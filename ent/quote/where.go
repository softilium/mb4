// Code generated by entc, DO NOT EDIT.

package quote

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/softilium/mb4/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// D applies equality check predicate on the "D" field. It's identical to DEQ.
func D(v time.Time) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldD), v))
	})
}

// O applies equality check predicate on the "O" field. It's identical to OEQ.
func O(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldO), v))
	})
}

// C applies equality check predicate on the "C" field. It's identical to CEQ.
func C(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldC), v))
	})
}

// H applies equality check predicate on the "H" field. It's identical to HEQ.
func H(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldH), v))
	})
}

// L applies equality check predicate on the "L" field. It's identical to LEQ.
func L(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldL), v))
	})
}

// V applies equality check predicate on the "V" field. It's identical to VEQ.
func V(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldV), v))
	})
}

// Cap applies equality check predicate on the "Cap" field. It's identical to CapEQ.
func Cap(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCap), v))
	})
}

// DivSum5Y applies equality check predicate on the "DivSum_5Y" field. It's identical to DivSum5YEQ.
func DivSum5Y(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDivSum5Y), v))
	})
}

// DivYield5Y applies equality check predicate on the "DivYield_5Y" field. It's identical to DivYield5YEQ.
func DivYield5Y(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDivYield5Y), v))
	})
}

// LotSize applies equality check predicate on the "LotSize" field. It's identical to LotSizeEQ.
func LotSize(v int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLotSize), v))
	})
}

// ListLevel applies equality check predicate on the "ListLevel" field. It's identical to ListLevelEQ.
func ListLevel(v int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldListLevel), v))
	})
}

// DEQ applies the EQ predicate on the "D" field.
func DEQ(v time.Time) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldD), v))
	})
}

// DNEQ applies the NEQ predicate on the "D" field.
func DNEQ(v time.Time) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldD), v))
	})
}

// DIn applies the In predicate on the "D" field.
func DIn(vs ...time.Time) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldD), v...))
	})
}

// DNotIn applies the NotIn predicate on the "D" field.
func DNotIn(vs ...time.Time) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldD), v...))
	})
}

// DGT applies the GT predicate on the "D" field.
func DGT(v time.Time) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldD), v))
	})
}

// DGTE applies the GTE predicate on the "D" field.
func DGTE(v time.Time) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldD), v))
	})
}

// DLT applies the LT predicate on the "D" field.
func DLT(v time.Time) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldD), v))
	})
}

// DLTE applies the LTE predicate on the "D" field.
func DLTE(v time.Time) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldD), v))
	})
}

// OEQ applies the EQ predicate on the "O" field.
func OEQ(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldO), v))
	})
}

// ONEQ applies the NEQ predicate on the "O" field.
func ONEQ(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldO), v))
	})
}

// OIn applies the In predicate on the "O" field.
func OIn(vs ...float64) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldO), v...))
	})
}

// ONotIn applies the NotIn predicate on the "O" field.
func ONotIn(vs ...float64) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldO), v...))
	})
}

// OGT applies the GT predicate on the "O" field.
func OGT(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldO), v))
	})
}

// OGTE applies the GTE predicate on the "O" field.
func OGTE(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldO), v))
	})
}

// OLT applies the LT predicate on the "O" field.
func OLT(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldO), v))
	})
}

// OLTE applies the LTE predicate on the "O" field.
func OLTE(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldO), v))
	})
}

// CEQ applies the EQ predicate on the "C" field.
func CEQ(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldC), v))
	})
}

// CNEQ applies the NEQ predicate on the "C" field.
func CNEQ(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldC), v))
	})
}

// CIn applies the In predicate on the "C" field.
func CIn(vs ...float64) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldC), v...))
	})
}

// CNotIn applies the NotIn predicate on the "C" field.
func CNotIn(vs ...float64) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldC), v...))
	})
}

// CGT applies the GT predicate on the "C" field.
func CGT(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldC), v))
	})
}

// CGTE applies the GTE predicate on the "C" field.
func CGTE(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldC), v))
	})
}

// CLT applies the LT predicate on the "C" field.
func CLT(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldC), v))
	})
}

// CLTE applies the LTE predicate on the "C" field.
func CLTE(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldC), v))
	})
}

// HEQ applies the EQ predicate on the "H" field.
func HEQ(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldH), v))
	})
}

// HNEQ applies the NEQ predicate on the "H" field.
func HNEQ(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldH), v))
	})
}

// HIn applies the In predicate on the "H" field.
func HIn(vs ...float64) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldH), v...))
	})
}

// HNotIn applies the NotIn predicate on the "H" field.
func HNotIn(vs ...float64) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldH), v...))
	})
}

// HGT applies the GT predicate on the "H" field.
func HGT(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldH), v))
	})
}

// HGTE applies the GTE predicate on the "H" field.
func HGTE(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldH), v))
	})
}

// HLT applies the LT predicate on the "H" field.
func HLT(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldH), v))
	})
}

// HLTE applies the LTE predicate on the "H" field.
func HLTE(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldH), v))
	})
}

// LEQ applies the EQ predicate on the "L" field.
func LEQ(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldL), v))
	})
}

// LNEQ applies the NEQ predicate on the "L" field.
func LNEQ(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldL), v))
	})
}

// LIn applies the In predicate on the "L" field.
func LIn(vs ...float64) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldL), v...))
	})
}

// LNotIn applies the NotIn predicate on the "L" field.
func LNotIn(vs ...float64) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldL), v...))
	})
}

// LGT applies the GT predicate on the "L" field.
func LGT(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldL), v))
	})
}

// LGTE applies the GTE predicate on the "L" field.
func LGTE(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldL), v))
	})
}

// LLT applies the LT predicate on the "L" field.
func LLT(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldL), v))
	})
}

// LLTE applies the LTE predicate on the "L" field.
func LLTE(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldL), v))
	})
}

// VEQ applies the EQ predicate on the "V" field.
func VEQ(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldV), v))
	})
}

// VNEQ applies the NEQ predicate on the "V" field.
func VNEQ(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldV), v))
	})
}

// VIn applies the In predicate on the "V" field.
func VIn(vs ...float64) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldV), v...))
	})
}

// VNotIn applies the NotIn predicate on the "V" field.
func VNotIn(vs ...float64) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldV), v...))
	})
}

// VGT applies the GT predicate on the "V" field.
func VGT(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldV), v))
	})
}

// VGTE applies the GTE predicate on the "V" field.
func VGTE(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldV), v))
	})
}

// VLT applies the LT predicate on the "V" field.
func VLT(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldV), v))
	})
}

// VLTE applies the LTE predicate on the "V" field.
func VLTE(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldV), v))
	})
}

// CapEQ applies the EQ predicate on the "Cap" field.
func CapEQ(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCap), v))
	})
}

// CapNEQ applies the NEQ predicate on the "Cap" field.
func CapNEQ(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCap), v))
	})
}

// CapIn applies the In predicate on the "Cap" field.
func CapIn(vs ...float64) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCap), v...))
	})
}

// CapNotIn applies the NotIn predicate on the "Cap" field.
func CapNotIn(vs ...float64) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCap), v...))
	})
}

// CapGT applies the GT predicate on the "Cap" field.
func CapGT(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCap), v))
	})
}

// CapGTE applies the GTE predicate on the "Cap" field.
func CapGTE(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCap), v))
	})
}

// CapLT applies the LT predicate on the "Cap" field.
func CapLT(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCap), v))
	})
}

// CapLTE applies the LTE predicate on the "Cap" field.
func CapLTE(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCap), v))
	})
}

// DivSum5YEQ applies the EQ predicate on the "DivSum_5Y" field.
func DivSum5YEQ(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDivSum5Y), v))
	})
}

// DivSum5YNEQ applies the NEQ predicate on the "DivSum_5Y" field.
func DivSum5YNEQ(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDivSum5Y), v))
	})
}

// DivSum5YIn applies the In predicate on the "DivSum_5Y" field.
func DivSum5YIn(vs ...float64) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDivSum5Y), v...))
	})
}

// DivSum5YNotIn applies the NotIn predicate on the "DivSum_5Y" field.
func DivSum5YNotIn(vs ...float64) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDivSum5Y), v...))
	})
}

// DivSum5YGT applies the GT predicate on the "DivSum_5Y" field.
func DivSum5YGT(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDivSum5Y), v))
	})
}

// DivSum5YGTE applies the GTE predicate on the "DivSum_5Y" field.
func DivSum5YGTE(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDivSum5Y), v))
	})
}

// DivSum5YLT applies the LT predicate on the "DivSum_5Y" field.
func DivSum5YLT(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDivSum5Y), v))
	})
}

// DivSum5YLTE applies the LTE predicate on the "DivSum_5Y" field.
func DivSum5YLTE(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDivSum5Y), v))
	})
}

// DivYield5YEQ applies the EQ predicate on the "DivYield_5Y" field.
func DivYield5YEQ(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDivYield5Y), v))
	})
}

// DivYield5YNEQ applies the NEQ predicate on the "DivYield_5Y" field.
func DivYield5YNEQ(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDivYield5Y), v))
	})
}

// DivYield5YIn applies the In predicate on the "DivYield_5Y" field.
func DivYield5YIn(vs ...float64) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDivYield5Y), v...))
	})
}

// DivYield5YNotIn applies the NotIn predicate on the "DivYield_5Y" field.
func DivYield5YNotIn(vs ...float64) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDivYield5Y), v...))
	})
}

// DivYield5YGT applies the GT predicate on the "DivYield_5Y" field.
func DivYield5YGT(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDivYield5Y), v))
	})
}

// DivYield5YGTE applies the GTE predicate on the "DivYield_5Y" field.
func DivYield5YGTE(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDivYield5Y), v))
	})
}

// DivYield5YLT applies the LT predicate on the "DivYield_5Y" field.
func DivYield5YLT(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDivYield5Y), v))
	})
}

// DivYield5YLTE applies the LTE predicate on the "DivYield_5Y" field.
func DivYield5YLTE(v float64) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDivYield5Y), v))
	})
}

// LotSizeEQ applies the EQ predicate on the "LotSize" field.
func LotSizeEQ(v int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLotSize), v))
	})
}

// LotSizeNEQ applies the NEQ predicate on the "LotSize" field.
func LotSizeNEQ(v int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLotSize), v))
	})
}

// LotSizeIn applies the In predicate on the "LotSize" field.
func LotSizeIn(vs ...int) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLotSize), v...))
	})
}

// LotSizeNotIn applies the NotIn predicate on the "LotSize" field.
func LotSizeNotIn(vs ...int) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLotSize), v...))
	})
}

// LotSizeGT applies the GT predicate on the "LotSize" field.
func LotSizeGT(v int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLotSize), v))
	})
}

// LotSizeGTE applies the GTE predicate on the "LotSize" field.
func LotSizeGTE(v int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLotSize), v))
	})
}

// LotSizeLT applies the LT predicate on the "LotSize" field.
func LotSizeLT(v int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLotSize), v))
	})
}

// LotSizeLTE applies the LTE predicate on the "LotSize" field.
func LotSizeLTE(v int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLotSize), v))
	})
}

// ListLevelEQ applies the EQ predicate on the "ListLevel" field.
func ListLevelEQ(v int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldListLevel), v))
	})
}

// ListLevelNEQ applies the NEQ predicate on the "ListLevel" field.
func ListLevelNEQ(v int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldListLevel), v))
	})
}

// ListLevelIn applies the In predicate on the "ListLevel" field.
func ListLevelIn(vs ...int) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldListLevel), v...))
	})
}

// ListLevelNotIn applies the NotIn predicate on the "ListLevel" field.
func ListLevelNotIn(vs ...int) predicate.Quote {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Quote(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldListLevel), v...))
	})
}

// ListLevelGT applies the GT predicate on the "ListLevel" field.
func ListLevelGT(v int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldListLevel), v))
	})
}

// ListLevelGTE applies the GTE predicate on the "ListLevel" field.
func ListLevelGTE(v int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldListLevel), v))
	})
}

// ListLevelLT applies the LT predicate on the "ListLevel" field.
func ListLevelLT(v int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldListLevel), v))
	})
}

// ListLevelLTE applies the LTE predicate on the "ListLevel" field.
func ListLevelLTE(v int) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldListLevel), v))
	})
}

// HasTicker applies the HasEdge predicate on the "Ticker" edge.
func HasTicker() predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(TickerTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, TickerTable, TickerColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasTickerWith applies the HasEdge predicate on the "Ticker" edge with a given conditions (other predicates).
func HasTickerWith(preds ...predicate.Ticker) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(TickerInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, TickerTable, TickerColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Quote) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Quote) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Quote) predicate.Quote {
	return predicate.Quote(func(s *sql.Selector) {
		p(s.Not())
	})
}
