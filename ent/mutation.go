// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/rs/xid"
	"github.com/softilium/mb4/ent/divpayout"
	"github.com/softilium/mb4/ent/emission"
	"github.com/softilium/mb4/ent/emitent"
	"github.com/softilium/mb4/ent/industry"
	"github.com/softilium/mb4/ent/investaccount"
	"github.com/softilium/mb4/ent/investaccountcashflow"
	"github.com/softilium/mb4/ent/investaccountvaluation"
	"github.com/softilium/mb4/ent/predicate"
	"github.com/softilium/mb4/ent/quote"
	"github.com/softilium/mb4/ent/report"
	"github.com/softilium/mb4/ent/strategy"
	"github.com/softilium/mb4/ent/strategyfactor"
	"github.com/softilium/mb4/ent/strategyfilter"
	"github.com/softilium/mb4/ent/strategyfixedticker"
	"github.com/softilium/mb4/ent/ticker"
	"github.com/softilium/mb4/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDivPayout              = "DivPayout"
	TypeEmission               = "Emission"
	TypeEmitent                = "Emitent"
	TypeIndustry               = "Industry"
	TypeInvestAccount          = "InvestAccount"
	TypeInvestAccountCashflow  = "InvestAccountCashflow"
	TypeInvestAccountValuation = "InvestAccountValuation"
	TypeQuote                  = "Quote"
	TypeReport                 = "Report"
	TypeStrategy               = "Strategy"
	TypeStrategyFactor         = "StrategyFactor"
	TypeStrategyFilter         = "StrategyFilter"
	TypeStrategyFixedTicker    = "StrategyFixedTicker"
	TypeTicker                 = "Ticker"
	TypeUser                   = "User"
)

// DivPayoutMutation represents an operation that mutates the DivPayout nodes in the graph.
type DivPayoutMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_ForYear        *int
	add_ForYear     *int
	_ForQuarter     *int
	add_ForQuarter  *int
	_CloseDate      *time.Time
	_Status         *int
	add_Status      *int
	_DPS            *float64
	add_DPS         *float64
	clearedFields   map[string]struct{}
	_Tickers        *string
	cleared_Tickers bool
	done            bool
	oldValue        func(context.Context) (*DivPayout, error)
	predicates      []predicate.DivPayout
}

var _ ent.Mutation = (*DivPayoutMutation)(nil)

// divpayoutOption allows management of the mutation configuration using functional options.
type divpayoutOption func(*DivPayoutMutation)

// newDivPayoutMutation creates new mutation for the DivPayout entity.
func newDivPayoutMutation(c config, op Op, opts ...divpayoutOption) *DivPayoutMutation {
	m := &DivPayoutMutation{
		config:        c,
		op:            op,
		typ:           TypeDivPayout,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDivPayoutID sets the ID field of the mutation.
func withDivPayoutID(id int) divpayoutOption {
	return func(m *DivPayoutMutation) {
		var (
			err   error
			once  sync.Once
			value *DivPayout
		)
		m.oldValue = func(ctx context.Context) (*DivPayout, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DivPayout.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDivPayout sets the old DivPayout of the mutation.
func withDivPayout(node *DivPayout) divpayoutOption {
	return func(m *DivPayoutMutation) {
		m.oldValue = func(context.Context) (*DivPayout, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DivPayoutMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DivPayoutMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DivPayoutMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DivPayoutMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DivPayout.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetForYear sets the "ForYear" field.
func (m *DivPayoutMutation) SetForYear(i int) {
	m._ForYear = &i
	m.add_ForYear = nil
}

// ForYear returns the value of the "ForYear" field in the mutation.
func (m *DivPayoutMutation) ForYear() (r int, exists bool) {
	v := m._ForYear
	if v == nil {
		return
	}
	return *v, true
}

// OldForYear returns the old "ForYear" field's value of the DivPayout entity.
// If the DivPayout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivPayoutMutation) OldForYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForYear: %w", err)
	}
	return oldValue.ForYear, nil
}

// AddForYear adds i to the "ForYear" field.
func (m *DivPayoutMutation) AddForYear(i int) {
	if m.add_ForYear != nil {
		*m.add_ForYear += i
	} else {
		m.add_ForYear = &i
	}
}

// AddedForYear returns the value that was added to the "ForYear" field in this mutation.
func (m *DivPayoutMutation) AddedForYear() (r int, exists bool) {
	v := m.add_ForYear
	if v == nil {
		return
	}
	return *v, true
}

// ResetForYear resets all changes to the "ForYear" field.
func (m *DivPayoutMutation) ResetForYear() {
	m._ForYear = nil
	m.add_ForYear = nil
}

// SetForQuarter sets the "ForQuarter" field.
func (m *DivPayoutMutation) SetForQuarter(i int) {
	m._ForQuarter = &i
	m.add_ForQuarter = nil
}

// ForQuarter returns the value of the "ForQuarter" field in the mutation.
func (m *DivPayoutMutation) ForQuarter() (r int, exists bool) {
	v := m._ForQuarter
	if v == nil {
		return
	}
	return *v, true
}

// OldForQuarter returns the old "ForQuarter" field's value of the DivPayout entity.
// If the DivPayout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivPayoutMutation) OldForQuarter(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForQuarter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForQuarter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForQuarter: %w", err)
	}
	return oldValue.ForQuarter, nil
}

// AddForQuarter adds i to the "ForQuarter" field.
func (m *DivPayoutMutation) AddForQuarter(i int) {
	if m.add_ForQuarter != nil {
		*m.add_ForQuarter += i
	} else {
		m.add_ForQuarter = &i
	}
}

// AddedForQuarter returns the value that was added to the "ForQuarter" field in this mutation.
func (m *DivPayoutMutation) AddedForQuarter() (r int, exists bool) {
	v := m.add_ForQuarter
	if v == nil {
		return
	}
	return *v, true
}

// ResetForQuarter resets all changes to the "ForQuarter" field.
func (m *DivPayoutMutation) ResetForQuarter() {
	m._ForQuarter = nil
	m.add_ForQuarter = nil
}

// SetCloseDate sets the "CloseDate" field.
func (m *DivPayoutMutation) SetCloseDate(t time.Time) {
	m._CloseDate = &t
}

// CloseDate returns the value of the "CloseDate" field in the mutation.
func (m *DivPayoutMutation) CloseDate() (r time.Time, exists bool) {
	v := m._CloseDate
	if v == nil {
		return
	}
	return *v, true
}

// OldCloseDate returns the old "CloseDate" field's value of the DivPayout entity.
// If the DivPayout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivPayoutMutation) OldCloseDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloseDate: %w", err)
	}
	return oldValue.CloseDate, nil
}

// ResetCloseDate resets all changes to the "CloseDate" field.
func (m *DivPayoutMutation) ResetCloseDate() {
	m._CloseDate = nil
}

// SetStatus sets the "Status" field.
func (m *DivPayoutMutation) SetStatus(i int) {
	m._Status = &i
	m.add_Status = nil
}

// Status returns the value of the "Status" field in the mutation.
func (m *DivPayoutMutation) Status() (r int, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the DivPayout entity.
// If the DivPayout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivPayoutMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "Status" field.
func (m *DivPayoutMutation) AddStatus(i int) {
	if m.add_Status != nil {
		*m.add_Status += i
	} else {
		m.add_Status = &i
	}
}

// AddedStatus returns the value that was added to the "Status" field in this mutation.
func (m *DivPayoutMutation) AddedStatus() (r int, exists bool) {
	v := m.add_Status
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "Status" field.
func (m *DivPayoutMutation) ResetStatus() {
	m._Status = nil
	m.add_Status = nil
}

// SetDPS sets the "DPS" field.
func (m *DivPayoutMutation) SetDPS(f float64) {
	m._DPS = &f
	m.add_DPS = nil
}

// DPS returns the value of the "DPS" field in the mutation.
func (m *DivPayoutMutation) DPS() (r float64, exists bool) {
	v := m._DPS
	if v == nil {
		return
	}
	return *v, true
}

// OldDPS returns the old "DPS" field's value of the DivPayout entity.
// If the DivPayout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivPayoutMutation) OldDPS(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDPS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDPS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDPS: %w", err)
	}
	return oldValue.DPS, nil
}

// AddDPS adds f to the "DPS" field.
func (m *DivPayoutMutation) AddDPS(f float64) {
	if m.add_DPS != nil {
		*m.add_DPS += f
	} else {
		m.add_DPS = &f
	}
}

// AddedDPS returns the value that was added to the "DPS" field in this mutation.
func (m *DivPayoutMutation) AddedDPS() (r float64, exists bool) {
	v := m.add_DPS
	if v == nil {
		return
	}
	return *v, true
}

// ResetDPS resets all changes to the "DPS" field.
func (m *DivPayoutMutation) ResetDPS() {
	m._DPS = nil
	m.add_DPS = nil
}

// SetTickersID sets the "Tickers" edge to the Ticker entity by id.
func (m *DivPayoutMutation) SetTickersID(id string) {
	m._Tickers = &id
}

// ClearTickers clears the "Tickers" edge to the Ticker entity.
func (m *DivPayoutMutation) ClearTickers() {
	m.cleared_Tickers = true
}

// TickersCleared reports if the "Tickers" edge to the Ticker entity was cleared.
func (m *DivPayoutMutation) TickersCleared() bool {
	return m.cleared_Tickers
}

// TickersID returns the "Tickers" edge ID in the mutation.
func (m *DivPayoutMutation) TickersID() (id string, exists bool) {
	if m._Tickers != nil {
		return *m._Tickers, true
	}
	return
}

// TickersIDs returns the "Tickers" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TickersID instead. It exists only for internal usage by the builders.
func (m *DivPayoutMutation) TickersIDs() (ids []string) {
	if id := m._Tickers; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTickers resets all changes to the "Tickers" edge.
func (m *DivPayoutMutation) ResetTickers() {
	m._Tickers = nil
	m.cleared_Tickers = false
}

// Where appends a list predicates to the DivPayoutMutation builder.
func (m *DivPayoutMutation) Where(ps ...predicate.DivPayout) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DivPayoutMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DivPayout).
func (m *DivPayoutMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DivPayoutMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._ForYear != nil {
		fields = append(fields, divpayout.FieldForYear)
	}
	if m._ForQuarter != nil {
		fields = append(fields, divpayout.FieldForQuarter)
	}
	if m._CloseDate != nil {
		fields = append(fields, divpayout.FieldCloseDate)
	}
	if m._Status != nil {
		fields = append(fields, divpayout.FieldStatus)
	}
	if m._DPS != nil {
		fields = append(fields, divpayout.FieldDPS)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DivPayoutMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case divpayout.FieldForYear:
		return m.ForYear()
	case divpayout.FieldForQuarter:
		return m.ForQuarter()
	case divpayout.FieldCloseDate:
		return m.CloseDate()
	case divpayout.FieldStatus:
		return m.Status()
	case divpayout.FieldDPS:
		return m.DPS()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DivPayoutMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case divpayout.FieldForYear:
		return m.OldForYear(ctx)
	case divpayout.FieldForQuarter:
		return m.OldForQuarter(ctx)
	case divpayout.FieldCloseDate:
		return m.OldCloseDate(ctx)
	case divpayout.FieldStatus:
		return m.OldStatus(ctx)
	case divpayout.FieldDPS:
		return m.OldDPS(ctx)
	}
	return nil, fmt.Errorf("unknown DivPayout field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DivPayoutMutation) SetField(name string, value ent.Value) error {
	switch name {
	case divpayout.FieldForYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForYear(v)
		return nil
	case divpayout.FieldForQuarter:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForQuarter(v)
		return nil
	case divpayout.FieldCloseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloseDate(v)
		return nil
	case divpayout.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case divpayout.FieldDPS:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDPS(v)
		return nil
	}
	return fmt.Errorf("unknown DivPayout field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DivPayoutMutation) AddedFields() []string {
	var fields []string
	if m.add_ForYear != nil {
		fields = append(fields, divpayout.FieldForYear)
	}
	if m.add_ForQuarter != nil {
		fields = append(fields, divpayout.FieldForQuarter)
	}
	if m.add_Status != nil {
		fields = append(fields, divpayout.FieldStatus)
	}
	if m.add_DPS != nil {
		fields = append(fields, divpayout.FieldDPS)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DivPayoutMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case divpayout.FieldForYear:
		return m.AddedForYear()
	case divpayout.FieldForQuarter:
		return m.AddedForQuarter()
	case divpayout.FieldStatus:
		return m.AddedStatus()
	case divpayout.FieldDPS:
		return m.AddedDPS()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DivPayoutMutation) AddField(name string, value ent.Value) error {
	switch name {
	case divpayout.FieldForYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddForYear(v)
		return nil
	case divpayout.FieldForQuarter:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddForQuarter(v)
		return nil
	case divpayout.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case divpayout.FieldDPS:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDPS(v)
		return nil
	}
	return fmt.Errorf("unknown DivPayout numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DivPayoutMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DivPayoutMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DivPayoutMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DivPayout nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DivPayoutMutation) ResetField(name string) error {
	switch name {
	case divpayout.FieldForYear:
		m.ResetForYear()
		return nil
	case divpayout.FieldForQuarter:
		m.ResetForQuarter()
		return nil
	case divpayout.FieldCloseDate:
		m.ResetCloseDate()
		return nil
	case divpayout.FieldStatus:
		m.ResetStatus()
		return nil
	case divpayout.FieldDPS:
		m.ResetDPS()
		return nil
	}
	return fmt.Errorf("unknown DivPayout field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DivPayoutMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Tickers != nil {
		edges = append(edges, divpayout.EdgeTickers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DivPayoutMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case divpayout.EdgeTickers:
		if id := m._Tickers; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DivPayoutMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DivPayoutMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DivPayoutMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Tickers {
		edges = append(edges, divpayout.EdgeTickers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DivPayoutMutation) EdgeCleared(name string) bool {
	switch name {
	case divpayout.EdgeTickers:
		return m.cleared_Tickers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DivPayoutMutation) ClearEdge(name string) error {
	switch name {
	case divpayout.EdgeTickers:
		m.ClearTickers()
		return nil
	}
	return fmt.Errorf("unknown DivPayout unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DivPayoutMutation) ResetEdge(name string) error {
	switch name {
	case divpayout.EdgeTickers:
		m.ResetTickers()
		return nil
	}
	return fmt.Errorf("unknown DivPayout edge %s", name)
}

// EmissionMutation represents an operation that mutates the Emission nodes in the graph.
type EmissionMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	_RecDate         *time.Time
	_Size            *int64
	add_Size         *int64
	_FreeFloat       *int
	add_FreeFloat    *int
	_LotSize         *int
	add_LotSize      *int
	_ListingLevel    *int
	add_ListingLevel *int
	clearedFields    map[string]struct{}
	_Ticker          *string
	cleared_Ticker   bool
	done             bool
	oldValue         func(context.Context) (*Emission, error)
	predicates       []predicate.Emission
}

var _ ent.Mutation = (*EmissionMutation)(nil)

// emissionOption allows management of the mutation configuration using functional options.
type emissionOption func(*EmissionMutation)

// newEmissionMutation creates new mutation for the Emission entity.
func newEmissionMutation(c config, op Op, opts ...emissionOption) *EmissionMutation {
	m := &EmissionMutation{
		config:        c,
		op:            op,
		typ:           TypeEmission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmissionID sets the ID field of the mutation.
func withEmissionID(id xid.ID) emissionOption {
	return func(m *EmissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Emission
		)
		m.oldValue = func(ctx context.Context) (*Emission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Emission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmission sets the old Emission of the mutation.
func withEmission(node *Emission) emissionOption {
	return func(m *EmissionMutation) {
		m.oldValue = func(context.Context) (*Emission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Emission entities.
func (m *EmissionMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmissionMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmissionMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Emission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRecDate sets the "RecDate" field.
func (m *EmissionMutation) SetRecDate(t time.Time) {
	m._RecDate = &t
}

// RecDate returns the value of the "RecDate" field in the mutation.
func (m *EmissionMutation) RecDate() (r time.Time, exists bool) {
	v := m._RecDate
	if v == nil {
		return
	}
	return *v, true
}

// OldRecDate returns the old "RecDate" field's value of the Emission entity.
// If the Emission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmissionMutation) OldRecDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecDate: %w", err)
	}
	return oldValue.RecDate, nil
}

// ResetRecDate resets all changes to the "RecDate" field.
func (m *EmissionMutation) ResetRecDate() {
	m._RecDate = nil
}

// SetSize sets the "Size" field.
func (m *EmissionMutation) SetSize(i int64) {
	m._Size = &i
	m.add_Size = nil
}

// Size returns the value of the "Size" field in the mutation.
func (m *EmissionMutation) Size() (r int64, exists bool) {
	v := m._Size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "Size" field's value of the Emission entity.
// If the Emission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmissionMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "Size" field.
func (m *EmissionMutation) AddSize(i int64) {
	if m.add_Size != nil {
		*m.add_Size += i
	} else {
		m.add_Size = &i
	}
}

// AddedSize returns the value that was added to the "Size" field in this mutation.
func (m *EmissionMutation) AddedSize() (r int64, exists bool) {
	v := m.add_Size
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "Size" field.
func (m *EmissionMutation) ResetSize() {
	m._Size = nil
	m.add_Size = nil
}

// SetFreeFloat sets the "FreeFloat" field.
func (m *EmissionMutation) SetFreeFloat(i int) {
	m._FreeFloat = &i
	m.add_FreeFloat = nil
}

// FreeFloat returns the value of the "FreeFloat" field in the mutation.
func (m *EmissionMutation) FreeFloat() (r int, exists bool) {
	v := m._FreeFloat
	if v == nil {
		return
	}
	return *v, true
}

// OldFreeFloat returns the old "FreeFloat" field's value of the Emission entity.
// If the Emission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmissionMutation) OldFreeFloat(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreeFloat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreeFloat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreeFloat: %w", err)
	}
	return oldValue.FreeFloat, nil
}

// AddFreeFloat adds i to the "FreeFloat" field.
func (m *EmissionMutation) AddFreeFloat(i int) {
	if m.add_FreeFloat != nil {
		*m.add_FreeFloat += i
	} else {
		m.add_FreeFloat = &i
	}
}

// AddedFreeFloat returns the value that was added to the "FreeFloat" field in this mutation.
func (m *EmissionMutation) AddedFreeFloat() (r int, exists bool) {
	v := m.add_FreeFloat
	if v == nil {
		return
	}
	return *v, true
}

// ClearFreeFloat clears the value of the "FreeFloat" field.
func (m *EmissionMutation) ClearFreeFloat() {
	m._FreeFloat = nil
	m.add_FreeFloat = nil
	m.clearedFields[emission.FieldFreeFloat] = struct{}{}
}

// FreeFloatCleared returns if the "FreeFloat" field was cleared in this mutation.
func (m *EmissionMutation) FreeFloatCleared() bool {
	_, ok := m.clearedFields[emission.FieldFreeFloat]
	return ok
}

// ResetFreeFloat resets all changes to the "FreeFloat" field.
func (m *EmissionMutation) ResetFreeFloat() {
	m._FreeFloat = nil
	m.add_FreeFloat = nil
	delete(m.clearedFields, emission.FieldFreeFloat)
}

// SetLotSize sets the "LotSize" field.
func (m *EmissionMutation) SetLotSize(i int) {
	m._LotSize = &i
	m.add_LotSize = nil
}

// LotSize returns the value of the "LotSize" field in the mutation.
func (m *EmissionMutation) LotSize() (r int, exists bool) {
	v := m._LotSize
	if v == nil {
		return
	}
	return *v, true
}

// OldLotSize returns the old "LotSize" field's value of the Emission entity.
// If the Emission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmissionMutation) OldLotSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLotSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLotSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLotSize: %w", err)
	}
	return oldValue.LotSize, nil
}

// AddLotSize adds i to the "LotSize" field.
func (m *EmissionMutation) AddLotSize(i int) {
	if m.add_LotSize != nil {
		*m.add_LotSize += i
	} else {
		m.add_LotSize = &i
	}
}

// AddedLotSize returns the value that was added to the "LotSize" field in this mutation.
func (m *EmissionMutation) AddedLotSize() (r int, exists bool) {
	v := m.add_LotSize
	if v == nil {
		return
	}
	return *v, true
}

// ClearLotSize clears the value of the "LotSize" field.
func (m *EmissionMutation) ClearLotSize() {
	m._LotSize = nil
	m.add_LotSize = nil
	m.clearedFields[emission.FieldLotSize] = struct{}{}
}

// LotSizeCleared returns if the "LotSize" field was cleared in this mutation.
func (m *EmissionMutation) LotSizeCleared() bool {
	_, ok := m.clearedFields[emission.FieldLotSize]
	return ok
}

// ResetLotSize resets all changes to the "LotSize" field.
func (m *EmissionMutation) ResetLotSize() {
	m._LotSize = nil
	m.add_LotSize = nil
	delete(m.clearedFields, emission.FieldLotSize)
}

// SetListingLevel sets the "ListingLevel" field.
func (m *EmissionMutation) SetListingLevel(i int) {
	m._ListingLevel = &i
	m.add_ListingLevel = nil
}

// ListingLevel returns the value of the "ListingLevel" field in the mutation.
func (m *EmissionMutation) ListingLevel() (r int, exists bool) {
	v := m._ListingLevel
	if v == nil {
		return
	}
	return *v, true
}

// OldListingLevel returns the old "ListingLevel" field's value of the Emission entity.
// If the Emission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmissionMutation) OldListingLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldListingLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldListingLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldListingLevel: %w", err)
	}
	return oldValue.ListingLevel, nil
}

// AddListingLevel adds i to the "ListingLevel" field.
func (m *EmissionMutation) AddListingLevel(i int) {
	if m.add_ListingLevel != nil {
		*m.add_ListingLevel += i
	} else {
		m.add_ListingLevel = &i
	}
}

// AddedListingLevel returns the value that was added to the "ListingLevel" field in this mutation.
func (m *EmissionMutation) AddedListingLevel() (r int, exists bool) {
	v := m.add_ListingLevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetListingLevel resets all changes to the "ListingLevel" field.
func (m *EmissionMutation) ResetListingLevel() {
	m._ListingLevel = nil
	m.add_ListingLevel = nil
}

// SetTickerID sets the "Ticker" edge to the Ticker entity by id.
func (m *EmissionMutation) SetTickerID(id string) {
	m._Ticker = &id
}

// ClearTicker clears the "Ticker" edge to the Ticker entity.
func (m *EmissionMutation) ClearTicker() {
	m.cleared_Ticker = true
}

// TickerCleared reports if the "Ticker" edge to the Ticker entity was cleared.
func (m *EmissionMutation) TickerCleared() bool {
	return m.cleared_Ticker
}

// TickerID returns the "Ticker" edge ID in the mutation.
func (m *EmissionMutation) TickerID() (id string, exists bool) {
	if m._Ticker != nil {
		return *m._Ticker, true
	}
	return
}

// TickerIDs returns the "Ticker" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TickerID instead. It exists only for internal usage by the builders.
func (m *EmissionMutation) TickerIDs() (ids []string) {
	if id := m._Ticker; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTicker resets all changes to the "Ticker" edge.
func (m *EmissionMutation) ResetTicker() {
	m._Ticker = nil
	m.cleared_Ticker = false
}

// Where appends a list predicates to the EmissionMutation builder.
func (m *EmissionMutation) Where(ps ...predicate.Emission) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EmissionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Emission).
func (m *EmissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmissionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._RecDate != nil {
		fields = append(fields, emission.FieldRecDate)
	}
	if m._Size != nil {
		fields = append(fields, emission.FieldSize)
	}
	if m._FreeFloat != nil {
		fields = append(fields, emission.FieldFreeFloat)
	}
	if m._LotSize != nil {
		fields = append(fields, emission.FieldLotSize)
	}
	if m._ListingLevel != nil {
		fields = append(fields, emission.FieldListingLevel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emission.FieldRecDate:
		return m.RecDate()
	case emission.FieldSize:
		return m.Size()
	case emission.FieldFreeFloat:
		return m.FreeFloat()
	case emission.FieldLotSize:
		return m.LotSize()
	case emission.FieldListingLevel:
		return m.ListingLevel()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emission.FieldRecDate:
		return m.OldRecDate(ctx)
	case emission.FieldSize:
		return m.OldSize(ctx)
	case emission.FieldFreeFloat:
		return m.OldFreeFloat(ctx)
	case emission.FieldLotSize:
		return m.OldLotSize(ctx)
	case emission.FieldListingLevel:
		return m.OldListingLevel(ctx)
	}
	return nil, fmt.Errorf("unknown Emission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emission.FieldRecDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecDate(v)
		return nil
	case emission.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case emission.FieldFreeFloat:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreeFloat(v)
		return nil
	case emission.FieldLotSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLotSize(v)
		return nil
	case emission.FieldListingLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetListingLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Emission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmissionMutation) AddedFields() []string {
	var fields []string
	if m.add_Size != nil {
		fields = append(fields, emission.FieldSize)
	}
	if m.add_FreeFloat != nil {
		fields = append(fields, emission.FieldFreeFloat)
	}
	if m.add_LotSize != nil {
		fields = append(fields, emission.FieldLotSize)
	}
	if m.add_ListingLevel != nil {
		fields = append(fields, emission.FieldListingLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case emission.FieldSize:
		return m.AddedSize()
	case emission.FieldFreeFloat:
		return m.AddedFreeFloat()
	case emission.FieldLotSize:
		return m.AddedLotSize()
	case emission.FieldListingLevel:
		return m.AddedListingLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case emission.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case emission.FieldFreeFloat:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFreeFloat(v)
		return nil
	case emission.FieldLotSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLotSize(v)
		return nil
	case emission.FieldListingLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddListingLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Emission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emission.FieldFreeFloat) {
		fields = append(fields, emission.FieldFreeFloat)
	}
	if m.FieldCleared(emission.FieldLotSize) {
		fields = append(fields, emission.FieldLotSize)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmissionMutation) ClearField(name string) error {
	switch name {
	case emission.FieldFreeFloat:
		m.ClearFreeFloat()
		return nil
	case emission.FieldLotSize:
		m.ClearLotSize()
		return nil
	}
	return fmt.Errorf("unknown Emission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmissionMutation) ResetField(name string) error {
	switch name {
	case emission.FieldRecDate:
		m.ResetRecDate()
		return nil
	case emission.FieldSize:
		m.ResetSize()
		return nil
	case emission.FieldFreeFloat:
		m.ResetFreeFloat()
		return nil
	case emission.FieldLotSize:
		m.ResetLotSize()
		return nil
	case emission.FieldListingLevel:
		m.ResetListingLevel()
		return nil
	}
	return fmt.Errorf("unknown Emission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Ticker != nil {
		edges = append(edges, emission.EdgeTicker)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emission.EdgeTicker:
		if id := m._Ticker; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Ticker {
		edges = append(edges, emission.EdgeTicker)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmissionMutation) EdgeCleared(name string) bool {
	switch name {
	case emission.EdgeTicker:
		return m.cleared_Ticker
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmissionMutation) ClearEdge(name string) error {
	switch name {
	case emission.EdgeTicker:
		m.ClearTicker()
		return nil
	}
	return fmt.Errorf("unknown Emission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmissionMutation) ResetEdge(name string) error {
	switch name {
	case emission.EdgeTicker:
		m.ResetTicker()
		return nil
	}
	return fmt.Errorf("unknown Emission edge %s", name)
}

// EmitentMutation represents an operation that mutates the Emitent nodes in the graph.
type EmitentMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	_Descr           *string
	clearedFields    map[string]struct{}
	_Industry        *string
	cleared_Industry bool
	_Tickers         map[string]struct{}
	removed_Tickers  map[string]struct{}
	cleared_Tickers  bool
	_Reports         map[xid.ID]struct{}
	removed_Reports  map[xid.ID]struct{}
	cleared_Reports  bool
	done             bool
	oldValue         func(context.Context) (*Emitent, error)
	predicates       []predicate.Emitent
}

var _ ent.Mutation = (*EmitentMutation)(nil)

// emitentOption allows management of the mutation configuration using functional options.
type emitentOption func(*EmitentMutation)

// newEmitentMutation creates new mutation for the Emitent entity.
func newEmitentMutation(c config, op Op, opts ...emitentOption) *EmitentMutation {
	m := &EmitentMutation{
		config:        c,
		op:            op,
		typ:           TypeEmitent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmitentID sets the ID field of the mutation.
func withEmitentID(id xid.ID) emitentOption {
	return func(m *EmitentMutation) {
		var (
			err   error
			once  sync.Once
			value *Emitent
		)
		m.oldValue = func(ctx context.Context) (*Emitent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Emitent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmitent sets the old Emitent of the mutation.
func withEmitent(node *Emitent) emitentOption {
	return func(m *EmitentMutation) {
		m.oldValue = func(context.Context) (*Emitent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmitentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmitentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Emitent entities.
func (m *EmitentMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmitentMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmitentMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Emitent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescr sets the "Descr" field.
func (m *EmitentMutation) SetDescr(s string) {
	m._Descr = &s
}

// Descr returns the value of the "Descr" field in the mutation.
func (m *EmitentMutation) Descr() (r string, exists bool) {
	v := m._Descr
	if v == nil {
		return
	}
	return *v, true
}

// OldDescr returns the old "Descr" field's value of the Emitent entity.
// If the Emitent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmitentMutation) OldDescr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescr: %w", err)
	}
	return oldValue.Descr, nil
}

// ResetDescr resets all changes to the "Descr" field.
func (m *EmitentMutation) ResetDescr() {
	m._Descr = nil
}

// SetIndustryID sets the "Industry" edge to the Industry entity by id.
func (m *EmitentMutation) SetIndustryID(id string) {
	m._Industry = &id
}

// ClearIndustry clears the "Industry" edge to the Industry entity.
func (m *EmitentMutation) ClearIndustry() {
	m.cleared_Industry = true
}

// IndustryCleared reports if the "Industry" edge to the Industry entity was cleared.
func (m *EmitentMutation) IndustryCleared() bool {
	return m.cleared_Industry
}

// IndustryID returns the "Industry" edge ID in the mutation.
func (m *EmitentMutation) IndustryID() (id string, exists bool) {
	if m._Industry != nil {
		return *m._Industry, true
	}
	return
}

// IndustryIDs returns the "Industry" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IndustryID instead. It exists only for internal usage by the builders.
func (m *EmitentMutation) IndustryIDs() (ids []string) {
	if id := m._Industry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIndustry resets all changes to the "Industry" edge.
func (m *EmitentMutation) ResetIndustry() {
	m._Industry = nil
	m.cleared_Industry = false
}

// AddTickerIDs adds the "Tickers" edge to the Ticker entity by ids.
func (m *EmitentMutation) AddTickerIDs(ids ...string) {
	if m._Tickers == nil {
		m._Tickers = make(map[string]struct{})
	}
	for i := range ids {
		m._Tickers[ids[i]] = struct{}{}
	}
}

// ClearTickers clears the "Tickers" edge to the Ticker entity.
func (m *EmitentMutation) ClearTickers() {
	m.cleared_Tickers = true
}

// TickersCleared reports if the "Tickers" edge to the Ticker entity was cleared.
func (m *EmitentMutation) TickersCleared() bool {
	return m.cleared_Tickers
}

// RemoveTickerIDs removes the "Tickers" edge to the Ticker entity by IDs.
func (m *EmitentMutation) RemoveTickerIDs(ids ...string) {
	if m.removed_Tickers == nil {
		m.removed_Tickers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m._Tickers, ids[i])
		m.removed_Tickers[ids[i]] = struct{}{}
	}
}

// RemovedTickers returns the removed IDs of the "Tickers" edge to the Ticker entity.
func (m *EmitentMutation) RemovedTickersIDs() (ids []string) {
	for id := range m.removed_Tickers {
		ids = append(ids, id)
	}
	return
}

// TickersIDs returns the "Tickers" edge IDs in the mutation.
func (m *EmitentMutation) TickersIDs() (ids []string) {
	for id := range m._Tickers {
		ids = append(ids, id)
	}
	return
}

// ResetTickers resets all changes to the "Tickers" edge.
func (m *EmitentMutation) ResetTickers() {
	m._Tickers = nil
	m.cleared_Tickers = false
	m.removed_Tickers = nil
}

// AddReportIDs adds the "Reports" edge to the Report entity by ids.
func (m *EmitentMutation) AddReportIDs(ids ...xid.ID) {
	if m._Reports == nil {
		m._Reports = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m._Reports[ids[i]] = struct{}{}
	}
}

// ClearReports clears the "Reports" edge to the Report entity.
func (m *EmitentMutation) ClearReports() {
	m.cleared_Reports = true
}

// ReportsCleared reports if the "Reports" edge to the Report entity was cleared.
func (m *EmitentMutation) ReportsCleared() bool {
	return m.cleared_Reports
}

// RemoveReportIDs removes the "Reports" edge to the Report entity by IDs.
func (m *EmitentMutation) RemoveReportIDs(ids ...xid.ID) {
	if m.removed_Reports == nil {
		m.removed_Reports = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m._Reports, ids[i])
		m.removed_Reports[ids[i]] = struct{}{}
	}
}

// RemovedReports returns the removed IDs of the "Reports" edge to the Report entity.
func (m *EmitentMutation) RemovedReportsIDs() (ids []xid.ID) {
	for id := range m.removed_Reports {
		ids = append(ids, id)
	}
	return
}

// ReportsIDs returns the "Reports" edge IDs in the mutation.
func (m *EmitentMutation) ReportsIDs() (ids []xid.ID) {
	for id := range m._Reports {
		ids = append(ids, id)
	}
	return
}

// ResetReports resets all changes to the "Reports" edge.
func (m *EmitentMutation) ResetReports() {
	m._Reports = nil
	m.cleared_Reports = false
	m.removed_Reports = nil
}

// Where appends a list predicates to the EmitentMutation builder.
func (m *EmitentMutation) Where(ps ...predicate.Emitent) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EmitentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Emitent).
func (m *EmitentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmitentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Descr != nil {
		fields = append(fields, emitent.FieldDescr)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmitentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emitent.FieldDescr:
		return m.Descr()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmitentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emitent.FieldDescr:
		return m.OldDescr(ctx)
	}
	return nil, fmt.Errorf("unknown Emitent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmitentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emitent.FieldDescr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescr(v)
		return nil
	}
	return fmt.Errorf("unknown Emitent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmitentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmitentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmitentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Emitent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmitentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmitentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmitentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Emitent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmitentMutation) ResetField(name string) error {
	switch name {
	case emitent.FieldDescr:
		m.ResetDescr()
		return nil
	}
	return fmt.Errorf("unknown Emitent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmitentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Industry != nil {
		edges = append(edges, emitent.EdgeIndustry)
	}
	if m._Tickers != nil {
		edges = append(edges, emitent.EdgeTickers)
	}
	if m._Reports != nil {
		edges = append(edges, emitent.EdgeReports)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmitentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emitent.EdgeIndustry:
		if id := m._Industry; id != nil {
			return []ent.Value{*id}
		}
	case emitent.EdgeTickers:
		ids := make([]ent.Value, 0, len(m._Tickers))
		for id := range m._Tickers {
			ids = append(ids, id)
		}
		return ids
	case emitent.EdgeReports:
		ids := make([]ent.Value, 0, len(m._Reports))
		for id := range m._Reports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmitentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_Tickers != nil {
		edges = append(edges, emitent.EdgeTickers)
	}
	if m.removed_Reports != nil {
		edges = append(edges, emitent.EdgeReports)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmitentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case emitent.EdgeTickers:
		ids := make([]ent.Value, 0, len(m.removed_Tickers))
		for id := range m.removed_Tickers {
			ids = append(ids, id)
		}
		return ids
	case emitent.EdgeReports:
		ids := make([]ent.Value, 0, len(m.removed_Reports))
		for id := range m.removed_Reports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmitentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Industry {
		edges = append(edges, emitent.EdgeIndustry)
	}
	if m.cleared_Tickers {
		edges = append(edges, emitent.EdgeTickers)
	}
	if m.cleared_Reports {
		edges = append(edges, emitent.EdgeReports)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmitentMutation) EdgeCleared(name string) bool {
	switch name {
	case emitent.EdgeIndustry:
		return m.cleared_Industry
	case emitent.EdgeTickers:
		return m.cleared_Tickers
	case emitent.EdgeReports:
		return m.cleared_Reports
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmitentMutation) ClearEdge(name string) error {
	switch name {
	case emitent.EdgeIndustry:
		m.ClearIndustry()
		return nil
	}
	return fmt.Errorf("unknown Emitent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmitentMutation) ResetEdge(name string) error {
	switch name {
	case emitent.EdgeIndustry:
		m.ResetIndustry()
		return nil
	case emitent.EdgeTickers:
		m.ResetTickers()
		return nil
	case emitent.EdgeReports:
		m.ResetReports()
		return nil
	}
	return fmt.Errorf("unknown Emitent edge %s", name)
}

// IndustryMutation represents an operation that mutates the Industry nodes in the graph.
type IndustryMutation struct {
	config
	op               Op
	typ              string
	id               *string
	_Descr           *string
	clearedFields    map[string]struct{}
	_Emitents        map[xid.ID]struct{}
	removed_Emitents map[xid.ID]struct{}
	cleared_Emitents bool
	done             bool
	oldValue         func(context.Context) (*Industry, error)
	predicates       []predicate.Industry
}

var _ ent.Mutation = (*IndustryMutation)(nil)

// industryOption allows management of the mutation configuration using functional options.
type industryOption func(*IndustryMutation)

// newIndustryMutation creates new mutation for the Industry entity.
func newIndustryMutation(c config, op Op, opts ...industryOption) *IndustryMutation {
	m := &IndustryMutation{
		config:        c,
		op:            op,
		typ:           TypeIndustry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIndustryID sets the ID field of the mutation.
func withIndustryID(id string) industryOption {
	return func(m *IndustryMutation) {
		var (
			err   error
			once  sync.Once
			value *Industry
		)
		m.oldValue = func(ctx context.Context) (*Industry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Industry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIndustry sets the old Industry of the mutation.
func withIndustry(node *Industry) industryOption {
	return func(m *IndustryMutation) {
		m.oldValue = func(context.Context) (*Industry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IndustryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IndustryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Industry entities.
func (m *IndustryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IndustryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IndustryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Industry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescr sets the "Descr" field.
func (m *IndustryMutation) SetDescr(s string) {
	m._Descr = &s
}

// Descr returns the value of the "Descr" field in the mutation.
func (m *IndustryMutation) Descr() (r string, exists bool) {
	v := m._Descr
	if v == nil {
		return
	}
	return *v, true
}

// OldDescr returns the old "Descr" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldDescr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescr: %w", err)
	}
	return oldValue.Descr, nil
}

// ResetDescr resets all changes to the "Descr" field.
func (m *IndustryMutation) ResetDescr() {
	m._Descr = nil
}

// AddEmitentIDs adds the "Emitents" edge to the Emitent entity by ids.
func (m *IndustryMutation) AddEmitentIDs(ids ...xid.ID) {
	if m._Emitents == nil {
		m._Emitents = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m._Emitents[ids[i]] = struct{}{}
	}
}

// ClearEmitents clears the "Emitents" edge to the Emitent entity.
func (m *IndustryMutation) ClearEmitents() {
	m.cleared_Emitents = true
}

// EmitentsCleared reports if the "Emitents" edge to the Emitent entity was cleared.
func (m *IndustryMutation) EmitentsCleared() bool {
	return m.cleared_Emitents
}

// RemoveEmitentIDs removes the "Emitents" edge to the Emitent entity by IDs.
func (m *IndustryMutation) RemoveEmitentIDs(ids ...xid.ID) {
	if m.removed_Emitents == nil {
		m.removed_Emitents = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m._Emitents, ids[i])
		m.removed_Emitents[ids[i]] = struct{}{}
	}
}

// RemovedEmitents returns the removed IDs of the "Emitents" edge to the Emitent entity.
func (m *IndustryMutation) RemovedEmitentsIDs() (ids []xid.ID) {
	for id := range m.removed_Emitents {
		ids = append(ids, id)
	}
	return
}

// EmitentsIDs returns the "Emitents" edge IDs in the mutation.
func (m *IndustryMutation) EmitentsIDs() (ids []xid.ID) {
	for id := range m._Emitents {
		ids = append(ids, id)
	}
	return
}

// ResetEmitents resets all changes to the "Emitents" edge.
func (m *IndustryMutation) ResetEmitents() {
	m._Emitents = nil
	m.cleared_Emitents = false
	m.removed_Emitents = nil
}

// Where appends a list predicates to the IndustryMutation builder.
func (m *IndustryMutation) Where(ps ...predicate.Industry) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *IndustryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Industry).
func (m *IndustryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IndustryMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Descr != nil {
		fields = append(fields, industry.FieldDescr)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IndustryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case industry.FieldDescr:
		return m.Descr()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IndustryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case industry.FieldDescr:
		return m.OldDescr(ctx)
	}
	return nil, fmt.Errorf("unknown Industry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IndustryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case industry.FieldDescr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescr(v)
		return nil
	}
	return fmt.Errorf("unknown Industry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IndustryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IndustryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IndustryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Industry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IndustryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IndustryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IndustryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Industry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IndustryMutation) ResetField(name string) error {
	switch name {
	case industry.FieldDescr:
		m.ResetDescr()
		return nil
	}
	return fmt.Errorf("unknown Industry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IndustryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Emitents != nil {
		edges = append(edges, industry.EdgeEmitents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IndustryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case industry.EdgeEmitents:
		ids := make([]ent.Value, 0, len(m._Emitents))
		for id := range m._Emitents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IndustryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Emitents != nil {
		edges = append(edges, industry.EdgeEmitents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IndustryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case industry.EdgeEmitents:
		ids := make([]ent.Value, 0, len(m.removed_Emitents))
		for id := range m.removed_Emitents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IndustryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Emitents {
		edges = append(edges, industry.EdgeEmitents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IndustryMutation) EdgeCleared(name string) bool {
	switch name {
	case industry.EdgeEmitents:
		return m.cleared_Emitents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IndustryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Industry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IndustryMutation) ResetEdge(name string) error {
	switch name {
	case industry.EdgeEmitents:
		m.ResetEmitents()
		return nil
	}
	return fmt.Errorf("unknown Industry edge %s", name)
}

// InvestAccountMutation represents an operation that mutates the InvestAccount nodes in the graph.
type InvestAccountMutation struct {
	config
	op                 Op
	typ                string
	id                 *xid.ID
	_Descr             *string
	clearedFields      map[string]struct{}
	_Owner             *xid.ID
	cleared_Owner      bool
	_Cashflows         map[xid.ID]struct{}
	removed_Cashflows  map[xid.ID]struct{}
	cleared_Cashflows  bool
	_Valuations        map[xid.ID]struct{}
	removed_Valuations map[xid.ID]struct{}
	cleared_Valuations bool
	done               bool
	oldValue           func(context.Context) (*InvestAccount, error)
	predicates         []predicate.InvestAccount
}

var _ ent.Mutation = (*InvestAccountMutation)(nil)

// investaccountOption allows management of the mutation configuration using functional options.
type investaccountOption func(*InvestAccountMutation)

// newInvestAccountMutation creates new mutation for the InvestAccount entity.
func newInvestAccountMutation(c config, op Op, opts ...investaccountOption) *InvestAccountMutation {
	m := &InvestAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeInvestAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvestAccountID sets the ID field of the mutation.
func withInvestAccountID(id xid.ID) investaccountOption {
	return func(m *InvestAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *InvestAccount
		)
		m.oldValue = func(ctx context.Context) (*InvestAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvestAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvestAccount sets the old InvestAccount of the mutation.
func withInvestAccount(node *InvestAccount) investaccountOption {
	return func(m *InvestAccountMutation) {
		m.oldValue = func(context.Context) (*InvestAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvestAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvestAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvestAccount entities.
func (m *InvestAccountMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvestAccountMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvestAccountMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvestAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescr sets the "Descr" field.
func (m *InvestAccountMutation) SetDescr(s string) {
	m._Descr = &s
}

// Descr returns the value of the "Descr" field in the mutation.
func (m *InvestAccountMutation) Descr() (r string, exists bool) {
	v := m._Descr
	if v == nil {
		return
	}
	return *v, true
}

// OldDescr returns the old "Descr" field's value of the InvestAccount entity.
// If the InvestAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestAccountMutation) OldDescr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescr: %w", err)
	}
	return oldValue.Descr, nil
}

// ResetDescr resets all changes to the "Descr" field.
func (m *InvestAccountMutation) ResetDescr() {
	m._Descr = nil
}

// SetOwnerID sets the "Owner" edge to the User entity by id.
func (m *InvestAccountMutation) SetOwnerID(id xid.ID) {
	m._Owner = &id
}

// ClearOwner clears the "Owner" edge to the User entity.
func (m *InvestAccountMutation) ClearOwner() {
	m.cleared_Owner = true
}

// OwnerCleared reports if the "Owner" edge to the User entity was cleared.
func (m *InvestAccountMutation) OwnerCleared() bool {
	return m.cleared_Owner
}

// OwnerID returns the "Owner" edge ID in the mutation.
func (m *InvestAccountMutation) OwnerID() (id xid.ID, exists bool) {
	if m._Owner != nil {
		return *m._Owner, true
	}
	return
}

// OwnerIDs returns the "Owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *InvestAccountMutation) OwnerIDs() (ids []xid.ID) {
	if id := m._Owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "Owner" edge.
func (m *InvestAccountMutation) ResetOwner() {
	m._Owner = nil
	m.cleared_Owner = false
}

// AddCashflowIDs adds the "Cashflows" edge to the InvestAccountCashflow entity by ids.
func (m *InvestAccountMutation) AddCashflowIDs(ids ...xid.ID) {
	if m._Cashflows == nil {
		m._Cashflows = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m._Cashflows[ids[i]] = struct{}{}
	}
}

// ClearCashflows clears the "Cashflows" edge to the InvestAccountCashflow entity.
func (m *InvestAccountMutation) ClearCashflows() {
	m.cleared_Cashflows = true
}

// CashflowsCleared reports if the "Cashflows" edge to the InvestAccountCashflow entity was cleared.
func (m *InvestAccountMutation) CashflowsCleared() bool {
	return m.cleared_Cashflows
}

// RemoveCashflowIDs removes the "Cashflows" edge to the InvestAccountCashflow entity by IDs.
func (m *InvestAccountMutation) RemoveCashflowIDs(ids ...xid.ID) {
	if m.removed_Cashflows == nil {
		m.removed_Cashflows = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m._Cashflows, ids[i])
		m.removed_Cashflows[ids[i]] = struct{}{}
	}
}

// RemovedCashflows returns the removed IDs of the "Cashflows" edge to the InvestAccountCashflow entity.
func (m *InvestAccountMutation) RemovedCashflowsIDs() (ids []xid.ID) {
	for id := range m.removed_Cashflows {
		ids = append(ids, id)
	}
	return
}

// CashflowsIDs returns the "Cashflows" edge IDs in the mutation.
func (m *InvestAccountMutation) CashflowsIDs() (ids []xid.ID) {
	for id := range m._Cashflows {
		ids = append(ids, id)
	}
	return
}

// ResetCashflows resets all changes to the "Cashflows" edge.
func (m *InvestAccountMutation) ResetCashflows() {
	m._Cashflows = nil
	m.cleared_Cashflows = false
	m.removed_Cashflows = nil
}

// AddValuationIDs adds the "Valuations" edge to the InvestAccountValuation entity by ids.
func (m *InvestAccountMutation) AddValuationIDs(ids ...xid.ID) {
	if m._Valuations == nil {
		m._Valuations = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m._Valuations[ids[i]] = struct{}{}
	}
}

// ClearValuations clears the "Valuations" edge to the InvestAccountValuation entity.
func (m *InvestAccountMutation) ClearValuations() {
	m.cleared_Valuations = true
}

// ValuationsCleared reports if the "Valuations" edge to the InvestAccountValuation entity was cleared.
func (m *InvestAccountMutation) ValuationsCleared() bool {
	return m.cleared_Valuations
}

// RemoveValuationIDs removes the "Valuations" edge to the InvestAccountValuation entity by IDs.
func (m *InvestAccountMutation) RemoveValuationIDs(ids ...xid.ID) {
	if m.removed_Valuations == nil {
		m.removed_Valuations = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m._Valuations, ids[i])
		m.removed_Valuations[ids[i]] = struct{}{}
	}
}

// RemovedValuations returns the removed IDs of the "Valuations" edge to the InvestAccountValuation entity.
func (m *InvestAccountMutation) RemovedValuationsIDs() (ids []xid.ID) {
	for id := range m.removed_Valuations {
		ids = append(ids, id)
	}
	return
}

// ValuationsIDs returns the "Valuations" edge IDs in the mutation.
func (m *InvestAccountMutation) ValuationsIDs() (ids []xid.ID) {
	for id := range m._Valuations {
		ids = append(ids, id)
	}
	return
}

// ResetValuations resets all changes to the "Valuations" edge.
func (m *InvestAccountMutation) ResetValuations() {
	m._Valuations = nil
	m.cleared_Valuations = false
	m.removed_Valuations = nil
}

// Where appends a list predicates to the InvestAccountMutation builder.
func (m *InvestAccountMutation) Where(ps ...predicate.InvestAccount) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InvestAccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InvestAccount).
func (m *InvestAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvestAccountMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Descr != nil {
		fields = append(fields, investaccount.FieldDescr)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvestAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case investaccount.FieldDescr:
		return m.Descr()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvestAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case investaccount.FieldDescr:
		return m.OldDescr(ctx)
	}
	return nil, fmt.Errorf("unknown InvestAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvestAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case investaccount.FieldDescr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescr(v)
		return nil
	}
	return fmt.Errorf("unknown InvestAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvestAccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvestAccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvestAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InvestAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvestAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvestAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvestAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InvestAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvestAccountMutation) ResetField(name string) error {
	switch name {
	case investaccount.FieldDescr:
		m.ResetDescr()
		return nil
	}
	return fmt.Errorf("unknown InvestAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvestAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Owner != nil {
		edges = append(edges, investaccount.EdgeOwner)
	}
	if m._Cashflows != nil {
		edges = append(edges, investaccount.EdgeCashflows)
	}
	if m._Valuations != nil {
		edges = append(edges, investaccount.EdgeValuations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvestAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case investaccount.EdgeOwner:
		if id := m._Owner; id != nil {
			return []ent.Value{*id}
		}
	case investaccount.EdgeCashflows:
		ids := make([]ent.Value, 0, len(m._Cashflows))
		for id := range m._Cashflows {
			ids = append(ids, id)
		}
		return ids
	case investaccount.EdgeValuations:
		ids := make([]ent.Value, 0, len(m._Valuations))
		for id := range m._Valuations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvestAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_Cashflows != nil {
		edges = append(edges, investaccount.EdgeCashflows)
	}
	if m.removed_Valuations != nil {
		edges = append(edges, investaccount.EdgeValuations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvestAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case investaccount.EdgeCashflows:
		ids := make([]ent.Value, 0, len(m.removed_Cashflows))
		for id := range m.removed_Cashflows {
			ids = append(ids, id)
		}
		return ids
	case investaccount.EdgeValuations:
		ids := make([]ent.Value, 0, len(m.removed_Valuations))
		for id := range m.removed_Valuations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvestAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Owner {
		edges = append(edges, investaccount.EdgeOwner)
	}
	if m.cleared_Cashflows {
		edges = append(edges, investaccount.EdgeCashflows)
	}
	if m.cleared_Valuations {
		edges = append(edges, investaccount.EdgeValuations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvestAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case investaccount.EdgeOwner:
		return m.cleared_Owner
	case investaccount.EdgeCashflows:
		return m.cleared_Cashflows
	case investaccount.EdgeValuations:
		return m.cleared_Valuations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvestAccountMutation) ClearEdge(name string) error {
	switch name {
	case investaccount.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown InvestAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvestAccountMutation) ResetEdge(name string) error {
	switch name {
	case investaccount.EdgeOwner:
		m.ResetOwner()
		return nil
	case investaccount.EdgeCashflows:
		m.ResetCashflows()
		return nil
	case investaccount.EdgeValuations:
		m.ResetValuations()
		return nil
	}
	return fmt.Errorf("unknown InvestAccount edge %s", name)
}

// InvestAccountCashflowMutation represents an operation that mutates the InvestAccountCashflow nodes in the graph.
type InvestAccountCashflowMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	_RecDate      *time.Time
	_Qty          *float64
	add_Qty       *float64
	clearedFields map[string]struct{}
	_Owner        *xid.ID
	cleared_Owner bool
	done          bool
	oldValue      func(context.Context) (*InvestAccountCashflow, error)
	predicates    []predicate.InvestAccountCashflow
}

var _ ent.Mutation = (*InvestAccountCashflowMutation)(nil)

// investaccountcashflowOption allows management of the mutation configuration using functional options.
type investaccountcashflowOption func(*InvestAccountCashflowMutation)

// newInvestAccountCashflowMutation creates new mutation for the InvestAccountCashflow entity.
func newInvestAccountCashflowMutation(c config, op Op, opts ...investaccountcashflowOption) *InvestAccountCashflowMutation {
	m := &InvestAccountCashflowMutation{
		config:        c,
		op:            op,
		typ:           TypeInvestAccountCashflow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvestAccountCashflowID sets the ID field of the mutation.
func withInvestAccountCashflowID(id xid.ID) investaccountcashflowOption {
	return func(m *InvestAccountCashflowMutation) {
		var (
			err   error
			once  sync.Once
			value *InvestAccountCashflow
		)
		m.oldValue = func(ctx context.Context) (*InvestAccountCashflow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvestAccountCashflow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvestAccountCashflow sets the old InvestAccountCashflow of the mutation.
func withInvestAccountCashflow(node *InvestAccountCashflow) investaccountcashflowOption {
	return func(m *InvestAccountCashflowMutation) {
		m.oldValue = func(context.Context) (*InvestAccountCashflow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvestAccountCashflowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvestAccountCashflowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvestAccountCashflow entities.
func (m *InvestAccountCashflowMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvestAccountCashflowMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvestAccountCashflowMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvestAccountCashflow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRecDate sets the "RecDate" field.
func (m *InvestAccountCashflowMutation) SetRecDate(t time.Time) {
	m._RecDate = &t
}

// RecDate returns the value of the "RecDate" field in the mutation.
func (m *InvestAccountCashflowMutation) RecDate() (r time.Time, exists bool) {
	v := m._RecDate
	if v == nil {
		return
	}
	return *v, true
}

// OldRecDate returns the old "RecDate" field's value of the InvestAccountCashflow entity.
// If the InvestAccountCashflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestAccountCashflowMutation) OldRecDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecDate: %w", err)
	}
	return oldValue.RecDate, nil
}

// ResetRecDate resets all changes to the "RecDate" field.
func (m *InvestAccountCashflowMutation) ResetRecDate() {
	m._RecDate = nil
}

// SetQty sets the "Qty" field.
func (m *InvestAccountCashflowMutation) SetQty(f float64) {
	m._Qty = &f
	m.add_Qty = nil
}

// Qty returns the value of the "Qty" field in the mutation.
func (m *InvestAccountCashflowMutation) Qty() (r float64, exists bool) {
	v := m._Qty
	if v == nil {
		return
	}
	return *v, true
}

// OldQty returns the old "Qty" field's value of the InvestAccountCashflow entity.
// If the InvestAccountCashflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestAccountCashflowMutation) OldQty(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQty: %w", err)
	}
	return oldValue.Qty, nil
}

// AddQty adds f to the "Qty" field.
func (m *InvestAccountCashflowMutation) AddQty(f float64) {
	if m.add_Qty != nil {
		*m.add_Qty += f
	} else {
		m.add_Qty = &f
	}
}

// AddedQty returns the value that was added to the "Qty" field in this mutation.
func (m *InvestAccountCashflowMutation) AddedQty() (r float64, exists bool) {
	v := m.add_Qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetQty resets all changes to the "Qty" field.
func (m *InvestAccountCashflowMutation) ResetQty() {
	m._Qty = nil
	m.add_Qty = nil
}

// SetOwnerID sets the "Owner" edge to the InvestAccount entity by id.
func (m *InvestAccountCashflowMutation) SetOwnerID(id xid.ID) {
	m._Owner = &id
}

// ClearOwner clears the "Owner" edge to the InvestAccount entity.
func (m *InvestAccountCashflowMutation) ClearOwner() {
	m.cleared_Owner = true
}

// OwnerCleared reports if the "Owner" edge to the InvestAccount entity was cleared.
func (m *InvestAccountCashflowMutation) OwnerCleared() bool {
	return m.cleared_Owner
}

// OwnerID returns the "Owner" edge ID in the mutation.
func (m *InvestAccountCashflowMutation) OwnerID() (id xid.ID, exists bool) {
	if m._Owner != nil {
		return *m._Owner, true
	}
	return
}

// OwnerIDs returns the "Owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *InvestAccountCashflowMutation) OwnerIDs() (ids []xid.ID) {
	if id := m._Owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "Owner" edge.
func (m *InvestAccountCashflowMutation) ResetOwner() {
	m._Owner = nil
	m.cleared_Owner = false
}

// Where appends a list predicates to the InvestAccountCashflowMutation builder.
func (m *InvestAccountCashflowMutation) Where(ps ...predicate.InvestAccountCashflow) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InvestAccountCashflowMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InvestAccountCashflow).
func (m *InvestAccountCashflowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvestAccountCashflowMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._RecDate != nil {
		fields = append(fields, investaccountcashflow.FieldRecDate)
	}
	if m._Qty != nil {
		fields = append(fields, investaccountcashflow.FieldQty)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvestAccountCashflowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case investaccountcashflow.FieldRecDate:
		return m.RecDate()
	case investaccountcashflow.FieldQty:
		return m.Qty()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvestAccountCashflowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case investaccountcashflow.FieldRecDate:
		return m.OldRecDate(ctx)
	case investaccountcashflow.FieldQty:
		return m.OldQty(ctx)
	}
	return nil, fmt.Errorf("unknown InvestAccountCashflow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvestAccountCashflowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case investaccountcashflow.FieldRecDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecDate(v)
		return nil
	case investaccountcashflow.FieldQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQty(v)
		return nil
	}
	return fmt.Errorf("unknown InvestAccountCashflow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvestAccountCashflowMutation) AddedFields() []string {
	var fields []string
	if m.add_Qty != nil {
		fields = append(fields, investaccountcashflow.FieldQty)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvestAccountCashflowMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case investaccountcashflow.FieldQty:
		return m.AddedQty()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvestAccountCashflowMutation) AddField(name string, value ent.Value) error {
	switch name {
	case investaccountcashflow.FieldQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQty(v)
		return nil
	}
	return fmt.Errorf("unknown InvestAccountCashflow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvestAccountCashflowMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvestAccountCashflowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvestAccountCashflowMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InvestAccountCashflow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvestAccountCashflowMutation) ResetField(name string) error {
	switch name {
	case investaccountcashflow.FieldRecDate:
		m.ResetRecDate()
		return nil
	case investaccountcashflow.FieldQty:
		m.ResetQty()
		return nil
	}
	return fmt.Errorf("unknown InvestAccountCashflow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvestAccountCashflowMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Owner != nil {
		edges = append(edges, investaccountcashflow.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvestAccountCashflowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case investaccountcashflow.EdgeOwner:
		if id := m._Owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvestAccountCashflowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvestAccountCashflowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvestAccountCashflowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Owner {
		edges = append(edges, investaccountcashflow.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvestAccountCashflowMutation) EdgeCleared(name string) bool {
	switch name {
	case investaccountcashflow.EdgeOwner:
		return m.cleared_Owner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvestAccountCashflowMutation) ClearEdge(name string) error {
	switch name {
	case investaccountcashflow.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown InvestAccountCashflow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvestAccountCashflowMutation) ResetEdge(name string) error {
	switch name {
	case investaccountcashflow.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown InvestAccountCashflow edge %s", name)
}

// InvestAccountValuationMutation represents an operation that mutates the InvestAccountValuation nodes in the graph.
type InvestAccountValuationMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	_RecDate      *time.Time
	_Value        *float64
	add_Value     *float64
	clearedFields map[string]struct{}
	_Owner        *xid.ID
	cleared_Owner bool
	done          bool
	oldValue      func(context.Context) (*InvestAccountValuation, error)
	predicates    []predicate.InvestAccountValuation
}

var _ ent.Mutation = (*InvestAccountValuationMutation)(nil)

// investaccountvaluationOption allows management of the mutation configuration using functional options.
type investaccountvaluationOption func(*InvestAccountValuationMutation)

// newInvestAccountValuationMutation creates new mutation for the InvestAccountValuation entity.
func newInvestAccountValuationMutation(c config, op Op, opts ...investaccountvaluationOption) *InvestAccountValuationMutation {
	m := &InvestAccountValuationMutation{
		config:        c,
		op:            op,
		typ:           TypeInvestAccountValuation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvestAccountValuationID sets the ID field of the mutation.
func withInvestAccountValuationID(id xid.ID) investaccountvaluationOption {
	return func(m *InvestAccountValuationMutation) {
		var (
			err   error
			once  sync.Once
			value *InvestAccountValuation
		)
		m.oldValue = func(ctx context.Context) (*InvestAccountValuation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvestAccountValuation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvestAccountValuation sets the old InvestAccountValuation of the mutation.
func withInvestAccountValuation(node *InvestAccountValuation) investaccountvaluationOption {
	return func(m *InvestAccountValuationMutation) {
		m.oldValue = func(context.Context) (*InvestAccountValuation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvestAccountValuationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvestAccountValuationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvestAccountValuation entities.
func (m *InvestAccountValuationMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvestAccountValuationMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvestAccountValuationMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvestAccountValuation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRecDate sets the "RecDate" field.
func (m *InvestAccountValuationMutation) SetRecDate(t time.Time) {
	m._RecDate = &t
}

// RecDate returns the value of the "RecDate" field in the mutation.
func (m *InvestAccountValuationMutation) RecDate() (r time.Time, exists bool) {
	v := m._RecDate
	if v == nil {
		return
	}
	return *v, true
}

// OldRecDate returns the old "RecDate" field's value of the InvestAccountValuation entity.
// If the InvestAccountValuation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestAccountValuationMutation) OldRecDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecDate: %w", err)
	}
	return oldValue.RecDate, nil
}

// ResetRecDate resets all changes to the "RecDate" field.
func (m *InvestAccountValuationMutation) ResetRecDate() {
	m._RecDate = nil
}

// SetValue sets the "Value" field.
func (m *InvestAccountValuationMutation) SetValue(f float64) {
	m._Value = &f
	m.add_Value = nil
}

// Value returns the value of the "Value" field in the mutation.
func (m *InvestAccountValuationMutation) Value() (r float64, exists bool) {
	v := m._Value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "Value" field's value of the InvestAccountValuation entity.
// If the InvestAccountValuation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestAccountValuationMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "Value" field.
func (m *InvestAccountValuationMutation) AddValue(f float64) {
	if m.add_Value != nil {
		*m.add_Value += f
	} else {
		m.add_Value = &f
	}
}

// AddedValue returns the value that was added to the "Value" field in this mutation.
func (m *InvestAccountValuationMutation) AddedValue() (r float64, exists bool) {
	v := m.add_Value
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "Value" field.
func (m *InvestAccountValuationMutation) ResetValue() {
	m._Value = nil
	m.add_Value = nil
}

// SetOwnerID sets the "Owner" edge to the InvestAccount entity by id.
func (m *InvestAccountValuationMutation) SetOwnerID(id xid.ID) {
	m._Owner = &id
}

// ClearOwner clears the "Owner" edge to the InvestAccount entity.
func (m *InvestAccountValuationMutation) ClearOwner() {
	m.cleared_Owner = true
}

// OwnerCleared reports if the "Owner" edge to the InvestAccount entity was cleared.
func (m *InvestAccountValuationMutation) OwnerCleared() bool {
	return m.cleared_Owner
}

// OwnerID returns the "Owner" edge ID in the mutation.
func (m *InvestAccountValuationMutation) OwnerID() (id xid.ID, exists bool) {
	if m._Owner != nil {
		return *m._Owner, true
	}
	return
}

// OwnerIDs returns the "Owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *InvestAccountValuationMutation) OwnerIDs() (ids []xid.ID) {
	if id := m._Owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "Owner" edge.
func (m *InvestAccountValuationMutation) ResetOwner() {
	m._Owner = nil
	m.cleared_Owner = false
}

// Where appends a list predicates to the InvestAccountValuationMutation builder.
func (m *InvestAccountValuationMutation) Where(ps ...predicate.InvestAccountValuation) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InvestAccountValuationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InvestAccountValuation).
func (m *InvestAccountValuationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvestAccountValuationMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._RecDate != nil {
		fields = append(fields, investaccountvaluation.FieldRecDate)
	}
	if m._Value != nil {
		fields = append(fields, investaccountvaluation.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvestAccountValuationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case investaccountvaluation.FieldRecDate:
		return m.RecDate()
	case investaccountvaluation.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvestAccountValuationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case investaccountvaluation.FieldRecDate:
		return m.OldRecDate(ctx)
	case investaccountvaluation.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown InvestAccountValuation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvestAccountValuationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case investaccountvaluation.FieldRecDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecDate(v)
		return nil
	case investaccountvaluation.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown InvestAccountValuation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvestAccountValuationMutation) AddedFields() []string {
	var fields []string
	if m.add_Value != nil {
		fields = append(fields, investaccountvaluation.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvestAccountValuationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case investaccountvaluation.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvestAccountValuationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case investaccountvaluation.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown InvestAccountValuation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvestAccountValuationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvestAccountValuationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvestAccountValuationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InvestAccountValuation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvestAccountValuationMutation) ResetField(name string) error {
	switch name {
	case investaccountvaluation.FieldRecDate:
		m.ResetRecDate()
		return nil
	case investaccountvaluation.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown InvestAccountValuation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvestAccountValuationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Owner != nil {
		edges = append(edges, investaccountvaluation.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvestAccountValuationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case investaccountvaluation.EdgeOwner:
		if id := m._Owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvestAccountValuationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvestAccountValuationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvestAccountValuationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Owner {
		edges = append(edges, investaccountvaluation.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvestAccountValuationMutation) EdgeCleared(name string) bool {
	switch name {
	case investaccountvaluation.EdgeOwner:
		return m.cleared_Owner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvestAccountValuationMutation) ClearEdge(name string) error {
	switch name {
	case investaccountvaluation.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown InvestAccountValuation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvestAccountValuationMutation) ResetEdge(name string) error {
	switch name {
	case investaccountvaluation.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown InvestAccountValuation edge %s", name)
}

// QuoteMutation represents an operation that mutates the Quote nodes in the graph.
type QuoteMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	_D             *time.Time
	_O             *float64
	add_O          *float64
	_C             *float64
	add_C          *float64
	_H             *float64
	add_H          *float64
	_L             *float64
	add_L          *float64
	_V             *float64
	add_V          *float64
	clearedFields  map[string]struct{}
	_Ticker        *string
	cleared_Ticker bool
	done           bool
	oldValue       func(context.Context) (*Quote, error)
	predicates     []predicate.Quote
}

var _ ent.Mutation = (*QuoteMutation)(nil)

// quoteOption allows management of the mutation configuration using functional options.
type quoteOption func(*QuoteMutation)

// newQuoteMutation creates new mutation for the Quote entity.
func newQuoteMutation(c config, op Op, opts ...quoteOption) *QuoteMutation {
	m := &QuoteMutation{
		config:        c,
		op:            op,
		typ:           TypeQuote,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQuoteID sets the ID field of the mutation.
func withQuoteID(id xid.ID) quoteOption {
	return func(m *QuoteMutation) {
		var (
			err   error
			once  sync.Once
			value *Quote
		)
		m.oldValue = func(ctx context.Context) (*Quote, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Quote.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQuote sets the old Quote of the mutation.
func withQuote(node *Quote) quoteOption {
	return func(m *QuoteMutation) {
		m.oldValue = func(context.Context) (*Quote, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QuoteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QuoteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Quote entities.
func (m *QuoteMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *QuoteMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *QuoteMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Quote.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetD sets the "D" field.
func (m *QuoteMutation) SetD(t time.Time) {
	m._D = &t
}

// D returns the value of the "D" field in the mutation.
func (m *QuoteMutation) D() (r time.Time, exists bool) {
	v := m._D
	if v == nil {
		return
	}
	return *v, true
}

// OldD returns the old "D" field's value of the Quote entity.
// If the Quote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuoteMutation) OldD(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldD is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldD requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldD: %w", err)
	}
	return oldValue.D, nil
}

// ResetD resets all changes to the "D" field.
func (m *QuoteMutation) ResetD() {
	m._D = nil
}

// SetO sets the "O" field.
func (m *QuoteMutation) SetO(f float64) {
	m._O = &f
	m.add_O = nil
}

// O returns the value of the "O" field in the mutation.
func (m *QuoteMutation) O() (r float64, exists bool) {
	v := m._O
	if v == nil {
		return
	}
	return *v, true
}

// OldO returns the old "O" field's value of the Quote entity.
// If the Quote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuoteMutation) OldO(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldO is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldO requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldO: %w", err)
	}
	return oldValue.O, nil
}

// AddO adds f to the "O" field.
func (m *QuoteMutation) AddO(f float64) {
	if m.add_O != nil {
		*m.add_O += f
	} else {
		m.add_O = &f
	}
}

// AddedO returns the value that was added to the "O" field in this mutation.
func (m *QuoteMutation) AddedO() (r float64, exists bool) {
	v := m.add_O
	if v == nil {
		return
	}
	return *v, true
}

// ResetO resets all changes to the "O" field.
func (m *QuoteMutation) ResetO() {
	m._O = nil
	m.add_O = nil
}

// SetC sets the "C" field.
func (m *QuoteMutation) SetC(f float64) {
	m._C = &f
	m.add_C = nil
}

// C returns the value of the "C" field in the mutation.
func (m *QuoteMutation) C() (r float64, exists bool) {
	v := m._C
	if v == nil {
		return
	}
	return *v, true
}

// OldC returns the old "C" field's value of the Quote entity.
// If the Quote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuoteMutation) OldC(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldC: %w", err)
	}
	return oldValue.C, nil
}

// AddC adds f to the "C" field.
func (m *QuoteMutation) AddC(f float64) {
	if m.add_C != nil {
		*m.add_C += f
	} else {
		m.add_C = &f
	}
}

// AddedC returns the value that was added to the "C" field in this mutation.
func (m *QuoteMutation) AddedC() (r float64, exists bool) {
	v := m.add_C
	if v == nil {
		return
	}
	return *v, true
}

// ResetC resets all changes to the "C" field.
func (m *QuoteMutation) ResetC() {
	m._C = nil
	m.add_C = nil
}

// SetH sets the "H" field.
func (m *QuoteMutation) SetH(f float64) {
	m._H = &f
	m.add_H = nil
}

// H returns the value of the "H" field in the mutation.
func (m *QuoteMutation) H() (r float64, exists bool) {
	v := m._H
	if v == nil {
		return
	}
	return *v, true
}

// OldH returns the old "H" field's value of the Quote entity.
// If the Quote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuoteMutation) OldH(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldH is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldH requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldH: %w", err)
	}
	return oldValue.H, nil
}

// AddH adds f to the "H" field.
func (m *QuoteMutation) AddH(f float64) {
	if m.add_H != nil {
		*m.add_H += f
	} else {
		m.add_H = &f
	}
}

// AddedH returns the value that was added to the "H" field in this mutation.
func (m *QuoteMutation) AddedH() (r float64, exists bool) {
	v := m.add_H
	if v == nil {
		return
	}
	return *v, true
}

// ResetH resets all changes to the "H" field.
func (m *QuoteMutation) ResetH() {
	m._H = nil
	m.add_H = nil
}

// SetL sets the "L" field.
func (m *QuoteMutation) SetL(f float64) {
	m._L = &f
	m.add_L = nil
}

// L returns the value of the "L" field in the mutation.
func (m *QuoteMutation) L() (r float64, exists bool) {
	v := m._L
	if v == nil {
		return
	}
	return *v, true
}

// OldL returns the old "L" field's value of the Quote entity.
// If the Quote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuoteMutation) OldL(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldL: %w", err)
	}
	return oldValue.L, nil
}

// AddL adds f to the "L" field.
func (m *QuoteMutation) AddL(f float64) {
	if m.add_L != nil {
		*m.add_L += f
	} else {
		m.add_L = &f
	}
}

// AddedL returns the value that was added to the "L" field in this mutation.
func (m *QuoteMutation) AddedL() (r float64, exists bool) {
	v := m.add_L
	if v == nil {
		return
	}
	return *v, true
}

// ResetL resets all changes to the "L" field.
func (m *QuoteMutation) ResetL() {
	m._L = nil
	m.add_L = nil
}

// SetV sets the "V" field.
func (m *QuoteMutation) SetV(f float64) {
	m._V = &f
	m.add_V = nil
}

// V returns the value of the "V" field in the mutation.
func (m *QuoteMutation) V() (r float64, exists bool) {
	v := m._V
	if v == nil {
		return
	}
	return *v, true
}

// OldV returns the old "V" field's value of the Quote entity.
// If the Quote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuoteMutation) OldV(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldV is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldV requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldV: %w", err)
	}
	return oldValue.V, nil
}

// AddV adds f to the "V" field.
func (m *QuoteMutation) AddV(f float64) {
	if m.add_V != nil {
		*m.add_V += f
	} else {
		m.add_V = &f
	}
}

// AddedV returns the value that was added to the "V" field in this mutation.
func (m *QuoteMutation) AddedV() (r float64, exists bool) {
	v := m.add_V
	if v == nil {
		return
	}
	return *v, true
}

// ResetV resets all changes to the "V" field.
func (m *QuoteMutation) ResetV() {
	m._V = nil
	m.add_V = nil
}

// SetTickerID sets the "Ticker" edge to the Ticker entity by id.
func (m *QuoteMutation) SetTickerID(id string) {
	m._Ticker = &id
}

// ClearTicker clears the "Ticker" edge to the Ticker entity.
func (m *QuoteMutation) ClearTicker() {
	m.cleared_Ticker = true
}

// TickerCleared reports if the "Ticker" edge to the Ticker entity was cleared.
func (m *QuoteMutation) TickerCleared() bool {
	return m.cleared_Ticker
}

// TickerID returns the "Ticker" edge ID in the mutation.
func (m *QuoteMutation) TickerID() (id string, exists bool) {
	if m._Ticker != nil {
		return *m._Ticker, true
	}
	return
}

// TickerIDs returns the "Ticker" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TickerID instead. It exists only for internal usage by the builders.
func (m *QuoteMutation) TickerIDs() (ids []string) {
	if id := m._Ticker; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTicker resets all changes to the "Ticker" edge.
func (m *QuoteMutation) ResetTicker() {
	m._Ticker = nil
	m.cleared_Ticker = false
}

// Where appends a list predicates to the QuoteMutation builder.
func (m *QuoteMutation) Where(ps ...predicate.Quote) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *QuoteMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Quote).
func (m *QuoteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *QuoteMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._D != nil {
		fields = append(fields, quote.FieldD)
	}
	if m._O != nil {
		fields = append(fields, quote.FieldO)
	}
	if m._C != nil {
		fields = append(fields, quote.FieldC)
	}
	if m._H != nil {
		fields = append(fields, quote.FieldH)
	}
	if m._L != nil {
		fields = append(fields, quote.FieldL)
	}
	if m._V != nil {
		fields = append(fields, quote.FieldV)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *QuoteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case quote.FieldD:
		return m.D()
	case quote.FieldO:
		return m.O()
	case quote.FieldC:
		return m.C()
	case quote.FieldH:
		return m.H()
	case quote.FieldL:
		return m.L()
	case quote.FieldV:
		return m.V()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *QuoteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case quote.FieldD:
		return m.OldD(ctx)
	case quote.FieldO:
		return m.OldO(ctx)
	case quote.FieldC:
		return m.OldC(ctx)
	case quote.FieldH:
		return m.OldH(ctx)
	case quote.FieldL:
		return m.OldL(ctx)
	case quote.FieldV:
		return m.OldV(ctx)
	}
	return nil, fmt.Errorf("unknown Quote field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuoteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case quote.FieldD:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetD(v)
		return nil
	case quote.FieldO:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetO(v)
		return nil
	case quote.FieldC:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetC(v)
		return nil
	case quote.FieldH:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetH(v)
		return nil
	case quote.FieldL:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetL(v)
		return nil
	case quote.FieldV:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetV(v)
		return nil
	}
	return fmt.Errorf("unknown Quote field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *QuoteMutation) AddedFields() []string {
	var fields []string
	if m.add_O != nil {
		fields = append(fields, quote.FieldO)
	}
	if m.add_C != nil {
		fields = append(fields, quote.FieldC)
	}
	if m.add_H != nil {
		fields = append(fields, quote.FieldH)
	}
	if m.add_L != nil {
		fields = append(fields, quote.FieldL)
	}
	if m.add_V != nil {
		fields = append(fields, quote.FieldV)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *QuoteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case quote.FieldO:
		return m.AddedO()
	case quote.FieldC:
		return m.AddedC()
	case quote.FieldH:
		return m.AddedH()
	case quote.FieldL:
		return m.AddedL()
	case quote.FieldV:
		return m.AddedV()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuoteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case quote.FieldO:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddO(v)
		return nil
	case quote.FieldC:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddC(v)
		return nil
	case quote.FieldH:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddH(v)
		return nil
	case quote.FieldL:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddL(v)
		return nil
	case quote.FieldV:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddV(v)
		return nil
	}
	return fmt.Errorf("unknown Quote numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *QuoteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *QuoteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *QuoteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Quote nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *QuoteMutation) ResetField(name string) error {
	switch name {
	case quote.FieldD:
		m.ResetD()
		return nil
	case quote.FieldO:
		m.ResetO()
		return nil
	case quote.FieldC:
		m.ResetC()
		return nil
	case quote.FieldH:
		m.ResetH()
		return nil
	case quote.FieldL:
		m.ResetL()
		return nil
	case quote.FieldV:
		m.ResetV()
		return nil
	}
	return fmt.Errorf("unknown Quote field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *QuoteMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Ticker != nil {
		edges = append(edges, quote.EdgeTicker)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *QuoteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case quote.EdgeTicker:
		if id := m._Ticker; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *QuoteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *QuoteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *QuoteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Ticker {
		edges = append(edges, quote.EdgeTicker)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *QuoteMutation) EdgeCleared(name string) bool {
	switch name {
	case quote.EdgeTicker:
		return m.cleared_Ticker
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *QuoteMutation) ClearEdge(name string) error {
	switch name {
	case quote.EdgeTicker:
		m.ClearTicker()
		return nil
	}
	return fmt.Errorf("unknown Quote unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *QuoteMutation) ResetEdge(name string) error {
	switch name {
	case quote.EdgeTicker:
		m.ResetTicker()
		return nil
	}
	return fmt.Errorf("unknown Quote edge %s", name)
}

// ReportMutation represents an operation that mutates the Report nodes in the graph.
type ReportMutation struct {
	config
	op                             Op
	typ                            string
	id                             *xid.ID
	_ReportYear                    *int
	add_ReportYear                 *int
	_ReportQuarter                 *int
	add_ReportQuarter              *int
	_ReportDate                    *time.Time
	_PnlRevenueYtd                 *float64
	add_PnlRevenueYtd              *float64
	_PnlAmortizationYtd            *float64
	add_PnlAmortizationYtd         *float64
	_PnlOperatingIncomeYtd         *float64
	add_PnlOperatingIncomeYtd      *float64
	_PnlInterestIncomeYtd          *float64
	add_PnlInterestIncomeYtd       *float64
	_PnlInterestExpensesYtd        *float64
	add_PnlInterestExpensesYtd     *float64
	_PnlIncomeTaxYtd               *float64
	add_PnlIncomeTaxYtd            *float64
	_PnlNetIncomeYtd               *float64
	add_PnlNetIncomeYtd            *float64
	_CfCashSld                     *float64
	add_CfCashSld                  *float64
	_CfNonCurrentLiabilitiesSld    *float64
	add_CfNonCurrentLiabilitiesSld *float64
	_CfCurrentLiabilitesSld        *float64
	add_CfCurrentLiabilitesSld     *float64
	_CfNonControllingSld           *float64
	add_CfNonControllingSld        *float64
	_CfEquitySld                   *float64
	add_CfEquitySld                *float64
	_CfTotalSld                    *float64
	add_CfTotalSld                 *float64
	_Url                           *string
	clearedFields                  map[string]struct{}
	_Emitent                       *xid.ID
	cleared_Emitent                bool
	done                           bool
	oldValue                       func(context.Context) (*Report, error)
	predicates                     []predicate.Report
}

var _ ent.Mutation = (*ReportMutation)(nil)

// reportOption allows management of the mutation configuration using functional options.
type reportOption func(*ReportMutation)

// newReportMutation creates new mutation for the Report entity.
func newReportMutation(c config, op Op, opts ...reportOption) *ReportMutation {
	m := &ReportMutation{
		config:        c,
		op:            op,
		typ:           TypeReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReportID sets the ID field of the mutation.
func withReportID(id xid.ID) reportOption {
	return func(m *ReportMutation) {
		var (
			err   error
			once  sync.Once
			value *Report
		)
		m.oldValue = func(ctx context.Context) (*Report, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Report.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReport sets the old Report of the mutation.
func withReport(node *Report) reportOption {
	return func(m *ReportMutation) {
		m.oldValue = func(context.Context) (*Report, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Report entities.
func (m *ReportMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReportMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReportMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Report.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReportYear sets the "ReportYear" field.
func (m *ReportMutation) SetReportYear(i int) {
	m._ReportYear = &i
	m.add_ReportYear = nil
}

// ReportYear returns the value of the "ReportYear" field in the mutation.
func (m *ReportMutation) ReportYear() (r int, exists bool) {
	v := m._ReportYear
	if v == nil {
		return
	}
	return *v, true
}

// OldReportYear returns the old "ReportYear" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldReportYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportYear: %w", err)
	}
	return oldValue.ReportYear, nil
}

// AddReportYear adds i to the "ReportYear" field.
func (m *ReportMutation) AddReportYear(i int) {
	if m.add_ReportYear != nil {
		*m.add_ReportYear += i
	} else {
		m.add_ReportYear = &i
	}
}

// AddedReportYear returns the value that was added to the "ReportYear" field in this mutation.
func (m *ReportMutation) AddedReportYear() (r int, exists bool) {
	v := m.add_ReportYear
	if v == nil {
		return
	}
	return *v, true
}

// ResetReportYear resets all changes to the "ReportYear" field.
func (m *ReportMutation) ResetReportYear() {
	m._ReportYear = nil
	m.add_ReportYear = nil
}

// SetReportQuarter sets the "ReportQuarter" field.
func (m *ReportMutation) SetReportQuarter(i int) {
	m._ReportQuarter = &i
	m.add_ReportQuarter = nil
}

// ReportQuarter returns the value of the "ReportQuarter" field in the mutation.
func (m *ReportMutation) ReportQuarter() (r int, exists bool) {
	v := m._ReportQuarter
	if v == nil {
		return
	}
	return *v, true
}

// OldReportQuarter returns the old "ReportQuarter" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldReportQuarter(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportQuarter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportQuarter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportQuarter: %w", err)
	}
	return oldValue.ReportQuarter, nil
}

// AddReportQuarter adds i to the "ReportQuarter" field.
func (m *ReportMutation) AddReportQuarter(i int) {
	if m.add_ReportQuarter != nil {
		*m.add_ReportQuarter += i
	} else {
		m.add_ReportQuarter = &i
	}
}

// AddedReportQuarter returns the value that was added to the "ReportQuarter" field in this mutation.
func (m *ReportMutation) AddedReportQuarter() (r int, exists bool) {
	v := m.add_ReportQuarter
	if v == nil {
		return
	}
	return *v, true
}

// ResetReportQuarter resets all changes to the "ReportQuarter" field.
func (m *ReportMutation) ResetReportQuarter() {
	m._ReportQuarter = nil
	m.add_ReportQuarter = nil
}

// SetReportDate sets the "ReportDate" field.
func (m *ReportMutation) SetReportDate(t time.Time) {
	m._ReportDate = &t
}

// ReportDate returns the value of the "ReportDate" field in the mutation.
func (m *ReportMutation) ReportDate() (r time.Time, exists bool) {
	v := m._ReportDate
	if v == nil {
		return
	}
	return *v, true
}

// OldReportDate returns the old "ReportDate" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldReportDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportDate: %w", err)
	}
	return oldValue.ReportDate, nil
}

// ResetReportDate resets all changes to the "ReportDate" field.
func (m *ReportMutation) ResetReportDate() {
	m._ReportDate = nil
}

// SetPnlRevenueYtd sets the "PnlRevenueYtd" field.
func (m *ReportMutation) SetPnlRevenueYtd(f float64) {
	m._PnlRevenueYtd = &f
	m.add_PnlRevenueYtd = nil
}

// PnlRevenueYtd returns the value of the "PnlRevenueYtd" field in the mutation.
func (m *ReportMutation) PnlRevenueYtd() (r float64, exists bool) {
	v := m._PnlRevenueYtd
	if v == nil {
		return
	}
	return *v, true
}

// OldPnlRevenueYtd returns the old "PnlRevenueYtd" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldPnlRevenueYtd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPnlRevenueYtd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPnlRevenueYtd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPnlRevenueYtd: %w", err)
	}
	return oldValue.PnlRevenueYtd, nil
}

// AddPnlRevenueYtd adds f to the "PnlRevenueYtd" field.
func (m *ReportMutation) AddPnlRevenueYtd(f float64) {
	if m.add_PnlRevenueYtd != nil {
		*m.add_PnlRevenueYtd += f
	} else {
		m.add_PnlRevenueYtd = &f
	}
}

// AddedPnlRevenueYtd returns the value that was added to the "PnlRevenueYtd" field in this mutation.
func (m *ReportMutation) AddedPnlRevenueYtd() (r float64, exists bool) {
	v := m.add_PnlRevenueYtd
	if v == nil {
		return
	}
	return *v, true
}

// ResetPnlRevenueYtd resets all changes to the "PnlRevenueYtd" field.
func (m *ReportMutation) ResetPnlRevenueYtd() {
	m._PnlRevenueYtd = nil
	m.add_PnlRevenueYtd = nil
}

// SetPnlAmortizationYtd sets the "PnlAmortizationYtd" field.
func (m *ReportMutation) SetPnlAmortizationYtd(f float64) {
	m._PnlAmortizationYtd = &f
	m.add_PnlAmortizationYtd = nil
}

// PnlAmortizationYtd returns the value of the "PnlAmortizationYtd" field in the mutation.
func (m *ReportMutation) PnlAmortizationYtd() (r float64, exists bool) {
	v := m._PnlAmortizationYtd
	if v == nil {
		return
	}
	return *v, true
}

// OldPnlAmortizationYtd returns the old "PnlAmortizationYtd" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldPnlAmortizationYtd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPnlAmortizationYtd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPnlAmortizationYtd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPnlAmortizationYtd: %w", err)
	}
	return oldValue.PnlAmortizationYtd, nil
}

// AddPnlAmortizationYtd adds f to the "PnlAmortizationYtd" field.
func (m *ReportMutation) AddPnlAmortizationYtd(f float64) {
	if m.add_PnlAmortizationYtd != nil {
		*m.add_PnlAmortizationYtd += f
	} else {
		m.add_PnlAmortizationYtd = &f
	}
}

// AddedPnlAmortizationYtd returns the value that was added to the "PnlAmortizationYtd" field in this mutation.
func (m *ReportMutation) AddedPnlAmortizationYtd() (r float64, exists bool) {
	v := m.add_PnlAmortizationYtd
	if v == nil {
		return
	}
	return *v, true
}

// ResetPnlAmortizationYtd resets all changes to the "PnlAmortizationYtd" field.
func (m *ReportMutation) ResetPnlAmortizationYtd() {
	m._PnlAmortizationYtd = nil
	m.add_PnlAmortizationYtd = nil
}

// SetPnlOperatingIncomeYtd sets the "PnlOperatingIncomeYtd" field.
func (m *ReportMutation) SetPnlOperatingIncomeYtd(f float64) {
	m._PnlOperatingIncomeYtd = &f
	m.add_PnlOperatingIncomeYtd = nil
}

// PnlOperatingIncomeYtd returns the value of the "PnlOperatingIncomeYtd" field in the mutation.
func (m *ReportMutation) PnlOperatingIncomeYtd() (r float64, exists bool) {
	v := m._PnlOperatingIncomeYtd
	if v == nil {
		return
	}
	return *v, true
}

// OldPnlOperatingIncomeYtd returns the old "PnlOperatingIncomeYtd" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldPnlOperatingIncomeYtd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPnlOperatingIncomeYtd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPnlOperatingIncomeYtd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPnlOperatingIncomeYtd: %w", err)
	}
	return oldValue.PnlOperatingIncomeYtd, nil
}

// AddPnlOperatingIncomeYtd adds f to the "PnlOperatingIncomeYtd" field.
func (m *ReportMutation) AddPnlOperatingIncomeYtd(f float64) {
	if m.add_PnlOperatingIncomeYtd != nil {
		*m.add_PnlOperatingIncomeYtd += f
	} else {
		m.add_PnlOperatingIncomeYtd = &f
	}
}

// AddedPnlOperatingIncomeYtd returns the value that was added to the "PnlOperatingIncomeYtd" field in this mutation.
func (m *ReportMutation) AddedPnlOperatingIncomeYtd() (r float64, exists bool) {
	v := m.add_PnlOperatingIncomeYtd
	if v == nil {
		return
	}
	return *v, true
}

// ResetPnlOperatingIncomeYtd resets all changes to the "PnlOperatingIncomeYtd" field.
func (m *ReportMutation) ResetPnlOperatingIncomeYtd() {
	m._PnlOperatingIncomeYtd = nil
	m.add_PnlOperatingIncomeYtd = nil
}

// SetPnlInterestIncomeYtd sets the "PnlInterestIncomeYtd" field.
func (m *ReportMutation) SetPnlInterestIncomeYtd(f float64) {
	m._PnlInterestIncomeYtd = &f
	m.add_PnlInterestIncomeYtd = nil
}

// PnlInterestIncomeYtd returns the value of the "PnlInterestIncomeYtd" field in the mutation.
func (m *ReportMutation) PnlInterestIncomeYtd() (r float64, exists bool) {
	v := m._PnlInterestIncomeYtd
	if v == nil {
		return
	}
	return *v, true
}

// OldPnlInterestIncomeYtd returns the old "PnlInterestIncomeYtd" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldPnlInterestIncomeYtd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPnlInterestIncomeYtd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPnlInterestIncomeYtd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPnlInterestIncomeYtd: %w", err)
	}
	return oldValue.PnlInterestIncomeYtd, nil
}

// AddPnlInterestIncomeYtd adds f to the "PnlInterestIncomeYtd" field.
func (m *ReportMutation) AddPnlInterestIncomeYtd(f float64) {
	if m.add_PnlInterestIncomeYtd != nil {
		*m.add_PnlInterestIncomeYtd += f
	} else {
		m.add_PnlInterestIncomeYtd = &f
	}
}

// AddedPnlInterestIncomeYtd returns the value that was added to the "PnlInterestIncomeYtd" field in this mutation.
func (m *ReportMutation) AddedPnlInterestIncomeYtd() (r float64, exists bool) {
	v := m.add_PnlInterestIncomeYtd
	if v == nil {
		return
	}
	return *v, true
}

// ResetPnlInterestIncomeYtd resets all changes to the "PnlInterestIncomeYtd" field.
func (m *ReportMutation) ResetPnlInterestIncomeYtd() {
	m._PnlInterestIncomeYtd = nil
	m.add_PnlInterestIncomeYtd = nil
}

// SetPnlInterestExpensesYtd sets the "PnlInterestExpensesYtd" field.
func (m *ReportMutation) SetPnlInterestExpensesYtd(f float64) {
	m._PnlInterestExpensesYtd = &f
	m.add_PnlInterestExpensesYtd = nil
}

// PnlInterestExpensesYtd returns the value of the "PnlInterestExpensesYtd" field in the mutation.
func (m *ReportMutation) PnlInterestExpensesYtd() (r float64, exists bool) {
	v := m._PnlInterestExpensesYtd
	if v == nil {
		return
	}
	return *v, true
}

// OldPnlInterestExpensesYtd returns the old "PnlInterestExpensesYtd" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldPnlInterestExpensesYtd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPnlInterestExpensesYtd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPnlInterestExpensesYtd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPnlInterestExpensesYtd: %w", err)
	}
	return oldValue.PnlInterestExpensesYtd, nil
}

// AddPnlInterestExpensesYtd adds f to the "PnlInterestExpensesYtd" field.
func (m *ReportMutation) AddPnlInterestExpensesYtd(f float64) {
	if m.add_PnlInterestExpensesYtd != nil {
		*m.add_PnlInterestExpensesYtd += f
	} else {
		m.add_PnlInterestExpensesYtd = &f
	}
}

// AddedPnlInterestExpensesYtd returns the value that was added to the "PnlInterestExpensesYtd" field in this mutation.
func (m *ReportMutation) AddedPnlInterestExpensesYtd() (r float64, exists bool) {
	v := m.add_PnlInterestExpensesYtd
	if v == nil {
		return
	}
	return *v, true
}

// ResetPnlInterestExpensesYtd resets all changes to the "PnlInterestExpensesYtd" field.
func (m *ReportMutation) ResetPnlInterestExpensesYtd() {
	m._PnlInterestExpensesYtd = nil
	m.add_PnlInterestExpensesYtd = nil
}

// SetPnlIncomeTaxYtd sets the "PnlIncomeTaxYtd" field.
func (m *ReportMutation) SetPnlIncomeTaxYtd(f float64) {
	m._PnlIncomeTaxYtd = &f
	m.add_PnlIncomeTaxYtd = nil
}

// PnlIncomeTaxYtd returns the value of the "PnlIncomeTaxYtd" field in the mutation.
func (m *ReportMutation) PnlIncomeTaxYtd() (r float64, exists bool) {
	v := m._PnlIncomeTaxYtd
	if v == nil {
		return
	}
	return *v, true
}

// OldPnlIncomeTaxYtd returns the old "PnlIncomeTaxYtd" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldPnlIncomeTaxYtd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPnlIncomeTaxYtd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPnlIncomeTaxYtd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPnlIncomeTaxYtd: %w", err)
	}
	return oldValue.PnlIncomeTaxYtd, nil
}

// AddPnlIncomeTaxYtd adds f to the "PnlIncomeTaxYtd" field.
func (m *ReportMutation) AddPnlIncomeTaxYtd(f float64) {
	if m.add_PnlIncomeTaxYtd != nil {
		*m.add_PnlIncomeTaxYtd += f
	} else {
		m.add_PnlIncomeTaxYtd = &f
	}
}

// AddedPnlIncomeTaxYtd returns the value that was added to the "PnlIncomeTaxYtd" field in this mutation.
func (m *ReportMutation) AddedPnlIncomeTaxYtd() (r float64, exists bool) {
	v := m.add_PnlIncomeTaxYtd
	if v == nil {
		return
	}
	return *v, true
}

// ResetPnlIncomeTaxYtd resets all changes to the "PnlIncomeTaxYtd" field.
func (m *ReportMutation) ResetPnlIncomeTaxYtd() {
	m._PnlIncomeTaxYtd = nil
	m.add_PnlIncomeTaxYtd = nil
}

// SetPnlNetIncomeYtd sets the "PnlNetIncomeYtd" field.
func (m *ReportMutation) SetPnlNetIncomeYtd(f float64) {
	m._PnlNetIncomeYtd = &f
	m.add_PnlNetIncomeYtd = nil
}

// PnlNetIncomeYtd returns the value of the "PnlNetIncomeYtd" field in the mutation.
func (m *ReportMutation) PnlNetIncomeYtd() (r float64, exists bool) {
	v := m._PnlNetIncomeYtd
	if v == nil {
		return
	}
	return *v, true
}

// OldPnlNetIncomeYtd returns the old "PnlNetIncomeYtd" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldPnlNetIncomeYtd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPnlNetIncomeYtd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPnlNetIncomeYtd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPnlNetIncomeYtd: %w", err)
	}
	return oldValue.PnlNetIncomeYtd, nil
}

// AddPnlNetIncomeYtd adds f to the "PnlNetIncomeYtd" field.
func (m *ReportMutation) AddPnlNetIncomeYtd(f float64) {
	if m.add_PnlNetIncomeYtd != nil {
		*m.add_PnlNetIncomeYtd += f
	} else {
		m.add_PnlNetIncomeYtd = &f
	}
}

// AddedPnlNetIncomeYtd returns the value that was added to the "PnlNetIncomeYtd" field in this mutation.
func (m *ReportMutation) AddedPnlNetIncomeYtd() (r float64, exists bool) {
	v := m.add_PnlNetIncomeYtd
	if v == nil {
		return
	}
	return *v, true
}

// ResetPnlNetIncomeYtd resets all changes to the "PnlNetIncomeYtd" field.
func (m *ReportMutation) ResetPnlNetIncomeYtd() {
	m._PnlNetIncomeYtd = nil
	m.add_PnlNetIncomeYtd = nil
}

// SetCfCashSld sets the "CfCashSld" field.
func (m *ReportMutation) SetCfCashSld(f float64) {
	m._CfCashSld = &f
	m.add_CfCashSld = nil
}

// CfCashSld returns the value of the "CfCashSld" field in the mutation.
func (m *ReportMutation) CfCashSld() (r float64, exists bool) {
	v := m._CfCashSld
	if v == nil {
		return
	}
	return *v, true
}

// OldCfCashSld returns the old "CfCashSld" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldCfCashSld(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCfCashSld is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCfCashSld requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCfCashSld: %w", err)
	}
	return oldValue.CfCashSld, nil
}

// AddCfCashSld adds f to the "CfCashSld" field.
func (m *ReportMutation) AddCfCashSld(f float64) {
	if m.add_CfCashSld != nil {
		*m.add_CfCashSld += f
	} else {
		m.add_CfCashSld = &f
	}
}

// AddedCfCashSld returns the value that was added to the "CfCashSld" field in this mutation.
func (m *ReportMutation) AddedCfCashSld() (r float64, exists bool) {
	v := m.add_CfCashSld
	if v == nil {
		return
	}
	return *v, true
}

// ResetCfCashSld resets all changes to the "CfCashSld" field.
func (m *ReportMutation) ResetCfCashSld() {
	m._CfCashSld = nil
	m.add_CfCashSld = nil
}

// SetCfNonCurrentLiabilitiesSld sets the "CfNonCurrentLiabilitiesSld" field.
func (m *ReportMutation) SetCfNonCurrentLiabilitiesSld(f float64) {
	m._CfNonCurrentLiabilitiesSld = &f
	m.add_CfNonCurrentLiabilitiesSld = nil
}

// CfNonCurrentLiabilitiesSld returns the value of the "CfNonCurrentLiabilitiesSld" field in the mutation.
func (m *ReportMutation) CfNonCurrentLiabilitiesSld() (r float64, exists bool) {
	v := m._CfNonCurrentLiabilitiesSld
	if v == nil {
		return
	}
	return *v, true
}

// OldCfNonCurrentLiabilitiesSld returns the old "CfNonCurrentLiabilitiesSld" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldCfNonCurrentLiabilitiesSld(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCfNonCurrentLiabilitiesSld is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCfNonCurrentLiabilitiesSld requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCfNonCurrentLiabilitiesSld: %w", err)
	}
	return oldValue.CfNonCurrentLiabilitiesSld, nil
}

// AddCfNonCurrentLiabilitiesSld adds f to the "CfNonCurrentLiabilitiesSld" field.
func (m *ReportMutation) AddCfNonCurrentLiabilitiesSld(f float64) {
	if m.add_CfNonCurrentLiabilitiesSld != nil {
		*m.add_CfNonCurrentLiabilitiesSld += f
	} else {
		m.add_CfNonCurrentLiabilitiesSld = &f
	}
}

// AddedCfNonCurrentLiabilitiesSld returns the value that was added to the "CfNonCurrentLiabilitiesSld" field in this mutation.
func (m *ReportMutation) AddedCfNonCurrentLiabilitiesSld() (r float64, exists bool) {
	v := m.add_CfNonCurrentLiabilitiesSld
	if v == nil {
		return
	}
	return *v, true
}

// ResetCfNonCurrentLiabilitiesSld resets all changes to the "CfNonCurrentLiabilitiesSld" field.
func (m *ReportMutation) ResetCfNonCurrentLiabilitiesSld() {
	m._CfNonCurrentLiabilitiesSld = nil
	m.add_CfNonCurrentLiabilitiesSld = nil
}

// SetCfCurrentLiabilitesSld sets the "CfCurrentLiabilitesSld" field.
func (m *ReportMutation) SetCfCurrentLiabilitesSld(f float64) {
	m._CfCurrentLiabilitesSld = &f
	m.add_CfCurrentLiabilitesSld = nil
}

// CfCurrentLiabilitesSld returns the value of the "CfCurrentLiabilitesSld" field in the mutation.
func (m *ReportMutation) CfCurrentLiabilitesSld() (r float64, exists bool) {
	v := m._CfCurrentLiabilitesSld
	if v == nil {
		return
	}
	return *v, true
}

// OldCfCurrentLiabilitesSld returns the old "CfCurrentLiabilitesSld" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldCfCurrentLiabilitesSld(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCfCurrentLiabilitesSld is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCfCurrentLiabilitesSld requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCfCurrentLiabilitesSld: %w", err)
	}
	return oldValue.CfCurrentLiabilitesSld, nil
}

// AddCfCurrentLiabilitesSld adds f to the "CfCurrentLiabilitesSld" field.
func (m *ReportMutation) AddCfCurrentLiabilitesSld(f float64) {
	if m.add_CfCurrentLiabilitesSld != nil {
		*m.add_CfCurrentLiabilitesSld += f
	} else {
		m.add_CfCurrentLiabilitesSld = &f
	}
}

// AddedCfCurrentLiabilitesSld returns the value that was added to the "CfCurrentLiabilitesSld" field in this mutation.
func (m *ReportMutation) AddedCfCurrentLiabilitesSld() (r float64, exists bool) {
	v := m.add_CfCurrentLiabilitesSld
	if v == nil {
		return
	}
	return *v, true
}

// ResetCfCurrentLiabilitesSld resets all changes to the "CfCurrentLiabilitesSld" field.
func (m *ReportMutation) ResetCfCurrentLiabilitesSld() {
	m._CfCurrentLiabilitesSld = nil
	m.add_CfCurrentLiabilitesSld = nil
}

// SetCfNonControllingSld sets the "CfNonControllingSld" field.
func (m *ReportMutation) SetCfNonControllingSld(f float64) {
	m._CfNonControllingSld = &f
	m.add_CfNonControllingSld = nil
}

// CfNonControllingSld returns the value of the "CfNonControllingSld" field in the mutation.
func (m *ReportMutation) CfNonControllingSld() (r float64, exists bool) {
	v := m._CfNonControllingSld
	if v == nil {
		return
	}
	return *v, true
}

// OldCfNonControllingSld returns the old "CfNonControllingSld" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldCfNonControllingSld(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCfNonControllingSld is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCfNonControllingSld requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCfNonControllingSld: %w", err)
	}
	return oldValue.CfNonControllingSld, nil
}

// AddCfNonControllingSld adds f to the "CfNonControllingSld" field.
func (m *ReportMutation) AddCfNonControllingSld(f float64) {
	if m.add_CfNonControllingSld != nil {
		*m.add_CfNonControllingSld += f
	} else {
		m.add_CfNonControllingSld = &f
	}
}

// AddedCfNonControllingSld returns the value that was added to the "CfNonControllingSld" field in this mutation.
func (m *ReportMutation) AddedCfNonControllingSld() (r float64, exists bool) {
	v := m.add_CfNonControllingSld
	if v == nil {
		return
	}
	return *v, true
}

// ResetCfNonControllingSld resets all changes to the "CfNonControllingSld" field.
func (m *ReportMutation) ResetCfNonControllingSld() {
	m._CfNonControllingSld = nil
	m.add_CfNonControllingSld = nil
}

// SetCfEquitySld sets the "CfEquitySld" field.
func (m *ReportMutation) SetCfEquitySld(f float64) {
	m._CfEquitySld = &f
	m.add_CfEquitySld = nil
}

// CfEquitySld returns the value of the "CfEquitySld" field in the mutation.
func (m *ReportMutation) CfEquitySld() (r float64, exists bool) {
	v := m._CfEquitySld
	if v == nil {
		return
	}
	return *v, true
}

// OldCfEquitySld returns the old "CfEquitySld" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldCfEquitySld(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCfEquitySld is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCfEquitySld requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCfEquitySld: %w", err)
	}
	return oldValue.CfEquitySld, nil
}

// AddCfEquitySld adds f to the "CfEquitySld" field.
func (m *ReportMutation) AddCfEquitySld(f float64) {
	if m.add_CfEquitySld != nil {
		*m.add_CfEquitySld += f
	} else {
		m.add_CfEquitySld = &f
	}
}

// AddedCfEquitySld returns the value that was added to the "CfEquitySld" field in this mutation.
func (m *ReportMutation) AddedCfEquitySld() (r float64, exists bool) {
	v := m.add_CfEquitySld
	if v == nil {
		return
	}
	return *v, true
}

// ResetCfEquitySld resets all changes to the "CfEquitySld" field.
func (m *ReportMutation) ResetCfEquitySld() {
	m._CfEquitySld = nil
	m.add_CfEquitySld = nil
}

// SetCfTotalSld sets the "CfTotalSld" field.
func (m *ReportMutation) SetCfTotalSld(f float64) {
	m._CfTotalSld = &f
	m.add_CfTotalSld = nil
}

// CfTotalSld returns the value of the "CfTotalSld" field in the mutation.
func (m *ReportMutation) CfTotalSld() (r float64, exists bool) {
	v := m._CfTotalSld
	if v == nil {
		return
	}
	return *v, true
}

// OldCfTotalSld returns the old "CfTotalSld" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldCfTotalSld(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCfTotalSld is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCfTotalSld requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCfTotalSld: %w", err)
	}
	return oldValue.CfTotalSld, nil
}

// AddCfTotalSld adds f to the "CfTotalSld" field.
func (m *ReportMutation) AddCfTotalSld(f float64) {
	if m.add_CfTotalSld != nil {
		*m.add_CfTotalSld += f
	} else {
		m.add_CfTotalSld = &f
	}
}

// AddedCfTotalSld returns the value that was added to the "CfTotalSld" field in this mutation.
func (m *ReportMutation) AddedCfTotalSld() (r float64, exists bool) {
	v := m.add_CfTotalSld
	if v == nil {
		return
	}
	return *v, true
}

// ResetCfTotalSld resets all changes to the "CfTotalSld" field.
func (m *ReportMutation) ResetCfTotalSld() {
	m._CfTotalSld = nil
	m.add_CfTotalSld = nil
}

// SetURL sets the "Url" field.
func (m *ReportMutation) SetURL(s string) {
	m._Url = &s
}

// URL returns the value of the "Url" field in the mutation.
func (m *ReportMutation) URL() (r string, exists bool) {
	v := m._Url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "Url" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "Url" field.
func (m *ReportMutation) ClearURL() {
	m._Url = nil
	m.clearedFields[report.FieldURL] = struct{}{}
}

// URLCleared returns if the "Url" field was cleared in this mutation.
func (m *ReportMutation) URLCleared() bool {
	_, ok := m.clearedFields[report.FieldURL]
	return ok
}

// ResetURL resets all changes to the "Url" field.
func (m *ReportMutation) ResetURL() {
	m._Url = nil
	delete(m.clearedFields, report.FieldURL)
}

// SetEmitentID sets the "Emitent" edge to the Emitent entity by id.
func (m *ReportMutation) SetEmitentID(id xid.ID) {
	m._Emitent = &id
}

// ClearEmitent clears the "Emitent" edge to the Emitent entity.
func (m *ReportMutation) ClearEmitent() {
	m.cleared_Emitent = true
}

// EmitentCleared reports if the "Emitent" edge to the Emitent entity was cleared.
func (m *ReportMutation) EmitentCleared() bool {
	return m.cleared_Emitent
}

// EmitentID returns the "Emitent" edge ID in the mutation.
func (m *ReportMutation) EmitentID() (id xid.ID, exists bool) {
	if m._Emitent != nil {
		return *m._Emitent, true
	}
	return
}

// EmitentIDs returns the "Emitent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmitentID instead. It exists only for internal usage by the builders.
func (m *ReportMutation) EmitentIDs() (ids []xid.ID) {
	if id := m._Emitent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmitent resets all changes to the "Emitent" edge.
func (m *ReportMutation) ResetEmitent() {
	m._Emitent = nil
	m.cleared_Emitent = false
}

// Where appends a list predicates to the ReportMutation builder.
func (m *ReportMutation) Where(ps ...predicate.Report) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ReportMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Report).
func (m *ReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReportMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m._ReportYear != nil {
		fields = append(fields, report.FieldReportYear)
	}
	if m._ReportQuarter != nil {
		fields = append(fields, report.FieldReportQuarter)
	}
	if m._ReportDate != nil {
		fields = append(fields, report.FieldReportDate)
	}
	if m._PnlRevenueYtd != nil {
		fields = append(fields, report.FieldPnlRevenueYtd)
	}
	if m._PnlAmortizationYtd != nil {
		fields = append(fields, report.FieldPnlAmortizationYtd)
	}
	if m._PnlOperatingIncomeYtd != nil {
		fields = append(fields, report.FieldPnlOperatingIncomeYtd)
	}
	if m._PnlInterestIncomeYtd != nil {
		fields = append(fields, report.FieldPnlInterestIncomeYtd)
	}
	if m._PnlInterestExpensesYtd != nil {
		fields = append(fields, report.FieldPnlInterestExpensesYtd)
	}
	if m._PnlIncomeTaxYtd != nil {
		fields = append(fields, report.FieldPnlIncomeTaxYtd)
	}
	if m._PnlNetIncomeYtd != nil {
		fields = append(fields, report.FieldPnlNetIncomeYtd)
	}
	if m._CfCashSld != nil {
		fields = append(fields, report.FieldCfCashSld)
	}
	if m._CfNonCurrentLiabilitiesSld != nil {
		fields = append(fields, report.FieldCfNonCurrentLiabilitiesSld)
	}
	if m._CfCurrentLiabilitesSld != nil {
		fields = append(fields, report.FieldCfCurrentLiabilitesSld)
	}
	if m._CfNonControllingSld != nil {
		fields = append(fields, report.FieldCfNonControllingSld)
	}
	if m._CfEquitySld != nil {
		fields = append(fields, report.FieldCfEquitySld)
	}
	if m._CfTotalSld != nil {
		fields = append(fields, report.FieldCfTotalSld)
	}
	if m._Url != nil {
		fields = append(fields, report.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case report.FieldReportYear:
		return m.ReportYear()
	case report.FieldReportQuarter:
		return m.ReportQuarter()
	case report.FieldReportDate:
		return m.ReportDate()
	case report.FieldPnlRevenueYtd:
		return m.PnlRevenueYtd()
	case report.FieldPnlAmortizationYtd:
		return m.PnlAmortizationYtd()
	case report.FieldPnlOperatingIncomeYtd:
		return m.PnlOperatingIncomeYtd()
	case report.FieldPnlInterestIncomeYtd:
		return m.PnlInterestIncomeYtd()
	case report.FieldPnlInterestExpensesYtd:
		return m.PnlInterestExpensesYtd()
	case report.FieldPnlIncomeTaxYtd:
		return m.PnlIncomeTaxYtd()
	case report.FieldPnlNetIncomeYtd:
		return m.PnlNetIncomeYtd()
	case report.FieldCfCashSld:
		return m.CfCashSld()
	case report.FieldCfNonCurrentLiabilitiesSld:
		return m.CfNonCurrentLiabilitiesSld()
	case report.FieldCfCurrentLiabilitesSld:
		return m.CfCurrentLiabilitesSld()
	case report.FieldCfNonControllingSld:
		return m.CfNonControllingSld()
	case report.FieldCfEquitySld:
		return m.CfEquitySld()
	case report.FieldCfTotalSld:
		return m.CfTotalSld()
	case report.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case report.FieldReportYear:
		return m.OldReportYear(ctx)
	case report.FieldReportQuarter:
		return m.OldReportQuarter(ctx)
	case report.FieldReportDate:
		return m.OldReportDate(ctx)
	case report.FieldPnlRevenueYtd:
		return m.OldPnlRevenueYtd(ctx)
	case report.FieldPnlAmortizationYtd:
		return m.OldPnlAmortizationYtd(ctx)
	case report.FieldPnlOperatingIncomeYtd:
		return m.OldPnlOperatingIncomeYtd(ctx)
	case report.FieldPnlInterestIncomeYtd:
		return m.OldPnlInterestIncomeYtd(ctx)
	case report.FieldPnlInterestExpensesYtd:
		return m.OldPnlInterestExpensesYtd(ctx)
	case report.FieldPnlIncomeTaxYtd:
		return m.OldPnlIncomeTaxYtd(ctx)
	case report.FieldPnlNetIncomeYtd:
		return m.OldPnlNetIncomeYtd(ctx)
	case report.FieldCfCashSld:
		return m.OldCfCashSld(ctx)
	case report.FieldCfNonCurrentLiabilitiesSld:
		return m.OldCfNonCurrentLiabilitiesSld(ctx)
	case report.FieldCfCurrentLiabilitesSld:
		return m.OldCfCurrentLiabilitesSld(ctx)
	case report.FieldCfNonControllingSld:
		return m.OldCfNonControllingSld(ctx)
	case report.FieldCfEquitySld:
		return m.OldCfEquitySld(ctx)
	case report.FieldCfTotalSld:
		return m.OldCfTotalSld(ctx)
	case report.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown Report field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case report.FieldReportYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportYear(v)
		return nil
	case report.FieldReportQuarter:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportQuarter(v)
		return nil
	case report.FieldReportDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportDate(v)
		return nil
	case report.FieldPnlRevenueYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPnlRevenueYtd(v)
		return nil
	case report.FieldPnlAmortizationYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPnlAmortizationYtd(v)
		return nil
	case report.FieldPnlOperatingIncomeYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPnlOperatingIncomeYtd(v)
		return nil
	case report.FieldPnlInterestIncomeYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPnlInterestIncomeYtd(v)
		return nil
	case report.FieldPnlInterestExpensesYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPnlInterestExpensesYtd(v)
		return nil
	case report.FieldPnlIncomeTaxYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPnlIncomeTaxYtd(v)
		return nil
	case report.FieldPnlNetIncomeYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPnlNetIncomeYtd(v)
		return nil
	case report.FieldCfCashSld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCfCashSld(v)
		return nil
	case report.FieldCfNonCurrentLiabilitiesSld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCfNonCurrentLiabilitiesSld(v)
		return nil
	case report.FieldCfCurrentLiabilitesSld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCfCurrentLiabilitesSld(v)
		return nil
	case report.FieldCfNonControllingSld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCfNonControllingSld(v)
		return nil
	case report.FieldCfEquitySld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCfEquitySld(v)
		return nil
	case report.FieldCfTotalSld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCfTotalSld(v)
		return nil
	case report.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown Report field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReportMutation) AddedFields() []string {
	var fields []string
	if m.add_ReportYear != nil {
		fields = append(fields, report.FieldReportYear)
	}
	if m.add_ReportQuarter != nil {
		fields = append(fields, report.FieldReportQuarter)
	}
	if m.add_PnlRevenueYtd != nil {
		fields = append(fields, report.FieldPnlRevenueYtd)
	}
	if m.add_PnlAmortizationYtd != nil {
		fields = append(fields, report.FieldPnlAmortizationYtd)
	}
	if m.add_PnlOperatingIncomeYtd != nil {
		fields = append(fields, report.FieldPnlOperatingIncomeYtd)
	}
	if m.add_PnlInterestIncomeYtd != nil {
		fields = append(fields, report.FieldPnlInterestIncomeYtd)
	}
	if m.add_PnlInterestExpensesYtd != nil {
		fields = append(fields, report.FieldPnlInterestExpensesYtd)
	}
	if m.add_PnlIncomeTaxYtd != nil {
		fields = append(fields, report.FieldPnlIncomeTaxYtd)
	}
	if m.add_PnlNetIncomeYtd != nil {
		fields = append(fields, report.FieldPnlNetIncomeYtd)
	}
	if m.add_CfCashSld != nil {
		fields = append(fields, report.FieldCfCashSld)
	}
	if m.add_CfNonCurrentLiabilitiesSld != nil {
		fields = append(fields, report.FieldCfNonCurrentLiabilitiesSld)
	}
	if m.add_CfCurrentLiabilitesSld != nil {
		fields = append(fields, report.FieldCfCurrentLiabilitesSld)
	}
	if m.add_CfNonControllingSld != nil {
		fields = append(fields, report.FieldCfNonControllingSld)
	}
	if m.add_CfEquitySld != nil {
		fields = append(fields, report.FieldCfEquitySld)
	}
	if m.add_CfTotalSld != nil {
		fields = append(fields, report.FieldCfTotalSld)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case report.FieldReportYear:
		return m.AddedReportYear()
	case report.FieldReportQuarter:
		return m.AddedReportQuarter()
	case report.FieldPnlRevenueYtd:
		return m.AddedPnlRevenueYtd()
	case report.FieldPnlAmortizationYtd:
		return m.AddedPnlAmortizationYtd()
	case report.FieldPnlOperatingIncomeYtd:
		return m.AddedPnlOperatingIncomeYtd()
	case report.FieldPnlInterestIncomeYtd:
		return m.AddedPnlInterestIncomeYtd()
	case report.FieldPnlInterestExpensesYtd:
		return m.AddedPnlInterestExpensesYtd()
	case report.FieldPnlIncomeTaxYtd:
		return m.AddedPnlIncomeTaxYtd()
	case report.FieldPnlNetIncomeYtd:
		return m.AddedPnlNetIncomeYtd()
	case report.FieldCfCashSld:
		return m.AddedCfCashSld()
	case report.FieldCfNonCurrentLiabilitiesSld:
		return m.AddedCfNonCurrentLiabilitiesSld()
	case report.FieldCfCurrentLiabilitesSld:
		return m.AddedCfCurrentLiabilitesSld()
	case report.FieldCfNonControllingSld:
		return m.AddedCfNonControllingSld()
	case report.FieldCfEquitySld:
		return m.AddedCfEquitySld()
	case report.FieldCfTotalSld:
		return m.AddedCfTotalSld()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case report.FieldReportYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReportYear(v)
		return nil
	case report.FieldReportQuarter:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReportQuarter(v)
		return nil
	case report.FieldPnlRevenueYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPnlRevenueYtd(v)
		return nil
	case report.FieldPnlAmortizationYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPnlAmortizationYtd(v)
		return nil
	case report.FieldPnlOperatingIncomeYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPnlOperatingIncomeYtd(v)
		return nil
	case report.FieldPnlInterestIncomeYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPnlInterestIncomeYtd(v)
		return nil
	case report.FieldPnlInterestExpensesYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPnlInterestExpensesYtd(v)
		return nil
	case report.FieldPnlIncomeTaxYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPnlIncomeTaxYtd(v)
		return nil
	case report.FieldPnlNetIncomeYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPnlNetIncomeYtd(v)
		return nil
	case report.FieldCfCashSld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCfCashSld(v)
		return nil
	case report.FieldCfNonCurrentLiabilitiesSld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCfNonCurrentLiabilitiesSld(v)
		return nil
	case report.FieldCfCurrentLiabilitesSld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCfCurrentLiabilitesSld(v)
		return nil
	case report.FieldCfNonControllingSld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCfNonControllingSld(v)
		return nil
	case report.FieldCfEquitySld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCfEquitySld(v)
		return nil
	case report.FieldCfTotalSld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCfTotalSld(v)
		return nil
	}
	return fmt.Errorf("unknown Report numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(report.FieldURL) {
		fields = append(fields, report.FieldURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReportMutation) ClearField(name string) error {
	switch name {
	case report.FieldURL:
		m.ClearURL()
		return nil
	}
	return fmt.Errorf("unknown Report nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReportMutation) ResetField(name string) error {
	switch name {
	case report.FieldReportYear:
		m.ResetReportYear()
		return nil
	case report.FieldReportQuarter:
		m.ResetReportQuarter()
		return nil
	case report.FieldReportDate:
		m.ResetReportDate()
		return nil
	case report.FieldPnlRevenueYtd:
		m.ResetPnlRevenueYtd()
		return nil
	case report.FieldPnlAmortizationYtd:
		m.ResetPnlAmortizationYtd()
		return nil
	case report.FieldPnlOperatingIncomeYtd:
		m.ResetPnlOperatingIncomeYtd()
		return nil
	case report.FieldPnlInterestIncomeYtd:
		m.ResetPnlInterestIncomeYtd()
		return nil
	case report.FieldPnlInterestExpensesYtd:
		m.ResetPnlInterestExpensesYtd()
		return nil
	case report.FieldPnlIncomeTaxYtd:
		m.ResetPnlIncomeTaxYtd()
		return nil
	case report.FieldPnlNetIncomeYtd:
		m.ResetPnlNetIncomeYtd()
		return nil
	case report.FieldCfCashSld:
		m.ResetCfCashSld()
		return nil
	case report.FieldCfNonCurrentLiabilitiesSld:
		m.ResetCfNonCurrentLiabilitiesSld()
		return nil
	case report.FieldCfCurrentLiabilitesSld:
		m.ResetCfCurrentLiabilitesSld()
		return nil
	case report.FieldCfNonControllingSld:
		m.ResetCfNonControllingSld()
		return nil
	case report.FieldCfEquitySld:
		m.ResetCfEquitySld()
		return nil
	case report.FieldCfTotalSld:
		m.ResetCfTotalSld()
		return nil
	case report.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown Report field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Emitent != nil {
		edges = append(edges, report.EdgeEmitent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case report.EdgeEmitent:
		if id := m._Emitent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReportMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Emitent {
		edges = append(edges, report.EdgeEmitent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReportMutation) EdgeCleared(name string) bool {
	switch name {
	case report.EdgeEmitent:
		return m.cleared_Emitent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReportMutation) ClearEdge(name string) error {
	switch name {
	case report.EdgeEmitent:
		m.ClearEmitent()
		return nil
	}
	return fmt.Errorf("unknown Report unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReportMutation) ResetEdge(name string) error {
	switch name {
	case report.EdgeEmitent:
		m.ResetEmitent()
		return nil
	}
	return fmt.Errorf("unknown Report edge %s", name)
}

// StrategyMutation represents an operation that mutates the Strategy nodes in the graph.
type StrategyMutation struct {
	config
	op                         Op
	typ                        string
	id                         *xid.ID
	_Descr                     *string
	_MaxTickers                *int
	add_MaxTickers             *int
	_MaxTickersPerIndustry     *int
	add_MaxTickersPerIndustry  *int
	_BaseIndex                 *string
	_LastYearInventResult      *float64
	add_LastYearInventResult   *float64
	_LastYearYield             *float64
	add_LastYearYield          *float64
	_Last3YearsInvertResult    *float64
	add_Last3YearsInvertResult *float64
	_Last3YearsYield           *float64
	add_Last3YearsYield        *float64
	_WeekRefillAmount          *float64
	add_WeekRefillAmount       *float64
	_StartAmount               *float64
	add_StartAmount            *float64
	_StartSimulation           *time.Time
	_BuyOnlyLowPrice           *bool
	_AllowLossWhenSell         *bool
	_SameEmitent               *int
	add_SameEmitent            *int
	clearedFields              map[string]struct{}
	_User                      *xid.ID
	cleared_User               bool
	_Factors                   map[xid.ID]struct{}
	removed_Factors            map[xid.ID]struct{}
	cleared_Factors            bool
	_Filters                   map[xid.ID]struct{}
	removed_Filters            map[xid.ID]struct{}
	cleared_Filters            bool
	_FixedTickers              map[xid.ID]struct{}
	removed_FixedTickers       map[xid.ID]struct{}
	cleared_FixedTickers       bool
	done                       bool
	oldValue                   func(context.Context) (*Strategy, error)
	predicates                 []predicate.Strategy
}

var _ ent.Mutation = (*StrategyMutation)(nil)

// strategyOption allows management of the mutation configuration using functional options.
type strategyOption func(*StrategyMutation)

// newStrategyMutation creates new mutation for the Strategy entity.
func newStrategyMutation(c config, op Op, opts ...strategyOption) *StrategyMutation {
	m := &StrategyMutation{
		config:        c,
		op:            op,
		typ:           TypeStrategy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStrategyID sets the ID field of the mutation.
func withStrategyID(id xid.ID) strategyOption {
	return func(m *StrategyMutation) {
		var (
			err   error
			once  sync.Once
			value *Strategy
		)
		m.oldValue = func(ctx context.Context) (*Strategy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Strategy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStrategy sets the old Strategy of the mutation.
func withStrategy(node *Strategy) strategyOption {
	return func(m *StrategyMutation) {
		m.oldValue = func(context.Context) (*Strategy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StrategyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StrategyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Strategy entities.
func (m *StrategyMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StrategyMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StrategyMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Strategy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescr sets the "Descr" field.
func (m *StrategyMutation) SetDescr(s string) {
	m._Descr = &s
}

// Descr returns the value of the "Descr" field in the mutation.
func (m *StrategyMutation) Descr() (r string, exists bool) {
	v := m._Descr
	if v == nil {
		return
	}
	return *v, true
}

// OldDescr returns the old "Descr" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldDescr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescr: %w", err)
	}
	return oldValue.Descr, nil
}

// ResetDescr resets all changes to the "Descr" field.
func (m *StrategyMutation) ResetDescr() {
	m._Descr = nil
}

// SetMaxTickers sets the "MaxTickers" field.
func (m *StrategyMutation) SetMaxTickers(i int) {
	m._MaxTickers = &i
	m.add_MaxTickers = nil
}

// MaxTickers returns the value of the "MaxTickers" field in the mutation.
func (m *StrategyMutation) MaxTickers() (r int, exists bool) {
	v := m._MaxTickers
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxTickers returns the old "MaxTickers" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldMaxTickers(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxTickers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxTickers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxTickers: %w", err)
	}
	return oldValue.MaxTickers, nil
}

// AddMaxTickers adds i to the "MaxTickers" field.
func (m *StrategyMutation) AddMaxTickers(i int) {
	if m.add_MaxTickers != nil {
		*m.add_MaxTickers += i
	} else {
		m.add_MaxTickers = &i
	}
}

// AddedMaxTickers returns the value that was added to the "MaxTickers" field in this mutation.
func (m *StrategyMutation) AddedMaxTickers() (r int, exists bool) {
	v := m.add_MaxTickers
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxTickers resets all changes to the "MaxTickers" field.
func (m *StrategyMutation) ResetMaxTickers() {
	m._MaxTickers = nil
	m.add_MaxTickers = nil
}

// SetMaxTickersPerIndustry sets the "MaxTickersPerIndustry" field.
func (m *StrategyMutation) SetMaxTickersPerIndustry(i int) {
	m._MaxTickersPerIndustry = &i
	m.add_MaxTickersPerIndustry = nil
}

// MaxTickersPerIndustry returns the value of the "MaxTickersPerIndustry" field in the mutation.
func (m *StrategyMutation) MaxTickersPerIndustry() (r int, exists bool) {
	v := m._MaxTickersPerIndustry
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxTickersPerIndustry returns the old "MaxTickersPerIndustry" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldMaxTickersPerIndustry(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxTickersPerIndustry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxTickersPerIndustry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxTickersPerIndustry: %w", err)
	}
	return oldValue.MaxTickersPerIndustry, nil
}

// AddMaxTickersPerIndustry adds i to the "MaxTickersPerIndustry" field.
func (m *StrategyMutation) AddMaxTickersPerIndustry(i int) {
	if m.add_MaxTickersPerIndustry != nil {
		*m.add_MaxTickersPerIndustry += i
	} else {
		m.add_MaxTickersPerIndustry = &i
	}
}

// AddedMaxTickersPerIndustry returns the value that was added to the "MaxTickersPerIndustry" field in this mutation.
func (m *StrategyMutation) AddedMaxTickersPerIndustry() (r int, exists bool) {
	v := m.add_MaxTickersPerIndustry
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxTickersPerIndustry resets all changes to the "MaxTickersPerIndustry" field.
func (m *StrategyMutation) ResetMaxTickersPerIndustry() {
	m._MaxTickersPerIndustry = nil
	m.add_MaxTickersPerIndustry = nil
}

// SetBaseIndex sets the "BaseIndex" field.
func (m *StrategyMutation) SetBaseIndex(s string) {
	m._BaseIndex = &s
}

// BaseIndex returns the value of the "BaseIndex" field in the mutation.
func (m *StrategyMutation) BaseIndex() (r string, exists bool) {
	v := m._BaseIndex
	if v == nil {
		return
	}
	return *v, true
}

// OldBaseIndex returns the old "BaseIndex" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldBaseIndex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaseIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaseIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaseIndex: %w", err)
	}
	return oldValue.BaseIndex, nil
}

// ClearBaseIndex clears the value of the "BaseIndex" field.
func (m *StrategyMutation) ClearBaseIndex() {
	m._BaseIndex = nil
	m.clearedFields[strategy.FieldBaseIndex] = struct{}{}
}

// BaseIndexCleared returns if the "BaseIndex" field was cleared in this mutation.
func (m *StrategyMutation) BaseIndexCleared() bool {
	_, ok := m.clearedFields[strategy.FieldBaseIndex]
	return ok
}

// ResetBaseIndex resets all changes to the "BaseIndex" field.
func (m *StrategyMutation) ResetBaseIndex() {
	m._BaseIndex = nil
	delete(m.clearedFields, strategy.FieldBaseIndex)
}

// SetLastYearInventResult sets the "LastYearInventResult" field.
func (m *StrategyMutation) SetLastYearInventResult(f float64) {
	m._LastYearInventResult = &f
	m.add_LastYearInventResult = nil
}

// LastYearInventResult returns the value of the "LastYearInventResult" field in the mutation.
func (m *StrategyMutation) LastYearInventResult() (r float64, exists bool) {
	v := m._LastYearInventResult
	if v == nil {
		return
	}
	return *v, true
}

// OldLastYearInventResult returns the old "LastYearInventResult" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldLastYearInventResult(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastYearInventResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastYearInventResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastYearInventResult: %w", err)
	}
	return oldValue.LastYearInventResult, nil
}

// AddLastYearInventResult adds f to the "LastYearInventResult" field.
func (m *StrategyMutation) AddLastYearInventResult(f float64) {
	if m.add_LastYearInventResult != nil {
		*m.add_LastYearInventResult += f
	} else {
		m.add_LastYearInventResult = &f
	}
}

// AddedLastYearInventResult returns the value that was added to the "LastYearInventResult" field in this mutation.
func (m *StrategyMutation) AddedLastYearInventResult() (r float64, exists bool) {
	v := m.add_LastYearInventResult
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastYearInventResult resets all changes to the "LastYearInventResult" field.
func (m *StrategyMutation) ResetLastYearInventResult() {
	m._LastYearInventResult = nil
	m.add_LastYearInventResult = nil
}

// SetLastYearYield sets the "LastYearYield" field.
func (m *StrategyMutation) SetLastYearYield(f float64) {
	m._LastYearYield = &f
	m.add_LastYearYield = nil
}

// LastYearYield returns the value of the "LastYearYield" field in the mutation.
func (m *StrategyMutation) LastYearYield() (r float64, exists bool) {
	v := m._LastYearYield
	if v == nil {
		return
	}
	return *v, true
}

// OldLastYearYield returns the old "LastYearYield" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldLastYearYield(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastYearYield is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastYearYield requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastYearYield: %w", err)
	}
	return oldValue.LastYearYield, nil
}

// AddLastYearYield adds f to the "LastYearYield" field.
func (m *StrategyMutation) AddLastYearYield(f float64) {
	if m.add_LastYearYield != nil {
		*m.add_LastYearYield += f
	} else {
		m.add_LastYearYield = &f
	}
}

// AddedLastYearYield returns the value that was added to the "LastYearYield" field in this mutation.
func (m *StrategyMutation) AddedLastYearYield() (r float64, exists bool) {
	v := m.add_LastYearYield
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastYearYield resets all changes to the "LastYearYield" field.
func (m *StrategyMutation) ResetLastYearYield() {
	m._LastYearYield = nil
	m.add_LastYearYield = nil
}

// SetLast3YearsInvertResult sets the "Last3YearsInvertResult" field.
func (m *StrategyMutation) SetLast3YearsInvertResult(f float64) {
	m._Last3YearsInvertResult = &f
	m.add_Last3YearsInvertResult = nil
}

// Last3YearsInvertResult returns the value of the "Last3YearsInvertResult" field in the mutation.
func (m *StrategyMutation) Last3YearsInvertResult() (r float64, exists bool) {
	v := m._Last3YearsInvertResult
	if v == nil {
		return
	}
	return *v, true
}

// OldLast3YearsInvertResult returns the old "Last3YearsInvertResult" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldLast3YearsInvertResult(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLast3YearsInvertResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLast3YearsInvertResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLast3YearsInvertResult: %w", err)
	}
	return oldValue.Last3YearsInvertResult, nil
}

// AddLast3YearsInvertResult adds f to the "Last3YearsInvertResult" field.
func (m *StrategyMutation) AddLast3YearsInvertResult(f float64) {
	if m.add_Last3YearsInvertResult != nil {
		*m.add_Last3YearsInvertResult += f
	} else {
		m.add_Last3YearsInvertResult = &f
	}
}

// AddedLast3YearsInvertResult returns the value that was added to the "Last3YearsInvertResult" field in this mutation.
func (m *StrategyMutation) AddedLast3YearsInvertResult() (r float64, exists bool) {
	v := m.add_Last3YearsInvertResult
	if v == nil {
		return
	}
	return *v, true
}

// ResetLast3YearsInvertResult resets all changes to the "Last3YearsInvertResult" field.
func (m *StrategyMutation) ResetLast3YearsInvertResult() {
	m._Last3YearsInvertResult = nil
	m.add_Last3YearsInvertResult = nil
}

// SetLast3YearsYield sets the "Last3YearsYield" field.
func (m *StrategyMutation) SetLast3YearsYield(f float64) {
	m._Last3YearsYield = &f
	m.add_Last3YearsYield = nil
}

// Last3YearsYield returns the value of the "Last3YearsYield" field in the mutation.
func (m *StrategyMutation) Last3YearsYield() (r float64, exists bool) {
	v := m._Last3YearsYield
	if v == nil {
		return
	}
	return *v, true
}

// OldLast3YearsYield returns the old "Last3YearsYield" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldLast3YearsYield(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLast3YearsYield is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLast3YearsYield requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLast3YearsYield: %w", err)
	}
	return oldValue.Last3YearsYield, nil
}

// AddLast3YearsYield adds f to the "Last3YearsYield" field.
func (m *StrategyMutation) AddLast3YearsYield(f float64) {
	if m.add_Last3YearsYield != nil {
		*m.add_Last3YearsYield += f
	} else {
		m.add_Last3YearsYield = &f
	}
}

// AddedLast3YearsYield returns the value that was added to the "Last3YearsYield" field in this mutation.
func (m *StrategyMutation) AddedLast3YearsYield() (r float64, exists bool) {
	v := m.add_Last3YearsYield
	if v == nil {
		return
	}
	return *v, true
}

// ResetLast3YearsYield resets all changes to the "Last3YearsYield" field.
func (m *StrategyMutation) ResetLast3YearsYield() {
	m._Last3YearsYield = nil
	m.add_Last3YearsYield = nil
}

// SetWeekRefillAmount sets the "WeekRefillAmount" field.
func (m *StrategyMutation) SetWeekRefillAmount(f float64) {
	m._WeekRefillAmount = &f
	m.add_WeekRefillAmount = nil
}

// WeekRefillAmount returns the value of the "WeekRefillAmount" field in the mutation.
func (m *StrategyMutation) WeekRefillAmount() (r float64, exists bool) {
	v := m._WeekRefillAmount
	if v == nil {
		return
	}
	return *v, true
}

// OldWeekRefillAmount returns the old "WeekRefillAmount" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldWeekRefillAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeekRefillAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeekRefillAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeekRefillAmount: %w", err)
	}
	return oldValue.WeekRefillAmount, nil
}

// AddWeekRefillAmount adds f to the "WeekRefillAmount" field.
func (m *StrategyMutation) AddWeekRefillAmount(f float64) {
	if m.add_WeekRefillAmount != nil {
		*m.add_WeekRefillAmount += f
	} else {
		m.add_WeekRefillAmount = &f
	}
}

// AddedWeekRefillAmount returns the value that was added to the "WeekRefillAmount" field in this mutation.
func (m *StrategyMutation) AddedWeekRefillAmount() (r float64, exists bool) {
	v := m.add_WeekRefillAmount
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeekRefillAmount resets all changes to the "WeekRefillAmount" field.
func (m *StrategyMutation) ResetWeekRefillAmount() {
	m._WeekRefillAmount = nil
	m.add_WeekRefillAmount = nil
}

// SetStartAmount sets the "StartAmount" field.
func (m *StrategyMutation) SetStartAmount(f float64) {
	m._StartAmount = &f
	m.add_StartAmount = nil
}

// StartAmount returns the value of the "StartAmount" field in the mutation.
func (m *StrategyMutation) StartAmount() (r float64, exists bool) {
	v := m._StartAmount
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAmount returns the old "StartAmount" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldStartAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAmount: %w", err)
	}
	return oldValue.StartAmount, nil
}

// AddStartAmount adds f to the "StartAmount" field.
func (m *StrategyMutation) AddStartAmount(f float64) {
	if m.add_StartAmount != nil {
		*m.add_StartAmount += f
	} else {
		m.add_StartAmount = &f
	}
}

// AddedStartAmount returns the value that was added to the "StartAmount" field in this mutation.
func (m *StrategyMutation) AddedStartAmount() (r float64, exists bool) {
	v := m.add_StartAmount
	if v == nil {
		return
	}
	return *v, true
}

// ResetStartAmount resets all changes to the "StartAmount" field.
func (m *StrategyMutation) ResetStartAmount() {
	m._StartAmount = nil
	m.add_StartAmount = nil
}

// SetStartSimulation sets the "StartSimulation" field.
func (m *StrategyMutation) SetStartSimulation(t time.Time) {
	m._StartSimulation = &t
}

// StartSimulation returns the value of the "StartSimulation" field in the mutation.
func (m *StrategyMutation) StartSimulation() (r time.Time, exists bool) {
	v := m._StartSimulation
	if v == nil {
		return
	}
	return *v, true
}

// OldStartSimulation returns the old "StartSimulation" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldStartSimulation(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartSimulation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartSimulation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartSimulation: %w", err)
	}
	return oldValue.StartSimulation, nil
}

// ResetStartSimulation resets all changes to the "StartSimulation" field.
func (m *StrategyMutation) ResetStartSimulation() {
	m._StartSimulation = nil
}

// SetBuyOnlyLowPrice sets the "BuyOnlyLowPrice" field.
func (m *StrategyMutation) SetBuyOnlyLowPrice(b bool) {
	m._BuyOnlyLowPrice = &b
}

// BuyOnlyLowPrice returns the value of the "BuyOnlyLowPrice" field in the mutation.
func (m *StrategyMutation) BuyOnlyLowPrice() (r bool, exists bool) {
	v := m._BuyOnlyLowPrice
	if v == nil {
		return
	}
	return *v, true
}

// OldBuyOnlyLowPrice returns the old "BuyOnlyLowPrice" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldBuyOnlyLowPrice(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuyOnlyLowPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuyOnlyLowPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuyOnlyLowPrice: %w", err)
	}
	return oldValue.BuyOnlyLowPrice, nil
}

// ResetBuyOnlyLowPrice resets all changes to the "BuyOnlyLowPrice" field.
func (m *StrategyMutation) ResetBuyOnlyLowPrice() {
	m._BuyOnlyLowPrice = nil
}

// SetAllowLossWhenSell sets the "AllowLossWhenSell" field.
func (m *StrategyMutation) SetAllowLossWhenSell(b bool) {
	m._AllowLossWhenSell = &b
}

// AllowLossWhenSell returns the value of the "AllowLossWhenSell" field in the mutation.
func (m *StrategyMutation) AllowLossWhenSell() (r bool, exists bool) {
	v := m._AllowLossWhenSell
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowLossWhenSell returns the old "AllowLossWhenSell" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldAllowLossWhenSell(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowLossWhenSell is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowLossWhenSell requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowLossWhenSell: %w", err)
	}
	return oldValue.AllowLossWhenSell, nil
}

// ResetAllowLossWhenSell resets all changes to the "AllowLossWhenSell" field.
func (m *StrategyMutation) ResetAllowLossWhenSell() {
	m._AllowLossWhenSell = nil
}

// SetSameEmitent sets the "SameEmitent" field.
func (m *StrategyMutation) SetSameEmitent(i int) {
	m._SameEmitent = &i
	m.add_SameEmitent = nil
}

// SameEmitent returns the value of the "SameEmitent" field in the mutation.
func (m *StrategyMutation) SameEmitent() (r int, exists bool) {
	v := m._SameEmitent
	if v == nil {
		return
	}
	return *v, true
}

// OldSameEmitent returns the old "SameEmitent" field's value of the Strategy entity.
// If the Strategy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyMutation) OldSameEmitent(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSameEmitent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSameEmitent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSameEmitent: %w", err)
	}
	return oldValue.SameEmitent, nil
}

// AddSameEmitent adds i to the "SameEmitent" field.
func (m *StrategyMutation) AddSameEmitent(i int) {
	if m.add_SameEmitent != nil {
		*m.add_SameEmitent += i
	} else {
		m.add_SameEmitent = &i
	}
}

// AddedSameEmitent returns the value that was added to the "SameEmitent" field in this mutation.
func (m *StrategyMutation) AddedSameEmitent() (r int, exists bool) {
	v := m.add_SameEmitent
	if v == nil {
		return
	}
	return *v, true
}

// ResetSameEmitent resets all changes to the "SameEmitent" field.
func (m *StrategyMutation) ResetSameEmitent() {
	m._SameEmitent = nil
	m.add_SameEmitent = nil
}

// SetUserID sets the "User" edge to the User entity by id.
func (m *StrategyMutation) SetUserID(id xid.ID) {
	m._User = &id
}

// ClearUser clears the "User" edge to the User entity.
func (m *StrategyMutation) ClearUser() {
	m.cleared_User = true
}

// UserCleared reports if the "User" edge to the User entity was cleared.
func (m *StrategyMutation) UserCleared() bool {
	return m.cleared_User
}

// UserID returns the "User" edge ID in the mutation.
func (m *StrategyMutation) UserID() (id xid.ID, exists bool) {
	if m._User != nil {
		return *m._User, true
	}
	return
}

// UserIDs returns the "User" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *StrategyMutation) UserIDs() (ids []xid.ID) {
	if id := m._User; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "User" edge.
func (m *StrategyMutation) ResetUser() {
	m._User = nil
	m.cleared_User = false
}

// AddFactorIDs adds the "Factors" edge to the StrategyFactor entity by ids.
func (m *StrategyMutation) AddFactorIDs(ids ...xid.ID) {
	if m._Factors == nil {
		m._Factors = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m._Factors[ids[i]] = struct{}{}
	}
}

// ClearFactors clears the "Factors" edge to the StrategyFactor entity.
func (m *StrategyMutation) ClearFactors() {
	m.cleared_Factors = true
}

// FactorsCleared reports if the "Factors" edge to the StrategyFactor entity was cleared.
func (m *StrategyMutation) FactorsCleared() bool {
	return m.cleared_Factors
}

// RemoveFactorIDs removes the "Factors" edge to the StrategyFactor entity by IDs.
func (m *StrategyMutation) RemoveFactorIDs(ids ...xid.ID) {
	if m.removed_Factors == nil {
		m.removed_Factors = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m._Factors, ids[i])
		m.removed_Factors[ids[i]] = struct{}{}
	}
}

// RemovedFactors returns the removed IDs of the "Factors" edge to the StrategyFactor entity.
func (m *StrategyMutation) RemovedFactorsIDs() (ids []xid.ID) {
	for id := range m.removed_Factors {
		ids = append(ids, id)
	}
	return
}

// FactorsIDs returns the "Factors" edge IDs in the mutation.
func (m *StrategyMutation) FactorsIDs() (ids []xid.ID) {
	for id := range m._Factors {
		ids = append(ids, id)
	}
	return
}

// ResetFactors resets all changes to the "Factors" edge.
func (m *StrategyMutation) ResetFactors() {
	m._Factors = nil
	m.cleared_Factors = false
	m.removed_Factors = nil
}

// AddFilterIDs adds the "Filters" edge to the StrategyFilter entity by ids.
func (m *StrategyMutation) AddFilterIDs(ids ...xid.ID) {
	if m._Filters == nil {
		m._Filters = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m._Filters[ids[i]] = struct{}{}
	}
}

// ClearFilters clears the "Filters" edge to the StrategyFilter entity.
func (m *StrategyMutation) ClearFilters() {
	m.cleared_Filters = true
}

// FiltersCleared reports if the "Filters" edge to the StrategyFilter entity was cleared.
func (m *StrategyMutation) FiltersCleared() bool {
	return m.cleared_Filters
}

// RemoveFilterIDs removes the "Filters" edge to the StrategyFilter entity by IDs.
func (m *StrategyMutation) RemoveFilterIDs(ids ...xid.ID) {
	if m.removed_Filters == nil {
		m.removed_Filters = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m._Filters, ids[i])
		m.removed_Filters[ids[i]] = struct{}{}
	}
}

// RemovedFilters returns the removed IDs of the "Filters" edge to the StrategyFilter entity.
func (m *StrategyMutation) RemovedFiltersIDs() (ids []xid.ID) {
	for id := range m.removed_Filters {
		ids = append(ids, id)
	}
	return
}

// FiltersIDs returns the "Filters" edge IDs in the mutation.
func (m *StrategyMutation) FiltersIDs() (ids []xid.ID) {
	for id := range m._Filters {
		ids = append(ids, id)
	}
	return
}

// ResetFilters resets all changes to the "Filters" edge.
func (m *StrategyMutation) ResetFilters() {
	m._Filters = nil
	m.cleared_Filters = false
	m.removed_Filters = nil
}

// AddFixedTickerIDs adds the "FixedTickers" edge to the StrategyFixedTicker entity by ids.
func (m *StrategyMutation) AddFixedTickerIDs(ids ...xid.ID) {
	if m._FixedTickers == nil {
		m._FixedTickers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m._FixedTickers[ids[i]] = struct{}{}
	}
}

// ClearFixedTickers clears the "FixedTickers" edge to the StrategyFixedTicker entity.
func (m *StrategyMutation) ClearFixedTickers() {
	m.cleared_FixedTickers = true
}

// FixedTickersCleared reports if the "FixedTickers" edge to the StrategyFixedTicker entity was cleared.
func (m *StrategyMutation) FixedTickersCleared() bool {
	return m.cleared_FixedTickers
}

// RemoveFixedTickerIDs removes the "FixedTickers" edge to the StrategyFixedTicker entity by IDs.
func (m *StrategyMutation) RemoveFixedTickerIDs(ids ...xid.ID) {
	if m.removed_FixedTickers == nil {
		m.removed_FixedTickers = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m._FixedTickers, ids[i])
		m.removed_FixedTickers[ids[i]] = struct{}{}
	}
}

// RemovedFixedTickers returns the removed IDs of the "FixedTickers" edge to the StrategyFixedTicker entity.
func (m *StrategyMutation) RemovedFixedTickersIDs() (ids []xid.ID) {
	for id := range m.removed_FixedTickers {
		ids = append(ids, id)
	}
	return
}

// FixedTickersIDs returns the "FixedTickers" edge IDs in the mutation.
func (m *StrategyMutation) FixedTickersIDs() (ids []xid.ID) {
	for id := range m._FixedTickers {
		ids = append(ids, id)
	}
	return
}

// ResetFixedTickers resets all changes to the "FixedTickers" edge.
func (m *StrategyMutation) ResetFixedTickers() {
	m._FixedTickers = nil
	m.cleared_FixedTickers = false
	m.removed_FixedTickers = nil
}

// Where appends a list predicates to the StrategyMutation builder.
func (m *StrategyMutation) Where(ps ...predicate.Strategy) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StrategyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Strategy).
func (m *StrategyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StrategyMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m._Descr != nil {
		fields = append(fields, strategy.FieldDescr)
	}
	if m._MaxTickers != nil {
		fields = append(fields, strategy.FieldMaxTickers)
	}
	if m._MaxTickersPerIndustry != nil {
		fields = append(fields, strategy.FieldMaxTickersPerIndustry)
	}
	if m._BaseIndex != nil {
		fields = append(fields, strategy.FieldBaseIndex)
	}
	if m._LastYearInventResult != nil {
		fields = append(fields, strategy.FieldLastYearInventResult)
	}
	if m._LastYearYield != nil {
		fields = append(fields, strategy.FieldLastYearYield)
	}
	if m._Last3YearsInvertResult != nil {
		fields = append(fields, strategy.FieldLast3YearsInvertResult)
	}
	if m._Last3YearsYield != nil {
		fields = append(fields, strategy.FieldLast3YearsYield)
	}
	if m._WeekRefillAmount != nil {
		fields = append(fields, strategy.FieldWeekRefillAmount)
	}
	if m._StartAmount != nil {
		fields = append(fields, strategy.FieldStartAmount)
	}
	if m._StartSimulation != nil {
		fields = append(fields, strategy.FieldStartSimulation)
	}
	if m._BuyOnlyLowPrice != nil {
		fields = append(fields, strategy.FieldBuyOnlyLowPrice)
	}
	if m._AllowLossWhenSell != nil {
		fields = append(fields, strategy.FieldAllowLossWhenSell)
	}
	if m._SameEmitent != nil {
		fields = append(fields, strategy.FieldSameEmitent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StrategyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case strategy.FieldDescr:
		return m.Descr()
	case strategy.FieldMaxTickers:
		return m.MaxTickers()
	case strategy.FieldMaxTickersPerIndustry:
		return m.MaxTickersPerIndustry()
	case strategy.FieldBaseIndex:
		return m.BaseIndex()
	case strategy.FieldLastYearInventResult:
		return m.LastYearInventResult()
	case strategy.FieldLastYearYield:
		return m.LastYearYield()
	case strategy.FieldLast3YearsInvertResult:
		return m.Last3YearsInvertResult()
	case strategy.FieldLast3YearsYield:
		return m.Last3YearsYield()
	case strategy.FieldWeekRefillAmount:
		return m.WeekRefillAmount()
	case strategy.FieldStartAmount:
		return m.StartAmount()
	case strategy.FieldStartSimulation:
		return m.StartSimulation()
	case strategy.FieldBuyOnlyLowPrice:
		return m.BuyOnlyLowPrice()
	case strategy.FieldAllowLossWhenSell:
		return m.AllowLossWhenSell()
	case strategy.FieldSameEmitent:
		return m.SameEmitent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StrategyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case strategy.FieldDescr:
		return m.OldDescr(ctx)
	case strategy.FieldMaxTickers:
		return m.OldMaxTickers(ctx)
	case strategy.FieldMaxTickersPerIndustry:
		return m.OldMaxTickersPerIndustry(ctx)
	case strategy.FieldBaseIndex:
		return m.OldBaseIndex(ctx)
	case strategy.FieldLastYearInventResult:
		return m.OldLastYearInventResult(ctx)
	case strategy.FieldLastYearYield:
		return m.OldLastYearYield(ctx)
	case strategy.FieldLast3YearsInvertResult:
		return m.OldLast3YearsInvertResult(ctx)
	case strategy.FieldLast3YearsYield:
		return m.OldLast3YearsYield(ctx)
	case strategy.FieldWeekRefillAmount:
		return m.OldWeekRefillAmount(ctx)
	case strategy.FieldStartAmount:
		return m.OldStartAmount(ctx)
	case strategy.FieldStartSimulation:
		return m.OldStartSimulation(ctx)
	case strategy.FieldBuyOnlyLowPrice:
		return m.OldBuyOnlyLowPrice(ctx)
	case strategy.FieldAllowLossWhenSell:
		return m.OldAllowLossWhenSell(ctx)
	case strategy.FieldSameEmitent:
		return m.OldSameEmitent(ctx)
	}
	return nil, fmt.Errorf("unknown Strategy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case strategy.FieldDescr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescr(v)
		return nil
	case strategy.FieldMaxTickers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxTickers(v)
		return nil
	case strategy.FieldMaxTickersPerIndustry:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxTickersPerIndustry(v)
		return nil
	case strategy.FieldBaseIndex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaseIndex(v)
		return nil
	case strategy.FieldLastYearInventResult:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastYearInventResult(v)
		return nil
	case strategy.FieldLastYearYield:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastYearYield(v)
		return nil
	case strategy.FieldLast3YearsInvertResult:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLast3YearsInvertResult(v)
		return nil
	case strategy.FieldLast3YearsYield:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLast3YearsYield(v)
		return nil
	case strategy.FieldWeekRefillAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeekRefillAmount(v)
		return nil
	case strategy.FieldStartAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAmount(v)
		return nil
	case strategy.FieldStartSimulation:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartSimulation(v)
		return nil
	case strategy.FieldBuyOnlyLowPrice:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuyOnlyLowPrice(v)
		return nil
	case strategy.FieldAllowLossWhenSell:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowLossWhenSell(v)
		return nil
	case strategy.FieldSameEmitent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSameEmitent(v)
		return nil
	}
	return fmt.Errorf("unknown Strategy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StrategyMutation) AddedFields() []string {
	var fields []string
	if m.add_MaxTickers != nil {
		fields = append(fields, strategy.FieldMaxTickers)
	}
	if m.add_MaxTickersPerIndustry != nil {
		fields = append(fields, strategy.FieldMaxTickersPerIndustry)
	}
	if m.add_LastYearInventResult != nil {
		fields = append(fields, strategy.FieldLastYearInventResult)
	}
	if m.add_LastYearYield != nil {
		fields = append(fields, strategy.FieldLastYearYield)
	}
	if m.add_Last3YearsInvertResult != nil {
		fields = append(fields, strategy.FieldLast3YearsInvertResult)
	}
	if m.add_Last3YearsYield != nil {
		fields = append(fields, strategy.FieldLast3YearsYield)
	}
	if m.add_WeekRefillAmount != nil {
		fields = append(fields, strategy.FieldWeekRefillAmount)
	}
	if m.add_StartAmount != nil {
		fields = append(fields, strategy.FieldStartAmount)
	}
	if m.add_SameEmitent != nil {
		fields = append(fields, strategy.FieldSameEmitent)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StrategyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case strategy.FieldMaxTickers:
		return m.AddedMaxTickers()
	case strategy.FieldMaxTickersPerIndustry:
		return m.AddedMaxTickersPerIndustry()
	case strategy.FieldLastYearInventResult:
		return m.AddedLastYearInventResult()
	case strategy.FieldLastYearYield:
		return m.AddedLastYearYield()
	case strategy.FieldLast3YearsInvertResult:
		return m.AddedLast3YearsInvertResult()
	case strategy.FieldLast3YearsYield:
		return m.AddedLast3YearsYield()
	case strategy.FieldWeekRefillAmount:
		return m.AddedWeekRefillAmount()
	case strategy.FieldStartAmount:
		return m.AddedStartAmount()
	case strategy.FieldSameEmitent:
		return m.AddedSameEmitent()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case strategy.FieldMaxTickers:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxTickers(v)
		return nil
	case strategy.FieldMaxTickersPerIndustry:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxTickersPerIndustry(v)
		return nil
	case strategy.FieldLastYearInventResult:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastYearInventResult(v)
		return nil
	case strategy.FieldLastYearYield:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastYearYield(v)
		return nil
	case strategy.FieldLast3YearsInvertResult:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLast3YearsInvertResult(v)
		return nil
	case strategy.FieldLast3YearsYield:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLast3YearsYield(v)
		return nil
	case strategy.FieldWeekRefillAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeekRefillAmount(v)
		return nil
	case strategy.FieldStartAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStartAmount(v)
		return nil
	case strategy.FieldSameEmitent:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSameEmitent(v)
		return nil
	}
	return fmt.Errorf("unknown Strategy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StrategyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(strategy.FieldBaseIndex) {
		fields = append(fields, strategy.FieldBaseIndex)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StrategyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StrategyMutation) ClearField(name string) error {
	switch name {
	case strategy.FieldBaseIndex:
		m.ClearBaseIndex()
		return nil
	}
	return fmt.Errorf("unknown Strategy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StrategyMutation) ResetField(name string) error {
	switch name {
	case strategy.FieldDescr:
		m.ResetDescr()
		return nil
	case strategy.FieldMaxTickers:
		m.ResetMaxTickers()
		return nil
	case strategy.FieldMaxTickersPerIndustry:
		m.ResetMaxTickersPerIndustry()
		return nil
	case strategy.FieldBaseIndex:
		m.ResetBaseIndex()
		return nil
	case strategy.FieldLastYearInventResult:
		m.ResetLastYearInventResult()
		return nil
	case strategy.FieldLastYearYield:
		m.ResetLastYearYield()
		return nil
	case strategy.FieldLast3YearsInvertResult:
		m.ResetLast3YearsInvertResult()
		return nil
	case strategy.FieldLast3YearsYield:
		m.ResetLast3YearsYield()
		return nil
	case strategy.FieldWeekRefillAmount:
		m.ResetWeekRefillAmount()
		return nil
	case strategy.FieldStartAmount:
		m.ResetStartAmount()
		return nil
	case strategy.FieldStartSimulation:
		m.ResetStartSimulation()
		return nil
	case strategy.FieldBuyOnlyLowPrice:
		m.ResetBuyOnlyLowPrice()
		return nil
	case strategy.FieldAllowLossWhenSell:
		m.ResetAllowLossWhenSell()
		return nil
	case strategy.FieldSameEmitent:
		m.ResetSameEmitent()
		return nil
	}
	return fmt.Errorf("unknown Strategy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StrategyMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._User != nil {
		edges = append(edges, strategy.EdgeUser)
	}
	if m._Factors != nil {
		edges = append(edges, strategy.EdgeFactors)
	}
	if m._Filters != nil {
		edges = append(edges, strategy.EdgeFilters)
	}
	if m._FixedTickers != nil {
		edges = append(edges, strategy.EdgeFixedTickers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StrategyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case strategy.EdgeUser:
		if id := m._User; id != nil {
			return []ent.Value{*id}
		}
	case strategy.EdgeFactors:
		ids := make([]ent.Value, 0, len(m._Factors))
		for id := range m._Factors {
			ids = append(ids, id)
		}
		return ids
	case strategy.EdgeFilters:
		ids := make([]ent.Value, 0, len(m._Filters))
		for id := range m._Filters {
			ids = append(ids, id)
		}
		return ids
	case strategy.EdgeFixedTickers:
		ids := make([]ent.Value, 0, len(m._FixedTickers))
		for id := range m._FixedTickers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StrategyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_Factors != nil {
		edges = append(edges, strategy.EdgeFactors)
	}
	if m.removed_Filters != nil {
		edges = append(edges, strategy.EdgeFilters)
	}
	if m.removed_FixedTickers != nil {
		edges = append(edges, strategy.EdgeFixedTickers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StrategyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case strategy.EdgeFactors:
		ids := make([]ent.Value, 0, len(m.removed_Factors))
		for id := range m.removed_Factors {
			ids = append(ids, id)
		}
		return ids
	case strategy.EdgeFilters:
		ids := make([]ent.Value, 0, len(m.removed_Filters))
		for id := range m.removed_Filters {
			ids = append(ids, id)
		}
		return ids
	case strategy.EdgeFixedTickers:
		ids := make([]ent.Value, 0, len(m.removed_FixedTickers))
		for id := range m.removed_FixedTickers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StrategyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_User {
		edges = append(edges, strategy.EdgeUser)
	}
	if m.cleared_Factors {
		edges = append(edges, strategy.EdgeFactors)
	}
	if m.cleared_Filters {
		edges = append(edges, strategy.EdgeFilters)
	}
	if m.cleared_FixedTickers {
		edges = append(edges, strategy.EdgeFixedTickers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StrategyMutation) EdgeCleared(name string) bool {
	switch name {
	case strategy.EdgeUser:
		return m.cleared_User
	case strategy.EdgeFactors:
		return m.cleared_Factors
	case strategy.EdgeFilters:
		return m.cleared_Filters
	case strategy.EdgeFixedTickers:
		return m.cleared_FixedTickers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StrategyMutation) ClearEdge(name string) error {
	switch name {
	case strategy.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Strategy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StrategyMutation) ResetEdge(name string) error {
	switch name {
	case strategy.EdgeUser:
		m.ResetUser()
		return nil
	case strategy.EdgeFactors:
		m.ResetFactors()
		return nil
	case strategy.EdgeFilters:
		m.ResetFilters()
		return nil
	case strategy.EdgeFixedTickers:
		m.ResetFixedTickers()
		return nil
	}
	return fmt.Errorf("unknown Strategy edge %s", name)
}

// StrategyFactorMutation represents an operation that mutates the StrategyFactor nodes in the graph.
type StrategyFactorMutation struct {
	config
	op                Op
	typ               string
	id                *xid.ID
	_LineNum          *int
	add_LineNum       *int
	_IsUsed           *bool
	_RK               *int
	add_RK            *int
	_RVT              *int
	add_RVT           *int
	_MinAcceptabe     *float64
	add_MinAcceptabe  *float64
	_MaxAcceptable    *float64
	add_MaxAcceptable *float64
	_Inverse          *bool
	_K                *float64
	add_K             *float64
	_Gist             *float64
	add_Gist          *float64
	clearedFields     map[string]struct{}
	_Strategy         *xid.ID
	cleared_Strategy  bool
	done              bool
	oldValue          func(context.Context) (*StrategyFactor, error)
	predicates        []predicate.StrategyFactor
}

var _ ent.Mutation = (*StrategyFactorMutation)(nil)

// strategyfactorOption allows management of the mutation configuration using functional options.
type strategyfactorOption func(*StrategyFactorMutation)

// newStrategyFactorMutation creates new mutation for the StrategyFactor entity.
func newStrategyFactorMutation(c config, op Op, opts ...strategyfactorOption) *StrategyFactorMutation {
	m := &StrategyFactorMutation{
		config:        c,
		op:            op,
		typ:           TypeStrategyFactor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStrategyFactorID sets the ID field of the mutation.
func withStrategyFactorID(id xid.ID) strategyfactorOption {
	return func(m *StrategyFactorMutation) {
		var (
			err   error
			once  sync.Once
			value *StrategyFactor
		)
		m.oldValue = func(ctx context.Context) (*StrategyFactor, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StrategyFactor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStrategyFactor sets the old StrategyFactor of the mutation.
func withStrategyFactor(node *StrategyFactor) strategyfactorOption {
	return func(m *StrategyFactorMutation) {
		m.oldValue = func(context.Context) (*StrategyFactor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StrategyFactorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StrategyFactorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StrategyFactor entities.
func (m *StrategyFactorMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StrategyFactorMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StrategyFactorMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StrategyFactor.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLineNum sets the "LineNum" field.
func (m *StrategyFactorMutation) SetLineNum(i int) {
	m._LineNum = &i
	m.add_LineNum = nil
}

// LineNum returns the value of the "LineNum" field in the mutation.
func (m *StrategyFactorMutation) LineNum() (r int, exists bool) {
	v := m._LineNum
	if v == nil {
		return
	}
	return *v, true
}

// OldLineNum returns the old "LineNum" field's value of the StrategyFactor entity.
// If the StrategyFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyFactorMutation) OldLineNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineNum: %w", err)
	}
	return oldValue.LineNum, nil
}

// AddLineNum adds i to the "LineNum" field.
func (m *StrategyFactorMutation) AddLineNum(i int) {
	if m.add_LineNum != nil {
		*m.add_LineNum += i
	} else {
		m.add_LineNum = &i
	}
}

// AddedLineNum returns the value that was added to the "LineNum" field in this mutation.
func (m *StrategyFactorMutation) AddedLineNum() (r int, exists bool) {
	v := m.add_LineNum
	if v == nil {
		return
	}
	return *v, true
}

// ResetLineNum resets all changes to the "LineNum" field.
func (m *StrategyFactorMutation) ResetLineNum() {
	m._LineNum = nil
	m.add_LineNum = nil
}

// SetIsUsed sets the "IsUsed" field.
func (m *StrategyFactorMutation) SetIsUsed(b bool) {
	m._IsUsed = &b
}

// IsUsed returns the value of the "IsUsed" field in the mutation.
func (m *StrategyFactorMutation) IsUsed() (r bool, exists bool) {
	v := m._IsUsed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsUsed returns the old "IsUsed" field's value of the StrategyFactor entity.
// If the StrategyFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyFactorMutation) OldIsUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsUsed: %w", err)
	}
	return oldValue.IsUsed, nil
}

// ResetIsUsed resets all changes to the "IsUsed" field.
func (m *StrategyFactorMutation) ResetIsUsed() {
	m._IsUsed = nil
}

// SetRK sets the "RK" field.
func (m *StrategyFactorMutation) SetRK(i int) {
	m._RK = &i
	m.add_RK = nil
}

// RK returns the value of the "RK" field in the mutation.
func (m *StrategyFactorMutation) RK() (r int, exists bool) {
	v := m._RK
	if v == nil {
		return
	}
	return *v, true
}

// OldRK returns the old "RK" field's value of the StrategyFactor entity.
// If the StrategyFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyFactorMutation) OldRK(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRK is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRK requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRK: %w", err)
	}
	return oldValue.RK, nil
}

// AddRK adds i to the "RK" field.
func (m *StrategyFactorMutation) AddRK(i int) {
	if m.add_RK != nil {
		*m.add_RK += i
	} else {
		m.add_RK = &i
	}
}

// AddedRK returns the value that was added to the "RK" field in this mutation.
func (m *StrategyFactorMutation) AddedRK() (r int, exists bool) {
	v := m.add_RK
	if v == nil {
		return
	}
	return *v, true
}

// ResetRK resets all changes to the "RK" field.
func (m *StrategyFactorMutation) ResetRK() {
	m._RK = nil
	m.add_RK = nil
}

// SetRVT sets the "RVT" field.
func (m *StrategyFactorMutation) SetRVT(i int) {
	m._RVT = &i
	m.add_RVT = nil
}

// RVT returns the value of the "RVT" field in the mutation.
func (m *StrategyFactorMutation) RVT() (r int, exists bool) {
	v := m._RVT
	if v == nil {
		return
	}
	return *v, true
}

// OldRVT returns the old "RVT" field's value of the StrategyFactor entity.
// If the StrategyFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyFactorMutation) OldRVT(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRVT is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRVT requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRVT: %w", err)
	}
	return oldValue.RVT, nil
}

// AddRVT adds i to the "RVT" field.
func (m *StrategyFactorMutation) AddRVT(i int) {
	if m.add_RVT != nil {
		*m.add_RVT += i
	} else {
		m.add_RVT = &i
	}
}

// AddedRVT returns the value that was added to the "RVT" field in this mutation.
func (m *StrategyFactorMutation) AddedRVT() (r int, exists bool) {
	v := m.add_RVT
	if v == nil {
		return
	}
	return *v, true
}

// ResetRVT resets all changes to the "RVT" field.
func (m *StrategyFactorMutation) ResetRVT() {
	m._RVT = nil
	m.add_RVT = nil
}

// SetMinAcceptabe sets the "MinAcceptabe" field.
func (m *StrategyFactorMutation) SetMinAcceptabe(f float64) {
	m._MinAcceptabe = &f
	m.add_MinAcceptabe = nil
}

// MinAcceptabe returns the value of the "MinAcceptabe" field in the mutation.
func (m *StrategyFactorMutation) MinAcceptabe() (r float64, exists bool) {
	v := m._MinAcceptabe
	if v == nil {
		return
	}
	return *v, true
}

// OldMinAcceptabe returns the old "MinAcceptabe" field's value of the StrategyFactor entity.
// If the StrategyFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyFactorMutation) OldMinAcceptabe(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinAcceptabe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinAcceptabe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinAcceptabe: %w", err)
	}
	return oldValue.MinAcceptabe, nil
}

// AddMinAcceptabe adds f to the "MinAcceptabe" field.
func (m *StrategyFactorMutation) AddMinAcceptabe(f float64) {
	if m.add_MinAcceptabe != nil {
		*m.add_MinAcceptabe += f
	} else {
		m.add_MinAcceptabe = &f
	}
}

// AddedMinAcceptabe returns the value that was added to the "MinAcceptabe" field in this mutation.
func (m *StrategyFactorMutation) AddedMinAcceptabe() (r float64, exists bool) {
	v := m.add_MinAcceptabe
	if v == nil {
		return
	}
	return *v, true
}

// ResetMinAcceptabe resets all changes to the "MinAcceptabe" field.
func (m *StrategyFactorMutation) ResetMinAcceptabe() {
	m._MinAcceptabe = nil
	m.add_MinAcceptabe = nil
}

// SetMaxAcceptable sets the "MaxAcceptable" field.
func (m *StrategyFactorMutation) SetMaxAcceptable(f float64) {
	m._MaxAcceptable = &f
	m.add_MaxAcceptable = nil
}

// MaxAcceptable returns the value of the "MaxAcceptable" field in the mutation.
func (m *StrategyFactorMutation) MaxAcceptable() (r float64, exists bool) {
	v := m._MaxAcceptable
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxAcceptable returns the old "MaxAcceptable" field's value of the StrategyFactor entity.
// If the StrategyFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyFactorMutation) OldMaxAcceptable(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxAcceptable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxAcceptable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxAcceptable: %w", err)
	}
	return oldValue.MaxAcceptable, nil
}

// AddMaxAcceptable adds f to the "MaxAcceptable" field.
func (m *StrategyFactorMutation) AddMaxAcceptable(f float64) {
	if m.add_MaxAcceptable != nil {
		*m.add_MaxAcceptable += f
	} else {
		m.add_MaxAcceptable = &f
	}
}

// AddedMaxAcceptable returns the value that was added to the "MaxAcceptable" field in this mutation.
func (m *StrategyFactorMutation) AddedMaxAcceptable() (r float64, exists bool) {
	v := m.add_MaxAcceptable
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxAcceptable resets all changes to the "MaxAcceptable" field.
func (m *StrategyFactorMutation) ResetMaxAcceptable() {
	m._MaxAcceptable = nil
	m.add_MaxAcceptable = nil
}

// SetInverse sets the "Inverse" field.
func (m *StrategyFactorMutation) SetInverse(b bool) {
	m._Inverse = &b
}

// Inverse returns the value of the "Inverse" field in the mutation.
func (m *StrategyFactorMutation) Inverse() (r bool, exists bool) {
	v := m._Inverse
	if v == nil {
		return
	}
	return *v, true
}

// OldInverse returns the old "Inverse" field's value of the StrategyFactor entity.
// If the StrategyFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyFactorMutation) OldInverse(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInverse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInverse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInverse: %w", err)
	}
	return oldValue.Inverse, nil
}

// ResetInverse resets all changes to the "Inverse" field.
func (m *StrategyFactorMutation) ResetInverse() {
	m._Inverse = nil
}

// SetK sets the "K" field.
func (m *StrategyFactorMutation) SetK(f float64) {
	m._K = &f
	m.add_K = nil
}

// K returns the value of the "K" field in the mutation.
func (m *StrategyFactorMutation) K() (r float64, exists bool) {
	v := m._K
	if v == nil {
		return
	}
	return *v, true
}

// OldK returns the old "K" field's value of the StrategyFactor entity.
// If the StrategyFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyFactorMutation) OldK(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldK is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldK requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldK: %w", err)
	}
	return oldValue.K, nil
}

// AddK adds f to the "K" field.
func (m *StrategyFactorMutation) AddK(f float64) {
	if m.add_K != nil {
		*m.add_K += f
	} else {
		m.add_K = &f
	}
}

// AddedK returns the value that was added to the "K" field in this mutation.
func (m *StrategyFactorMutation) AddedK() (r float64, exists bool) {
	v := m.add_K
	if v == nil {
		return
	}
	return *v, true
}

// ResetK resets all changes to the "K" field.
func (m *StrategyFactorMutation) ResetK() {
	m._K = nil
	m.add_K = nil
}

// SetGist sets the "Gist" field.
func (m *StrategyFactorMutation) SetGist(f float64) {
	m._Gist = &f
	m.add_Gist = nil
}

// Gist returns the value of the "Gist" field in the mutation.
func (m *StrategyFactorMutation) Gist() (r float64, exists bool) {
	v := m._Gist
	if v == nil {
		return
	}
	return *v, true
}

// OldGist returns the old "Gist" field's value of the StrategyFactor entity.
// If the StrategyFactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyFactorMutation) OldGist(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGist: %w", err)
	}
	return oldValue.Gist, nil
}

// AddGist adds f to the "Gist" field.
func (m *StrategyFactorMutation) AddGist(f float64) {
	if m.add_Gist != nil {
		*m.add_Gist += f
	} else {
		m.add_Gist = &f
	}
}

// AddedGist returns the value that was added to the "Gist" field in this mutation.
func (m *StrategyFactorMutation) AddedGist() (r float64, exists bool) {
	v := m.add_Gist
	if v == nil {
		return
	}
	return *v, true
}

// ResetGist resets all changes to the "Gist" field.
func (m *StrategyFactorMutation) ResetGist() {
	m._Gist = nil
	m.add_Gist = nil
}

// SetStrategyID sets the "Strategy" edge to the Strategy entity by id.
func (m *StrategyFactorMutation) SetStrategyID(id xid.ID) {
	m._Strategy = &id
}

// ClearStrategy clears the "Strategy" edge to the Strategy entity.
func (m *StrategyFactorMutation) ClearStrategy() {
	m.cleared_Strategy = true
}

// StrategyCleared reports if the "Strategy" edge to the Strategy entity was cleared.
func (m *StrategyFactorMutation) StrategyCleared() bool {
	return m.cleared_Strategy
}

// StrategyID returns the "Strategy" edge ID in the mutation.
func (m *StrategyFactorMutation) StrategyID() (id xid.ID, exists bool) {
	if m._Strategy != nil {
		return *m._Strategy, true
	}
	return
}

// StrategyIDs returns the "Strategy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StrategyID instead. It exists only for internal usage by the builders.
func (m *StrategyFactorMutation) StrategyIDs() (ids []xid.ID) {
	if id := m._Strategy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStrategy resets all changes to the "Strategy" edge.
func (m *StrategyFactorMutation) ResetStrategy() {
	m._Strategy = nil
	m.cleared_Strategy = false
}

// Where appends a list predicates to the StrategyFactorMutation builder.
func (m *StrategyFactorMutation) Where(ps ...predicate.StrategyFactor) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StrategyFactorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (StrategyFactor).
func (m *StrategyFactorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StrategyFactorMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m._LineNum != nil {
		fields = append(fields, strategyfactor.FieldLineNum)
	}
	if m._IsUsed != nil {
		fields = append(fields, strategyfactor.FieldIsUsed)
	}
	if m._RK != nil {
		fields = append(fields, strategyfactor.FieldRK)
	}
	if m._RVT != nil {
		fields = append(fields, strategyfactor.FieldRVT)
	}
	if m._MinAcceptabe != nil {
		fields = append(fields, strategyfactor.FieldMinAcceptabe)
	}
	if m._MaxAcceptable != nil {
		fields = append(fields, strategyfactor.FieldMaxAcceptable)
	}
	if m._Inverse != nil {
		fields = append(fields, strategyfactor.FieldInverse)
	}
	if m._K != nil {
		fields = append(fields, strategyfactor.FieldK)
	}
	if m._Gist != nil {
		fields = append(fields, strategyfactor.FieldGist)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StrategyFactorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case strategyfactor.FieldLineNum:
		return m.LineNum()
	case strategyfactor.FieldIsUsed:
		return m.IsUsed()
	case strategyfactor.FieldRK:
		return m.RK()
	case strategyfactor.FieldRVT:
		return m.RVT()
	case strategyfactor.FieldMinAcceptabe:
		return m.MinAcceptabe()
	case strategyfactor.FieldMaxAcceptable:
		return m.MaxAcceptable()
	case strategyfactor.FieldInverse:
		return m.Inverse()
	case strategyfactor.FieldK:
		return m.K()
	case strategyfactor.FieldGist:
		return m.Gist()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StrategyFactorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case strategyfactor.FieldLineNum:
		return m.OldLineNum(ctx)
	case strategyfactor.FieldIsUsed:
		return m.OldIsUsed(ctx)
	case strategyfactor.FieldRK:
		return m.OldRK(ctx)
	case strategyfactor.FieldRVT:
		return m.OldRVT(ctx)
	case strategyfactor.FieldMinAcceptabe:
		return m.OldMinAcceptabe(ctx)
	case strategyfactor.FieldMaxAcceptable:
		return m.OldMaxAcceptable(ctx)
	case strategyfactor.FieldInverse:
		return m.OldInverse(ctx)
	case strategyfactor.FieldK:
		return m.OldK(ctx)
	case strategyfactor.FieldGist:
		return m.OldGist(ctx)
	}
	return nil, fmt.Errorf("unknown StrategyFactor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyFactorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case strategyfactor.FieldLineNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineNum(v)
		return nil
	case strategyfactor.FieldIsUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsUsed(v)
		return nil
	case strategyfactor.FieldRK:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRK(v)
		return nil
	case strategyfactor.FieldRVT:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRVT(v)
		return nil
	case strategyfactor.FieldMinAcceptabe:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinAcceptabe(v)
		return nil
	case strategyfactor.FieldMaxAcceptable:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxAcceptable(v)
		return nil
	case strategyfactor.FieldInverse:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInverse(v)
		return nil
	case strategyfactor.FieldK:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetK(v)
		return nil
	case strategyfactor.FieldGist:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGist(v)
		return nil
	}
	return fmt.Errorf("unknown StrategyFactor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StrategyFactorMutation) AddedFields() []string {
	var fields []string
	if m.add_LineNum != nil {
		fields = append(fields, strategyfactor.FieldLineNum)
	}
	if m.add_RK != nil {
		fields = append(fields, strategyfactor.FieldRK)
	}
	if m.add_RVT != nil {
		fields = append(fields, strategyfactor.FieldRVT)
	}
	if m.add_MinAcceptabe != nil {
		fields = append(fields, strategyfactor.FieldMinAcceptabe)
	}
	if m.add_MaxAcceptable != nil {
		fields = append(fields, strategyfactor.FieldMaxAcceptable)
	}
	if m.add_K != nil {
		fields = append(fields, strategyfactor.FieldK)
	}
	if m.add_Gist != nil {
		fields = append(fields, strategyfactor.FieldGist)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StrategyFactorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case strategyfactor.FieldLineNum:
		return m.AddedLineNum()
	case strategyfactor.FieldRK:
		return m.AddedRK()
	case strategyfactor.FieldRVT:
		return m.AddedRVT()
	case strategyfactor.FieldMinAcceptabe:
		return m.AddedMinAcceptabe()
	case strategyfactor.FieldMaxAcceptable:
		return m.AddedMaxAcceptable()
	case strategyfactor.FieldK:
		return m.AddedK()
	case strategyfactor.FieldGist:
		return m.AddedGist()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyFactorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case strategyfactor.FieldLineNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLineNum(v)
		return nil
	case strategyfactor.FieldRK:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRK(v)
		return nil
	case strategyfactor.FieldRVT:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRVT(v)
		return nil
	case strategyfactor.FieldMinAcceptabe:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinAcceptabe(v)
		return nil
	case strategyfactor.FieldMaxAcceptable:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxAcceptable(v)
		return nil
	case strategyfactor.FieldK:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddK(v)
		return nil
	case strategyfactor.FieldGist:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGist(v)
		return nil
	}
	return fmt.Errorf("unknown StrategyFactor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StrategyFactorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StrategyFactorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StrategyFactorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StrategyFactor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StrategyFactorMutation) ResetField(name string) error {
	switch name {
	case strategyfactor.FieldLineNum:
		m.ResetLineNum()
		return nil
	case strategyfactor.FieldIsUsed:
		m.ResetIsUsed()
		return nil
	case strategyfactor.FieldRK:
		m.ResetRK()
		return nil
	case strategyfactor.FieldRVT:
		m.ResetRVT()
		return nil
	case strategyfactor.FieldMinAcceptabe:
		m.ResetMinAcceptabe()
		return nil
	case strategyfactor.FieldMaxAcceptable:
		m.ResetMaxAcceptable()
		return nil
	case strategyfactor.FieldInverse:
		m.ResetInverse()
		return nil
	case strategyfactor.FieldK:
		m.ResetK()
		return nil
	case strategyfactor.FieldGist:
		m.ResetGist()
		return nil
	}
	return fmt.Errorf("unknown StrategyFactor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StrategyFactorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Strategy != nil {
		edges = append(edges, strategyfactor.EdgeStrategy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StrategyFactorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case strategyfactor.EdgeStrategy:
		if id := m._Strategy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StrategyFactorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StrategyFactorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StrategyFactorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Strategy {
		edges = append(edges, strategyfactor.EdgeStrategy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StrategyFactorMutation) EdgeCleared(name string) bool {
	switch name {
	case strategyfactor.EdgeStrategy:
		return m.cleared_Strategy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StrategyFactorMutation) ClearEdge(name string) error {
	switch name {
	case strategyfactor.EdgeStrategy:
		m.ClearStrategy()
		return nil
	}
	return fmt.Errorf("unknown StrategyFactor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StrategyFactorMutation) ResetEdge(name string) error {
	switch name {
	case strategyfactor.EdgeStrategy:
		m.ResetStrategy()
		return nil
	}
	return fmt.Errorf("unknown StrategyFactor edge %s", name)
}

// StrategyFilterMutation represents an operation that mutates the StrategyFilter nodes in the graph.
type StrategyFilterMutation struct {
	config
	op                Op
	typ               string
	id                *xid.ID
	_LineNum          *int
	add_LineNum       *int
	_IsUsed           *bool
	_LeftValueKind    *int
	add_LeftValueKind *int
	_LeftValue        *string
	_RVT              *int
	add_RVT           *int
	_Operation        *int
	add_Operation     *int
	_RightValue       *string
	clearedFields     map[string]struct{}
	_Strategy         *xid.ID
	cleared_Strategy  bool
	done              bool
	oldValue          func(context.Context) (*StrategyFilter, error)
	predicates        []predicate.StrategyFilter
}

var _ ent.Mutation = (*StrategyFilterMutation)(nil)

// strategyfilterOption allows management of the mutation configuration using functional options.
type strategyfilterOption func(*StrategyFilterMutation)

// newStrategyFilterMutation creates new mutation for the StrategyFilter entity.
func newStrategyFilterMutation(c config, op Op, opts ...strategyfilterOption) *StrategyFilterMutation {
	m := &StrategyFilterMutation{
		config:        c,
		op:            op,
		typ:           TypeStrategyFilter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStrategyFilterID sets the ID field of the mutation.
func withStrategyFilterID(id xid.ID) strategyfilterOption {
	return func(m *StrategyFilterMutation) {
		var (
			err   error
			once  sync.Once
			value *StrategyFilter
		)
		m.oldValue = func(ctx context.Context) (*StrategyFilter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StrategyFilter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStrategyFilter sets the old StrategyFilter of the mutation.
func withStrategyFilter(node *StrategyFilter) strategyfilterOption {
	return func(m *StrategyFilterMutation) {
		m.oldValue = func(context.Context) (*StrategyFilter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StrategyFilterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StrategyFilterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StrategyFilter entities.
func (m *StrategyFilterMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StrategyFilterMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StrategyFilterMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StrategyFilter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLineNum sets the "LineNum" field.
func (m *StrategyFilterMutation) SetLineNum(i int) {
	m._LineNum = &i
	m.add_LineNum = nil
}

// LineNum returns the value of the "LineNum" field in the mutation.
func (m *StrategyFilterMutation) LineNum() (r int, exists bool) {
	v := m._LineNum
	if v == nil {
		return
	}
	return *v, true
}

// OldLineNum returns the old "LineNum" field's value of the StrategyFilter entity.
// If the StrategyFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyFilterMutation) OldLineNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineNum: %w", err)
	}
	return oldValue.LineNum, nil
}

// AddLineNum adds i to the "LineNum" field.
func (m *StrategyFilterMutation) AddLineNum(i int) {
	if m.add_LineNum != nil {
		*m.add_LineNum += i
	} else {
		m.add_LineNum = &i
	}
}

// AddedLineNum returns the value that was added to the "LineNum" field in this mutation.
func (m *StrategyFilterMutation) AddedLineNum() (r int, exists bool) {
	v := m.add_LineNum
	if v == nil {
		return
	}
	return *v, true
}

// ResetLineNum resets all changes to the "LineNum" field.
func (m *StrategyFilterMutation) ResetLineNum() {
	m._LineNum = nil
	m.add_LineNum = nil
}

// SetIsUsed sets the "IsUsed" field.
func (m *StrategyFilterMutation) SetIsUsed(b bool) {
	m._IsUsed = &b
}

// IsUsed returns the value of the "IsUsed" field in the mutation.
func (m *StrategyFilterMutation) IsUsed() (r bool, exists bool) {
	v := m._IsUsed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsUsed returns the old "IsUsed" field's value of the StrategyFilter entity.
// If the StrategyFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyFilterMutation) OldIsUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsUsed: %w", err)
	}
	return oldValue.IsUsed, nil
}

// ResetIsUsed resets all changes to the "IsUsed" field.
func (m *StrategyFilterMutation) ResetIsUsed() {
	m._IsUsed = nil
}

// SetLeftValueKind sets the "LeftValueKind" field.
func (m *StrategyFilterMutation) SetLeftValueKind(i int) {
	m._LeftValueKind = &i
	m.add_LeftValueKind = nil
}

// LeftValueKind returns the value of the "LeftValueKind" field in the mutation.
func (m *StrategyFilterMutation) LeftValueKind() (r int, exists bool) {
	v := m._LeftValueKind
	if v == nil {
		return
	}
	return *v, true
}

// OldLeftValueKind returns the old "LeftValueKind" field's value of the StrategyFilter entity.
// If the StrategyFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyFilterMutation) OldLeftValueKind(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeftValueKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeftValueKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeftValueKind: %w", err)
	}
	return oldValue.LeftValueKind, nil
}

// AddLeftValueKind adds i to the "LeftValueKind" field.
func (m *StrategyFilterMutation) AddLeftValueKind(i int) {
	if m.add_LeftValueKind != nil {
		*m.add_LeftValueKind += i
	} else {
		m.add_LeftValueKind = &i
	}
}

// AddedLeftValueKind returns the value that was added to the "LeftValueKind" field in this mutation.
func (m *StrategyFilterMutation) AddedLeftValueKind() (r int, exists bool) {
	v := m.add_LeftValueKind
	if v == nil {
		return
	}
	return *v, true
}

// ResetLeftValueKind resets all changes to the "LeftValueKind" field.
func (m *StrategyFilterMutation) ResetLeftValueKind() {
	m._LeftValueKind = nil
	m.add_LeftValueKind = nil
}

// SetLeftValue sets the "LeftValue" field.
func (m *StrategyFilterMutation) SetLeftValue(s string) {
	m._LeftValue = &s
}

// LeftValue returns the value of the "LeftValue" field in the mutation.
func (m *StrategyFilterMutation) LeftValue() (r string, exists bool) {
	v := m._LeftValue
	if v == nil {
		return
	}
	return *v, true
}

// OldLeftValue returns the old "LeftValue" field's value of the StrategyFilter entity.
// If the StrategyFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyFilterMutation) OldLeftValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeftValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeftValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeftValue: %w", err)
	}
	return oldValue.LeftValue, nil
}

// ResetLeftValue resets all changes to the "LeftValue" field.
func (m *StrategyFilterMutation) ResetLeftValue() {
	m._LeftValue = nil
}

// SetRVT sets the "RVT" field.
func (m *StrategyFilterMutation) SetRVT(i int) {
	m._RVT = &i
	m.add_RVT = nil
}

// RVT returns the value of the "RVT" field in the mutation.
func (m *StrategyFilterMutation) RVT() (r int, exists bool) {
	v := m._RVT
	if v == nil {
		return
	}
	return *v, true
}

// OldRVT returns the old "RVT" field's value of the StrategyFilter entity.
// If the StrategyFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyFilterMutation) OldRVT(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRVT is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRVT requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRVT: %w", err)
	}
	return oldValue.RVT, nil
}

// AddRVT adds i to the "RVT" field.
func (m *StrategyFilterMutation) AddRVT(i int) {
	if m.add_RVT != nil {
		*m.add_RVT += i
	} else {
		m.add_RVT = &i
	}
}

// AddedRVT returns the value that was added to the "RVT" field in this mutation.
func (m *StrategyFilterMutation) AddedRVT() (r int, exists bool) {
	v := m.add_RVT
	if v == nil {
		return
	}
	return *v, true
}

// ResetRVT resets all changes to the "RVT" field.
func (m *StrategyFilterMutation) ResetRVT() {
	m._RVT = nil
	m.add_RVT = nil
}

// SetOperation sets the "Operation" field.
func (m *StrategyFilterMutation) SetOperation(i int) {
	m._Operation = &i
	m.add_Operation = nil
}

// Operation returns the value of the "Operation" field in the mutation.
func (m *StrategyFilterMutation) Operation() (r int, exists bool) {
	v := m._Operation
	if v == nil {
		return
	}
	return *v, true
}

// OldOperation returns the old "Operation" field's value of the StrategyFilter entity.
// If the StrategyFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyFilterMutation) OldOperation(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOperation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOperation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperation: %w", err)
	}
	return oldValue.Operation, nil
}

// AddOperation adds i to the "Operation" field.
func (m *StrategyFilterMutation) AddOperation(i int) {
	if m.add_Operation != nil {
		*m.add_Operation += i
	} else {
		m.add_Operation = &i
	}
}

// AddedOperation returns the value that was added to the "Operation" field in this mutation.
func (m *StrategyFilterMutation) AddedOperation() (r int, exists bool) {
	v := m.add_Operation
	if v == nil {
		return
	}
	return *v, true
}

// ResetOperation resets all changes to the "Operation" field.
func (m *StrategyFilterMutation) ResetOperation() {
	m._Operation = nil
	m.add_Operation = nil
}

// SetRightValue sets the "RightValue" field.
func (m *StrategyFilterMutation) SetRightValue(s string) {
	m._RightValue = &s
}

// RightValue returns the value of the "RightValue" field in the mutation.
func (m *StrategyFilterMutation) RightValue() (r string, exists bool) {
	v := m._RightValue
	if v == nil {
		return
	}
	return *v, true
}

// OldRightValue returns the old "RightValue" field's value of the StrategyFilter entity.
// If the StrategyFilter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyFilterMutation) OldRightValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRightValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRightValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRightValue: %w", err)
	}
	return oldValue.RightValue, nil
}

// ResetRightValue resets all changes to the "RightValue" field.
func (m *StrategyFilterMutation) ResetRightValue() {
	m._RightValue = nil
}

// SetStrategyID sets the "Strategy" edge to the Strategy entity by id.
func (m *StrategyFilterMutation) SetStrategyID(id xid.ID) {
	m._Strategy = &id
}

// ClearStrategy clears the "Strategy" edge to the Strategy entity.
func (m *StrategyFilterMutation) ClearStrategy() {
	m.cleared_Strategy = true
}

// StrategyCleared reports if the "Strategy" edge to the Strategy entity was cleared.
func (m *StrategyFilterMutation) StrategyCleared() bool {
	return m.cleared_Strategy
}

// StrategyID returns the "Strategy" edge ID in the mutation.
func (m *StrategyFilterMutation) StrategyID() (id xid.ID, exists bool) {
	if m._Strategy != nil {
		return *m._Strategy, true
	}
	return
}

// StrategyIDs returns the "Strategy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StrategyID instead. It exists only for internal usage by the builders.
func (m *StrategyFilterMutation) StrategyIDs() (ids []xid.ID) {
	if id := m._Strategy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStrategy resets all changes to the "Strategy" edge.
func (m *StrategyFilterMutation) ResetStrategy() {
	m._Strategy = nil
	m.cleared_Strategy = false
}

// Where appends a list predicates to the StrategyFilterMutation builder.
func (m *StrategyFilterMutation) Where(ps ...predicate.StrategyFilter) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StrategyFilterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (StrategyFilter).
func (m *StrategyFilterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StrategyFilterMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._LineNum != nil {
		fields = append(fields, strategyfilter.FieldLineNum)
	}
	if m._IsUsed != nil {
		fields = append(fields, strategyfilter.FieldIsUsed)
	}
	if m._LeftValueKind != nil {
		fields = append(fields, strategyfilter.FieldLeftValueKind)
	}
	if m._LeftValue != nil {
		fields = append(fields, strategyfilter.FieldLeftValue)
	}
	if m._RVT != nil {
		fields = append(fields, strategyfilter.FieldRVT)
	}
	if m._Operation != nil {
		fields = append(fields, strategyfilter.FieldOperation)
	}
	if m._RightValue != nil {
		fields = append(fields, strategyfilter.FieldRightValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StrategyFilterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case strategyfilter.FieldLineNum:
		return m.LineNum()
	case strategyfilter.FieldIsUsed:
		return m.IsUsed()
	case strategyfilter.FieldLeftValueKind:
		return m.LeftValueKind()
	case strategyfilter.FieldLeftValue:
		return m.LeftValue()
	case strategyfilter.FieldRVT:
		return m.RVT()
	case strategyfilter.FieldOperation:
		return m.Operation()
	case strategyfilter.FieldRightValue:
		return m.RightValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StrategyFilterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case strategyfilter.FieldLineNum:
		return m.OldLineNum(ctx)
	case strategyfilter.FieldIsUsed:
		return m.OldIsUsed(ctx)
	case strategyfilter.FieldLeftValueKind:
		return m.OldLeftValueKind(ctx)
	case strategyfilter.FieldLeftValue:
		return m.OldLeftValue(ctx)
	case strategyfilter.FieldRVT:
		return m.OldRVT(ctx)
	case strategyfilter.FieldOperation:
		return m.OldOperation(ctx)
	case strategyfilter.FieldRightValue:
		return m.OldRightValue(ctx)
	}
	return nil, fmt.Errorf("unknown StrategyFilter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyFilterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case strategyfilter.FieldLineNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineNum(v)
		return nil
	case strategyfilter.FieldIsUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsUsed(v)
		return nil
	case strategyfilter.FieldLeftValueKind:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeftValueKind(v)
		return nil
	case strategyfilter.FieldLeftValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeftValue(v)
		return nil
	case strategyfilter.FieldRVT:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRVT(v)
		return nil
	case strategyfilter.FieldOperation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperation(v)
		return nil
	case strategyfilter.FieldRightValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRightValue(v)
		return nil
	}
	return fmt.Errorf("unknown StrategyFilter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StrategyFilterMutation) AddedFields() []string {
	var fields []string
	if m.add_LineNum != nil {
		fields = append(fields, strategyfilter.FieldLineNum)
	}
	if m.add_LeftValueKind != nil {
		fields = append(fields, strategyfilter.FieldLeftValueKind)
	}
	if m.add_RVT != nil {
		fields = append(fields, strategyfilter.FieldRVT)
	}
	if m.add_Operation != nil {
		fields = append(fields, strategyfilter.FieldOperation)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StrategyFilterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case strategyfilter.FieldLineNum:
		return m.AddedLineNum()
	case strategyfilter.FieldLeftValueKind:
		return m.AddedLeftValueKind()
	case strategyfilter.FieldRVT:
		return m.AddedRVT()
	case strategyfilter.FieldOperation:
		return m.AddedOperation()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyFilterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case strategyfilter.FieldLineNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLineNum(v)
		return nil
	case strategyfilter.FieldLeftValueKind:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLeftValueKind(v)
		return nil
	case strategyfilter.FieldRVT:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRVT(v)
		return nil
	case strategyfilter.FieldOperation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOperation(v)
		return nil
	}
	return fmt.Errorf("unknown StrategyFilter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StrategyFilterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StrategyFilterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StrategyFilterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StrategyFilter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StrategyFilterMutation) ResetField(name string) error {
	switch name {
	case strategyfilter.FieldLineNum:
		m.ResetLineNum()
		return nil
	case strategyfilter.FieldIsUsed:
		m.ResetIsUsed()
		return nil
	case strategyfilter.FieldLeftValueKind:
		m.ResetLeftValueKind()
		return nil
	case strategyfilter.FieldLeftValue:
		m.ResetLeftValue()
		return nil
	case strategyfilter.FieldRVT:
		m.ResetRVT()
		return nil
	case strategyfilter.FieldOperation:
		m.ResetOperation()
		return nil
	case strategyfilter.FieldRightValue:
		m.ResetRightValue()
		return nil
	}
	return fmt.Errorf("unknown StrategyFilter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StrategyFilterMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Strategy != nil {
		edges = append(edges, strategyfilter.EdgeStrategy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StrategyFilterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case strategyfilter.EdgeStrategy:
		if id := m._Strategy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StrategyFilterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StrategyFilterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StrategyFilterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Strategy {
		edges = append(edges, strategyfilter.EdgeStrategy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StrategyFilterMutation) EdgeCleared(name string) bool {
	switch name {
	case strategyfilter.EdgeStrategy:
		return m.cleared_Strategy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StrategyFilterMutation) ClearEdge(name string) error {
	switch name {
	case strategyfilter.EdgeStrategy:
		m.ClearStrategy()
		return nil
	}
	return fmt.Errorf("unknown StrategyFilter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StrategyFilterMutation) ResetEdge(name string) error {
	switch name {
	case strategyfilter.EdgeStrategy:
		m.ResetStrategy()
		return nil
	}
	return fmt.Errorf("unknown StrategyFilter edge %s", name)
}

// StrategyFixedTickerMutation represents an operation that mutates the StrategyFixedTicker nodes in the graph.
type StrategyFixedTickerMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	_LineNum         *int
	add_LineNum      *int
	_IsUsed          *bool
	clearedFields    map[string]struct{}
	_Strategy        *xid.ID
	cleared_Strategy bool
	done             bool
	oldValue         func(context.Context) (*StrategyFixedTicker, error)
	predicates       []predicate.StrategyFixedTicker
}

var _ ent.Mutation = (*StrategyFixedTickerMutation)(nil)

// strategyfixedtickerOption allows management of the mutation configuration using functional options.
type strategyfixedtickerOption func(*StrategyFixedTickerMutation)

// newStrategyFixedTickerMutation creates new mutation for the StrategyFixedTicker entity.
func newStrategyFixedTickerMutation(c config, op Op, opts ...strategyfixedtickerOption) *StrategyFixedTickerMutation {
	m := &StrategyFixedTickerMutation{
		config:        c,
		op:            op,
		typ:           TypeStrategyFixedTicker,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStrategyFixedTickerID sets the ID field of the mutation.
func withStrategyFixedTickerID(id xid.ID) strategyfixedtickerOption {
	return func(m *StrategyFixedTickerMutation) {
		var (
			err   error
			once  sync.Once
			value *StrategyFixedTicker
		)
		m.oldValue = func(ctx context.Context) (*StrategyFixedTicker, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StrategyFixedTicker.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStrategyFixedTicker sets the old StrategyFixedTicker of the mutation.
func withStrategyFixedTicker(node *StrategyFixedTicker) strategyfixedtickerOption {
	return func(m *StrategyFixedTickerMutation) {
		m.oldValue = func(context.Context) (*StrategyFixedTicker, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StrategyFixedTickerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StrategyFixedTickerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StrategyFixedTicker entities.
func (m *StrategyFixedTickerMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StrategyFixedTickerMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StrategyFixedTickerMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StrategyFixedTicker.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLineNum sets the "LineNum" field.
func (m *StrategyFixedTickerMutation) SetLineNum(i int) {
	m._LineNum = &i
	m.add_LineNum = nil
}

// LineNum returns the value of the "LineNum" field in the mutation.
func (m *StrategyFixedTickerMutation) LineNum() (r int, exists bool) {
	v := m._LineNum
	if v == nil {
		return
	}
	return *v, true
}

// OldLineNum returns the old "LineNum" field's value of the StrategyFixedTicker entity.
// If the StrategyFixedTicker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyFixedTickerMutation) OldLineNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLineNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLineNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLineNum: %w", err)
	}
	return oldValue.LineNum, nil
}

// AddLineNum adds i to the "LineNum" field.
func (m *StrategyFixedTickerMutation) AddLineNum(i int) {
	if m.add_LineNum != nil {
		*m.add_LineNum += i
	} else {
		m.add_LineNum = &i
	}
}

// AddedLineNum returns the value that was added to the "LineNum" field in this mutation.
func (m *StrategyFixedTickerMutation) AddedLineNum() (r int, exists bool) {
	v := m.add_LineNum
	if v == nil {
		return
	}
	return *v, true
}

// ResetLineNum resets all changes to the "LineNum" field.
func (m *StrategyFixedTickerMutation) ResetLineNum() {
	m._LineNum = nil
	m.add_LineNum = nil
}

// SetIsUsed sets the "IsUsed" field.
func (m *StrategyFixedTickerMutation) SetIsUsed(b bool) {
	m._IsUsed = &b
}

// IsUsed returns the value of the "IsUsed" field in the mutation.
func (m *StrategyFixedTickerMutation) IsUsed() (r bool, exists bool) {
	v := m._IsUsed
	if v == nil {
		return
	}
	return *v, true
}

// OldIsUsed returns the old "IsUsed" field's value of the StrategyFixedTicker entity.
// If the StrategyFixedTicker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StrategyFixedTickerMutation) OldIsUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsUsed: %w", err)
	}
	return oldValue.IsUsed, nil
}

// ResetIsUsed resets all changes to the "IsUsed" field.
func (m *StrategyFixedTickerMutation) ResetIsUsed() {
	m._IsUsed = nil
}

// SetStrategyID sets the "Strategy" edge to the Strategy entity by id.
func (m *StrategyFixedTickerMutation) SetStrategyID(id xid.ID) {
	m._Strategy = &id
}

// ClearStrategy clears the "Strategy" edge to the Strategy entity.
func (m *StrategyFixedTickerMutation) ClearStrategy() {
	m.cleared_Strategy = true
}

// StrategyCleared reports if the "Strategy" edge to the Strategy entity was cleared.
func (m *StrategyFixedTickerMutation) StrategyCleared() bool {
	return m.cleared_Strategy
}

// StrategyID returns the "Strategy" edge ID in the mutation.
func (m *StrategyFixedTickerMutation) StrategyID() (id xid.ID, exists bool) {
	if m._Strategy != nil {
		return *m._Strategy, true
	}
	return
}

// StrategyIDs returns the "Strategy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StrategyID instead. It exists only for internal usage by the builders.
func (m *StrategyFixedTickerMutation) StrategyIDs() (ids []xid.ID) {
	if id := m._Strategy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStrategy resets all changes to the "Strategy" edge.
func (m *StrategyFixedTickerMutation) ResetStrategy() {
	m._Strategy = nil
	m.cleared_Strategy = false
}

// Where appends a list predicates to the StrategyFixedTickerMutation builder.
func (m *StrategyFixedTickerMutation) Where(ps ...predicate.StrategyFixedTicker) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StrategyFixedTickerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (StrategyFixedTicker).
func (m *StrategyFixedTickerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StrategyFixedTickerMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._LineNum != nil {
		fields = append(fields, strategyfixedticker.FieldLineNum)
	}
	if m._IsUsed != nil {
		fields = append(fields, strategyfixedticker.FieldIsUsed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StrategyFixedTickerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case strategyfixedticker.FieldLineNum:
		return m.LineNum()
	case strategyfixedticker.FieldIsUsed:
		return m.IsUsed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StrategyFixedTickerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case strategyfixedticker.FieldLineNum:
		return m.OldLineNum(ctx)
	case strategyfixedticker.FieldIsUsed:
		return m.OldIsUsed(ctx)
	}
	return nil, fmt.Errorf("unknown StrategyFixedTicker field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyFixedTickerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case strategyfixedticker.FieldLineNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLineNum(v)
		return nil
	case strategyfixedticker.FieldIsUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsUsed(v)
		return nil
	}
	return fmt.Errorf("unknown StrategyFixedTicker field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StrategyFixedTickerMutation) AddedFields() []string {
	var fields []string
	if m.add_LineNum != nil {
		fields = append(fields, strategyfixedticker.FieldLineNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StrategyFixedTickerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case strategyfixedticker.FieldLineNum:
		return m.AddedLineNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StrategyFixedTickerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case strategyfixedticker.FieldLineNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLineNum(v)
		return nil
	}
	return fmt.Errorf("unknown StrategyFixedTicker numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StrategyFixedTickerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StrategyFixedTickerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StrategyFixedTickerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StrategyFixedTicker nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StrategyFixedTickerMutation) ResetField(name string) error {
	switch name {
	case strategyfixedticker.FieldLineNum:
		m.ResetLineNum()
		return nil
	case strategyfixedticker.FieldIsUsed:
		m.ResetIsUsed()
		return nil
	}
	return fmt.Errorf("unknown StrategyFixedTicker field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StrategyFixedTickerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Strategy != nil {
		edges = append(edges, strategyfixedticker.EdgeStrategy)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StrategyFixedTickerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case strategyfixedticker.EdgeStrategy:
		if id := m._Strategy; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StrategyFixedTickerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StrategyFixedTickerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StrategyFixedTickerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Strategy {
		edges = append(edges, strategyfixedticker.EdgeStrategy)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StrategyFixedTickerMutation) EdgeCleared(name string) bool {
	switch name {
	case strategyfixedticker.EdgeStrategy:
		return m.cleared_Strategy
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StrategyFixedTickerMutation) ClearEdge(name string) error {
	switch name {
	case strategyfixedticker.EdgeStrategy:
		m.ClearStrategy()
		return nil
	}
	return fmt.Errorf("unknown StrategyFixedTicker unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StrategyFixedTickerMutation) ResetEdge(name string) error {
	switch name {
	case strategyfixedticker.EdgeStrategy:
		m.ResetStrategy()
		return nil
	}
	return fmt.Errorf("unknown StrategyFixedTicker edge %s", name)
}

// TickerMutation represents an operation that mutates the Ticker nodes in the graph.
type TickerMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	_Descr             *string
	_Kind              *int32
	add_Kind           *int32
	clearedFields      map[string]struct{}
	_Emitent           *xid.ID
	cleared_Emitent    bool
	_Quotes            map[xid.ID]struct{}
	removed_Quotes     map[xid.ID]struct{}
	cleared_Quotes     bool
	_DivPayouts        map[int]struct{}
	removed_DivPayouts map[int]struct{}
	cleared_DivPayouts bool
	_Emissions         map[xid.ID]struct{}
	removed_Emissions  map[xid.ID]struct{}
	cleared_Emissions  bool
	done               bool
	oldValue           func(context.Context) (*Ticker, error)
	predicates         []predicate.Ticker
}

var _ ent.Mutation = (*TickerMutation)(nil)

// tickerOption allows management of the mutation configuration using functional options.
type tickerOption func(*TickerMutation)

// newTickerMutation creates new mutation for the Ticker entity.
func newTickerMutation(c config, op Op, opts ...tickerOption) *TickerMutation {
	m := &TickerMutation{
		config:        c,
		op:            op,
		typ:           TypeTicker,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTickerID sets the ID field of the mutation.
func withTickerID(id string) tickerOption {
	return func(m *TickerMutation) {
		var (
			err   error
			once  sync.Once
			value *Ticker
		)
		m.oldValue = func(ctx context.Context) (*Ticker, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ticker.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicker sets the old Ticker of the mutation.
func withTicker(node *Ticker) tickerOption {
	return func(m *TickerMutation) {
		m.oldValue = func(context.Context) (*Ticker, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TickerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TickerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ticker entities.
func (m *TickerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TickerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TickerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ticker.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescr sets the "Descr" field.
func (m *TickerMutation) SetDescr(s string) {
	m._Descr = &s
}

// Descr returns the value of the "Descr" field in the mutation.
func (m *TickerMutation) Descr() (r string, exists bool) {
	v := m._Descr
	if v == nil {
		return
	}
	return *v, true
}

// OldDescr returns the old "Descr" field's value of the Ticker entity.
// If the Ticker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TickerMutation) OldDescr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescr: %w", err)
	}
	return oldValue.Descr, nil
}

// ResetDescr resets all changes to the "Descr" field.
func (m *TickerMutation) ResetDescr() {
	m._Descr = nil
}

// SetKind sets the "Kind" field.
func (m *TickerMutation) SetKind(i int32) {
	m._Kind = &i
	m.add_Kind = nil
}

// Kind returns the value of the "Kind" field in the mutation.
func (m *TickerMutation) Kind() (r int32, exists bool) {
	v := m._Kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "Kind" field's value of the Ticker entity.
// If the Ticker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TickerMutation) OldKind(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// AddKind adds i to the "Kind" field.
func (m *TickerMutation) AddKind(i int32) {
	if m.add_Kind != nil {
		*m.add_Kind += i
	} else {
		m.add_Kind = &i
	}
}

// AddedKind returns the value that was added to the "Kind" field in this mutation.
func (m *TickerMutation) AddedKind() (r int32, exists bool) {
	v := m.add_Kind
	if v == nil {
		return
	}
	return *v, true
}

// ResetKind resets all changes to the "Kind" field.
func (m *TickerMutation) ResetKind() {
	m._Kind = nil
	m.add_Kind = nil
}

// SetEmitentID sets the "Emitent" edge to the Emitent entity by id.
func (m *TickerMutation) SetEmitentID(id xid.ID) {
	m._Emitent = &id
}

// ClearEmitent clears the "Emitent" edge to the Emitent entity.
func (m *TickerMutation) ClearEmitent() {
	m.cleared_Emitent = true
}

// EmitentCleared reports if the "Emitent" edge to the Emitent entity was cleared.
func (m *TickerMutation) EmitentCleared() bool {
	return m.cleared_Emitent
}

// EmitentID returns the "Emitent" edge ID in the mutation.
func (m *TickerMutation) EmitentID() (id xid.ID, exists bool) {
	if m._Emitent != nil {
		return *m._Emitent, true
	}
	return
}

// EmitentIDs returns the "Emitent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmitentID instead. It exists only for internal usage by the builders.
func (m *TickerMutation) EmitentIDs() (ids []xid.ID) {
	if id := m._Emitent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmitent resets all changes to the "Emitent" edge.
func (m *TickerMutation) ResetEmitent() {
	m._Emitent = nil
	m.cleared_Emitent = false
}

// AddQuoteIDs adds the "Quotes" edge to the Quote entity by ids.
func (m *TickerMutation) AddQuoteIDs(ids ...xid.ID) {
	if m._Quotes == nil {
		m._Quotes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m._Quotes[ids[i]] = struct{}{}
	}
}

// ClearQuotes clears the "Quotes" edge to the Quote entity.
func (m *TickerMutation) ClearQuotes() {
	m.cleared_Quotes = true
}

// QuotesCleared reports if the "Quotes" edge to the Quote entity was cleared.
func (m *TickerMutation) QuotesCleared() bool {
	return m.cleared_Quotes
}

// RemoveQuoteIDs removes the "Quotes" edge to the Quote entity by IDs.
func (m *TickerMutation) RemoveQuoteIDs(ids ...xid.ID) {
	if m.removed_Quotes == nil {
		m.removed_Quotes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m._Quotes, ids[i])
		m.removed_Quotes[ids[i]] = struct{}{}
	}
}

// RemovedQuotes returns the removed IDs of the "Quotes" edge to the Quote entity.
func (m *TickerMutation) RemovedQuotesIDs() (ids []xid.ID) {
	for id := range m.removed_Quotes {
		ids = append(ids, id)
	}
	return
}

// QuotesIDs returns the "Quotes" edge IDs in the mutation.
func (m *TickerMutation) QuotesIDs() (ids []xid.ID) {
	for id := range m._Quotes {
		ids = append(ids, id)
	}
	return
}

// ResetQuotes resets all changes to the "Quotes" edge.
func (m *TickerMutation) ResetQuotes() {
	m._Quotes = nil
	m.cleared_Quotes = false
	m.removed_Quotes = nil
}

// AddDivPayoutIDs adds the "DivPayouts" edge to the DivPayout entity by ids.
func (m *TickerMutation) AddDivPayoutIDs(ids ...int) {
	if m._DivPayouts == nil {
		m._DivPayouts = make(map[int]struct{})
	}
	for i := range ids {
		m._DivPayouts[ids[i]] = struct{}{}
	}
}

// ClearDivPayouts clears the "DivPayouts" edge to the DivPayout entity.
func (m *TickerMutation) ClearDivPayouts() {
	m.cleared_DivPayouts = true
}

// DivPayoutsCleared reports if the "DivPayouts" edge to the DivPayout entity was cleared.
func (m *TickerMutation) DivPayoutsCleared() bool {
	return m.cleared_DivPayouts
}

// RemoveDivPayoutIDs removes the "DivPayouts" edge to the DivPayout entity by IDs.
func (m *TickerMutation) RemoveDivPayoutIDs(ids ...int) {
	if m.removed_DivPayouts == nil {
		m.removed_DivPayouts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._DivPayouts, ids[i])
		m.removed_DivPayouts[ids[i]] = struct{}{}
	}
}

// RemovedDivPayouts returns the removed IDs of the "DivPayouts" edge to the DivPayout entity.
func (m *TickerMutation) RemovedDivPayoutsIDs() (ids []int) {
	for id := range m.removed_DivPayouts {
		ids = append(ids, id)
	}
	return
}

// DivPayoutsIDs returns the "DivPayouts" edge IDs in the mutation.
func (m *TickerMutation) DivPayoutsIDs() (ids []int) {
	for id := range m._DivPayouts {
		ids = append(ids, id)
	}
	return
}

// ResetDivPayouts resets all changes to the "DivPayouts" edge.
func (m *TickerMutation) ResetDivPayouts() {
	m._DivPayouts = nil
	m.cleared_DivPayouts = false
	m.removed_DivPayouts = nil
}

// AddEmissionIDs adds the "Emissions" edge to the Emission entity by ids.
func (m *TickerMutation) AddEmissionIDs(ids ...xid.ID) {
	if m._Emissions == nil {
		m._Emissions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m._Emissions[ids[i]] = struct{}{}
	}
}

// ClearEmissions clears the "Emissions" edge to the Emission entity.
func (m *TickerMutation) ClearEmissions() {
	m.cleared_Emissions = true
}

// EmissionsCleared reports if the "Emissions" edge to the Emission entity was cleared.
func (m *TickerMutation) EmissionsCleared() bool {
	return m.cleared_Emissions
}

// RemoveEmissionIDs removes the "Emissions" edge to the Emission entity by IDs.
func (m *TickerMutation) RemoveEmissionIDs(ids ...xid.ID) {
	if m.removed_Emissions == nil {
		m.removed_Emissions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m._Emissions, ids[i])
		m.removed_Emissions[ids[i]] = struct{}{}
	}
}

// RemovedEmissions returns the removed IDs of the "Emissions" edge to the Emission entity.
func (m *TickerMutation) RemovedEmissionsIDs() (ids []xid.ID) {
	for id := range m.removed_Emissions {
		ids = append(ids, id)
	}
	return
}

// EmissionsIDs returns the "Emissions" edge IDs in the mutation.
func (m *TickerMutation) EmissionsIDs() (ids []xid.ID) {
	for id := range m._Emissions {
		ids = append(ids, id)
	}
	return
}

// ResetEmissions resets all changes to the "Emissions" edge.
func (m *TickerMutation) ResetEmissions() {
	m._Emissions = nil
	m.cleared_Emissions = false
	m.removed_Emissions = nil
}

// Where appends a list predicates to the TickerMutation builder.
func (m *TickerMutation) Where(ps ...predicate.Ticker) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TickerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Ticker).
func (m *TickerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TickerMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Descr != nil {
		fields = append(fields, ticker.FieldDescr)
	}
	if m._Kind != nil {
		fields = append(fields, ticker.FieldKind)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TickerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticker.FieldDescr:
		return m.Descr()
	case ticker.FieldKind:
		return m.Kind()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TickerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticker.FieldDescr:
		return m.OldDescr(ctx)
	case ticker.FieldKind:
		return m.OldKind(ctx)
	}
	return nil, fmt.Errorf("unknown Ticker field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TickerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticker.FieldDescr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescr(v)
		return nil
	case ticker.FieldKind:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	}
	return fmt.Errorf("unknown Ticker field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TickerMutation) AddedFields() []string {
	var fields []string
	if m.add_Kind != nil {
		fields = append(fields, ticker.FieldKind)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TickerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ticker.FieldKind:
		return m.AddedKind()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TickerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ticker.FieldKind:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKind(v)
		return nil
	}
	return fmt.Errorf("unknown Ticker numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TickerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TickerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TickerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Ticker nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TickerMutation) ResetField(name string) error {
	switch name {
	case ticker.FieldDescr:
		m.ResetDescr()
		return nil
	case ticker.FieldKind:
		m.ResetKind()
		return nil
	}
	return fmt.Errorf("unknown Ticker field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TickerMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._Emitent != nil {
		edges = append(edges, ticker.EdgeEmitent)
	}
	if m._Quotes != nil {
		edges = append(edges, ticker.EdgeQuotes)
	}
	if m._DivPayouts != nil {
		edges = append(edges, ticker.EdgeDivPayouts)
	}
	if m._Emissions != nil {
		edges = append(edges, ticker.EdgeEmissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TickerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ticker.EdgeEmitent:
		if id := m._Emitent; id != nil {
			return []ent.Value{*id}
		}
	case ticker.EdgeQuotes:
		ids := make([]ent.Value, 0, len(m._Quotes))
		for id := range m._Quotes {
			ids = append(ids, id)
		}
		return ids
	case ticker.EdgeDivPayouts:
		ids := make([]ent.Value, 0, len(m._DivPayouts))
		for id := range m._DivPayouts {
			ids = append(ids, id)
		}
		return ids
	case ticker.EdgeEmissions:
		ids := make([]ent.Value, 0, len(m._Emissions))
		for id := range m._Emissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TickerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_Quotes != nil {
		edges = append(edges, ticker.EdgeQuotes)
	}
	if m.removed_DivPayouts != nil {
		edges = append(edges, ticker.EdgeDivPayouts)
	}
	if m.removed_Emissions != nil {
		edges = append(edges, ticker.EdgeEmissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TickerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ticker.EdgeQuotes:
		ids := make([]ent.Value, 0, len(m.removed_Quotes))
		for id := range m.removed_Quotes {
			ids = append(ids, id)
		}
		return ids
	case ticker.EdgeDivPayouts:
		ids := make([]ent.Value, 0, len(m.removed_DivPayouts))
		for id := range m.removed_DivPayouts {
			ids = append(ids, id)
		}
		return ids
	case ticker.EdgeEmissions:
		ids := make([]ent.Value, 0, len(m.removed_Emissions))
		for id := range m.removed_Emissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TickerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_Emitent {
		edges = append(edges, ticker.EdgeEmitent)
	}
	if m.cleared_Quotes {
		edges = append(edges, ticker.EdgeQuotes)
	}
	if m.cleared_DivPayouts {
		edges = append(edges, ticker.EdgeDivPayouts)
	}
	if m.cleared_Emissions {
		edges = append(edges, ticker.EdgeEmissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TickerMutation) EdgeCleared(name string) bool {
	switch name {
	case ticker.EdgeEmitent:
		return m.cleared_Emitent
	case ticker.EdgeQuotes:
		return m.cleared_Quotes
	case ticker.EdgeDivPayouts:
		return m.cleared_DivPayouts
	case ticker.EdgeEmissions:
		return m.cleared_Emissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TickerMutation) ClearEdge(name string) error {
	switch name {
	case ticker.EdgeEmitent:
		m.ClearEmitent()
		return nil
	}
	return fmt.Errorf("unknown Ticker unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TickerMutation) ResetEdge(name string) error {
	switch name {
	case ticker.EdgeEmitent:
		m.ResetEmitent()
		return nil
	case ticker.EdgeQuotes:
		m.ResetQuotes()
		return nil
	case ticker.EdgeDivPayouts:
		m.ResetDivPayouts()
		return nil
	case ticker.EdgeEmissions:
		m.ResetEmissions()
		return nil
	}
	return fmt.Errorf("unknown Ticker edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                           Op
	typ                          string
	id                           *xid.ID
	_UserName                    *string
	_PasswordHash                *string
	_Admin                       *bool
	_StartInvestAccountsFlow     *time.Time
	_HowManyTickersOnHomepage    *int
	add_HowManyTickersOnHomepage *int
	clearedFields                map[string]struct{}
	_InvestAccounts              map[xid.ID]struct{}
	removed_InvestAccounts       map[xid.ID]struct{}
	cleared_InvestAccounts       bool
	_Strategies                  map[xid.ID]struct{}
	removed_Strategies           map[xid.ID]struct{}
	cleared_Strategies           bool
	done                         bool
	oldValue                     func(context.Context) (*User, error)
	predicates                   []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id xid.ID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserName sets the "UserName" field.
func (m *UserMutation) SetUserName(s string) {
	m._UserName = &s
}

// UserName returns the value of the "UserName" field in the mutation.
func (m *UserMutation) UserName() (r string, exists bool) {
	v := m._UserName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "UserName" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName resets all changes to the "UserName" field.
func (m *UserMutation) ResetUserName() {
	m._UserName = nil
}

// SetPasswordHash sets the "PasswordHash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m._PasswordHash = &s
}

// PasswordHash returns the value of the "PasswordHash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m._PasswordHash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "PasswordHash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "PasswordHash" field.
func (m *UserMutation) ResetPasswordHash() {
	m._PasswordHash = nil
}

// SetAdmin sets the "Admin" field.
func (m *UserMutation) SetAdmin(b bool) {
	m._Admin = &b
}

// Admin returns the value of the "Admin" field in the mutation.
func (m *UserMutation) Admin() (r bool, exists bool) {
	v := m._Admin
	if v == nil {
		return
	}
	return *v, true
}

// OldAdmin returns the old "Admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdmin: %w", err)
	}
	return oldValue.Admin, nil
}

// ResetAdmin resets all changes to the "Admin" field.
func (m *UserMutation) ResetAdmin() {
	m._Admin = nil
}

// SetStartInvestAccountsFlow sets the "StartInvestAccountsFlow" field.
func (m *UserMutation) SetStartInvestAccountsFlow(t time.Time) {
	m._StartInvestAccountsFlow = &t
}

// StartInvestAccountsFlow returns the value of the "StartInvestAccountsFlow" field in the mutation.
func (m *UserMutation) StartInvestAccountsFlow() (r time.Time, exists bool) {
	v := m._StartInvestAccountsFlow
	if v == nil {
		return
	}
	return *v, true
}

// OldStartInvestAccountsFlow returns the old "StartInvestAccountsFlow" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStartInvestAccountsFlow(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartInvestAccountsFlow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartInvestAccountsFlow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartInvestAccountsFlow: %w", err)
	}
	return oldValue.StartInvestAccountsFlow, nil
}

// ClearStartInvestAccountsFlow clears the value of the "StartInvestAccountsFlow" field.
func (m *UserMutation) ClearStartInvestAccountsFlow() {
	m._StartInvestAccountsFlow = nil
	m.clearedFields[user.FieldStartInvestAccountsFlow] = struct{}{}
}

// StartInvestAccountsFlowCleared returns if the "StartInvestAccountsFlow" field was cleared in this mutation.
func (m *UserMutation) StartInvestAccountsFlowCleared() bool {
	_, ok := m.clearedFields[user.FieldStartInvestAccountsFlow]
	return ok
}

// ResetStartInvestAccountsFlow resets all changes to the "StartInvestAccountsFlow" field.
func (m *UserMutation) ResetStartInvestAccountsFlow() {
	m._StartInvestAccountsFlow = nil
	delete(m.clearedFields, user.FieldStartInvestAccountsFlow)
}

// SetHowManyTickersOnHomepage sets the "HowManyTickersOnHomepage" field.
func (m *UserMutation) SetHowManyTickersOnHomepage(i int) {
	m._HowManyTickersOnHomepage = &i
	m.add_HowManyTickersOnHomepage = nil
}

// HowManyTickersOnHomepage returns the value of the "HowManyTickersOnHomepage" field in the mutation.
func (m *UserMutation) HowManyTickersOnHomepage() (r int, exists bool) {
	v := m._HowManyTickersOnHomepage
	if v == nil {
		return
	}
	return *v, true
}

// OldHowManyTickersOnHomepage returns the old "HowManyTickersOnHomepage" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHowManyTickersOnHomepage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHowManyTickersOnHomepage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHowManyTickersOnHomepage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHowManyTickersOnHomepage: %w", err)
	}
	return oldValue.HowManyTickersOnHomepage, nil
}

// AddHowManyTickersOnHomepage adds i to the "HowManyTickersOnHomepage" field.
func (m *UserMutation) AddHowManyTickersOnHomepage(i int) {
	if m.add_HowManyTickersOnHomepage != nil {
		*m.add_HowManyTickersOnHomepage += i
	} else {
		m.add_HowManyTickersOnHomepage = &i
	}
}

// AddedHowManyTickersOnHomepage returns the value that was added to the "HowManyTickersOnHomepage" field in this mutation.
func (m *UserMutation) AddedHowManyTickersOnHomepage() (r int, exists bool) {
	v := m.add_HowManyTickersOnHomepage
	if v == nil {
		return
	}
	return *v, true
}

// ResetHowManyTickersOnHomepage resets all changes to the "HowManyTickersOnHomepage" field.
func (m *UserMutation) ResetHowManyTickersOnHomepage() {
	m._HowManyTickersOnHomepage = nil
	m.add_HowManyTickersOnHomepage = nil
}

// AddInvestAccountIDs adds the "InvestAccounts" edge to the InvestAccount entity by ids.
func (m *UserMutation) AddInvestAccountIDs(ids ...xid.ID) {
	if m._InvestAccounts == nil {
		m._InvestAccounts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m._InvestAccounts[ids[i]] = struct{}{}
	}
}

// ClearInvestAccounts clears the "InvestAccounts" edge to the InvestAccount entity.
func (m *UserMutation) ClearInvestAccounts() {
	m.cleared_InvestAccounts = true
}

// InvestAccountsCleared reports if the "InvestAccounts" edge to the InvestAccount entity was cleared.
func (m *UserMutation) InvestAccountsCleared() bool {
	return m.cleared_InvestAccounts
}

// RemoveInvestAccountIDs removes the "InvestAccounts" edge to the InvestAccount entity by IDs.
func (m *UserMutation) RemoveInvestAccountIDs(ids ...xid.ID) {
	if m.removed_InvestAccounts == nil {
		m.removed_InvestAccounts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m._InvestAccounts, ids[i])
		m.removed_InvestAccounts[ids[i]] = struct{}{}
	}
}

// RemovedInvestAccounts returns the removed IDs of the "InvestAccounts" edge to the InvestAccount entity.
func (m *UserMutation) RemovedInvestAccountsIDs() (ids []xid.ID) {
	for id := range m.removed_InvestAccounts {
		ids = append(ids, id)
	}
	return
}

// InvestAccountsIDs returns the "InvestAccounts" edge IDs in the mutation.
func (m *UserMutation) InvestAccountsIDs() (ids []xid.ID) {
	for id := range m._InvestAccounts {
		ids = append(ids, id)
	}
	return
}

// ResetInvestAccounts resets all changes to the "InvestAccounts" edge.
func (m *UserMutation) ResetInvestAccounts() {
	m._InvestAccounts = nil
	m.cleared_InvestAccounts = false
	m.removed_InvestAccounts = nil
}

// AddStrategyIDs adds the "Strategies" edge to the Strategy entity by ids.
func (m *UserMutation) AddStrategyIDs(ids ...xid.ID) {
	if m._Strategies == nil {
		m._Strategies = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m._Strategies[ids[i]] = struct{}{}
	}
}

// ClearStrategies clears the "Strategies" edge to the Strategy entity.
func (m *UserMutation) ClearStrategies() {
	m.cleared_Strategies = true
}

// StrategiesCleared reports if the "Strategies" edge to the Strategy entity was cleared.
func (m *UserMutation) StrategiesCleared() bool {
	return m.cleared_Strategies
}

// RemoveStrategyIDs removes the "Strategies" edge to the Strategy entity by IDs.
func (m *UserMutation) RemoveStrategyIDs(ids ...xid.ID) {
	if m.removed_Strategies == nil {
		m.removed_Strategies = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m._Strategies, ids[i])
		m.removed_Strategies[ids[i]] = struct{}{}
	}
}

// RemovedStrategies returns the removed IDs of the "Strategies" edge to the Strategy entity.
func (m *UserMutation) RemovedStrategiesIDs() (ids []xid.ID) {
	for id := range m.removed_Strategies {
		ids = append(ids, id)
	}
	return
}

// StrategiesIDs returns the "Strategies" edge IDs in the mutation.
func (m *UserMutation) StrategiesIDs() (ids []xid.ID) {
	for id := range m._Strategies {
		ids = append(ids, id)
	}
	return
}

// ResetStrategies resets all changes to the "Strategies" edge.
func (m *UserMutation) ResetStrategies() {
	m._Strategies = nil
	m.cleared_Strategies = false
	m.removed_Strategies = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._UserName != nil {
		fields = append(fields, user.FieldUserName)
	}
	if m._PasswordHash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m._Admin != nil {
		fields = append(fields, user.FieldAdmin)
	}
	if m._StartInvestAccountsFlow != nil {
		fields = append(fields, user.FieldStartInvestAccountsFlow)
	}
	if m._HowManyTickersOnHomepage != nil {
		fields = append(fields, user.FieldHowManyTickersOnHomepage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUserName:
		return m.UserName()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldAdmin:
		return m.Admin()
	case user.FieldStartInvestAccountsFlow:
		return m.StartInvestAccountsFlow()
	case user.FieldHowManyTickersOnHomepage:
		return m.HowManyTickersOnHomepage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUserName:
		return m.OldUserName(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldAdmin:
		return m.OldAdmin(ctx)
	case user.FieldStartInvestAccountsFlow:
		return m.OldStartInvestAccountsFlow(ctx)
	case user.FieldHowManyTickersOnHomepage:
		return m.OldHowManyTickersOnHomepage(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdmin(v)
		return nil
	case user.FieldStartInvestAccountsFlow:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartInvestAccountsFlow(v)
		return nil
	case user.FieldHowManyTickersOnHomepage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHowManyTickersOnHomepage(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.add_HowManyTickersOnHomepage != nil {
		fields = append(fields, user.FieldHowManyTickersOnHomepage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldHowManyTickersOnHomepage:
		return m.AddedHowManyTickersOnHomepage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldHowManyTickersOnHomepage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHowManyTickersOnHomepage(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldStartInvestAccountsFlow) {
		fields = append(fields, user.FieldStartInvestAccountsFlow)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldStartInvestAccountsFlow:
		m.ClearStartInvestAccountsFlow()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUserName:
		m.ResetUserName()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldAdmin:
		m.ResetAdmin()
		return nil
	case user.FieldStartInvestAccountsFlow:
		m.ResetStartInvestAccountsFlow()
		return nil
	case user.FieldHowManyTickersOnHomepage:
		m.ResetHowManyTickersOnHomepage()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._InvestAccounts != nil {
		edges = append(edges, user.EdgeInvestAccounts)
	}
	if m._Strategies != nil {
		edges = append(edges, user.EdgeStrategies)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeInvestAccounts:
		ids := make([]ent.Value, 0, len(m._InvestAccounts))
		for id := range m._InvestAccounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeStrategies:
		ids := make([]ent.Value, 0, len(m._Strategies))
		for id := range m._Strategies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removed_InvestAccounts != nil {
		edges = append(edges, user.EdgeInvestAccounts)
	}
	if m.removed_Strategies != nil {
		edges = append(edges, user.EdgeStrategies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeInvestAccounts:
		ids := make([]ent.Value, 0, len(m.removed_InvestAccounts))
		for id := range m.removed_InvestAccounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeStrategies:
		ids := make([]ent.Value, 0, len(m.removed_Strategies))
		for id := range m.removed_Strategies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_InvestAccounts {
		edges = append(edges, user.EdgeInvestAccounts)
	}
	if m.cleared_Strategies {
		edges = append(edges, user.EdgeStrategies)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeInvestAccounts:
		return m.cleared_InvestAccounts
	case user.EdgeStrategies:
		return m.cleared_Strategies
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeInvestAccounts:
		m.ResetInvestAccounts()
		return nil
	case user.EdgeStrategies:
		m.ResetStrategies()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
