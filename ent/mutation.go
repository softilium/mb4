// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/rs/xid"
	"github.com/softilium/mb4/ent/divpayout"
	"github.com/softilium/mb4/ent/emission"
	"github.com/softilium/mb4/ent/emitent"
	"github.com/softilium/mb4/ent/industry"
	"github.com/softilium/mb4/ent/investaccount"
	"github.com/softilium/mb4/ent/investaccountcashflow"
	"github.com/softilium/mb4/ent/investaccountvaluation"
	"github.com/softilium/mb4/ent/predicate"
	"github.com/softilium/mb4/ent/quote"
	"github.com/softilium/mb4/ent/report"
	"github.com/softilium/mb4/ent/ticker"
	"github.com/softilium/mb4/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDivPayout              = "DivPayout"
	TypeEmission               = "Emission"
	TypeEmitent                = "Emitent"
	TypeIndustry               = "Industry"
	TypeInvestAccount          = "InvestAccount"
	TypeInvestAccountCashflow  = "InvestAccountCashflow"
	TypeInvestAccountValuation = "InvestAccountValuation"
	TypeQuote                  = "Quote"
	TypeReport                 = "Report"
	TypeTicker                 = "Ticker"
	TypeUser                   = "User"
)

// DivPayoutMutation represents an operation that mutates the DivPayout nodes in the graph.
type DivPayoutMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_ForYear        *int
	add_ForYear     *int
	_ForQuarter     *int
	add_ForQuarter  *int
	_CloseDate      *time.Time
	_Status         *int
	add_Status      *int
	_DPS            *float64
	add_DPS         *float64
	clearedFields   map[string]struct{}
	_Tickers        *string
	cleared_Tickers bool
	done            bool
	oldValue        func(context.Context) (*DivPayout, error)
	predicates      []predicate.DivPayout
}

var _ ent.Mutation = (*DivPayoutMutation)(nil)

// divpayoutOption allows management of the mutation configuration using functional options.
type divpayoutOption func(*DivPayoutMutation)

// newDivPayoutMutation creates new mutation for the DivPayout entity.
func newDivPayoutMutation(c config, op Op, opts ...divpayoutOption) *DivPayoutMutation {
	m := &DivPayoutMutation{
		config:        c,
		op:            op,
		typ:           TypeDivPayout,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDivPayoutID sets the ID field of the mutation.
func withDivPayoutID(id int) divpayoutOption {
	return func(m *DivPayoutMutation) {
		var (
			err   error
			once  sync.Once
			value *DivPayout
		)
		m.oldValue = func(ctx context.Context) (*DivPayout, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DivPayout.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDivPayout sets the old DivPayout of the mutation.
func withDivPayout(node *DivPayout) divpayoutOption {
	return func(m *DivPayoutMutation) {
		m.oldValue = func(context.Context) (*DivPayout, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DivPayoutMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DivPayoutMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DivPayoutMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DivPayoutMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DivPayout.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetForYear sets the "ForYear" field.
func (m *DivPayoutMutation) SetForYear(i int) {
	m._ForYear = &i
	m.add_ForYear = nil
}

// ForYear returns the value of the "ForYear" field in the mutation.
func (m *DivPayoutMutation) ForYear() (r int, exists bool) {
	v := m._ForYear
	if v == nil {
		return
	}
	return *v, true
}

// OldForYear returns the old "ForYear" field's value of the DivPayout entity.
// If the DivPayout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivPayoutMutation) OldForYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForYear: %w", err)
	}
	return oldValue.ForYear, nil
}

// AddForYear adds i to the "ForYear" field.
func (m *DivPayoutMutation) AddForYear(i int) {
	if m.add_ForYear != nil {
		*m.add_ForYear += i
	} else {
		m.add_ForYear = &i
	}
}

// AddedForYear returns the value that was added to the "ForYear" field in this mutation.
func (m *DivPayoutMutation) AddedForYear() (r int, exists bool) {
	v := m.add_ForYear
	if v == nil {
		return
	}
	return *v, true
}

// ResetForYear resets all changes to the "ForYear" field.
func (m *DivPayoutMutation) ResetForYear() {
	m._ForYear = nil
	m.add_ForYear = nil
}

// SetForQuarter sets the "ForQuarter" field.
func (m *DivPayoutMutation) SetForQuarter(i int) {
	m._ForQuarter = &i
	m.add_ForQuarter = nil
}

// ForQuarter returns the value of the "ForQuarter" field in the mutation.
func (m *DivPayoutMutation) ForQuarter() (r int, exists bool) {
	v := m._ForQuarter
	if v == nil {
		return
	}
	return *v, true
}

// OldForQuarter returns the old "ForQuarter" field's value of the DivPayout entity.
// If the DivPayout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivPayoutMutation) OldForQuarter(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForQuarter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForQuarter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForQuarter: %w", err)
	}
	return oldValue.ForQuarter, nil
}

// AddForQuarter adds i to the "ForQuarter" field.
func (m *DivPayoutMutation) AddForQuarter(i int) {
	if m.add_ForQuarter != nil {
		*m.add_ForQuarter += i
	} else {
		m.add_ForQuarter = &i
	}
}

// AddedForQuarter returns the value that was added to the "ForQuarter" field in this mutation.
func (m *DivPayoutMutation) AddedForQuarter() (r int, exists bool) {
	v := m.add_ForQuarter
	if v == nil {
		return
	}
	return *v, true
}

// ResetForQuarter resets all changes to the "ForQuarter" field.
func (m *DivPayoutMutation) ResetForQuarter() {
	m._ForQuarter = nil
	m.add_ForQuarter = nil
}

// SetCloseDate sets the "CloseDate" field.
func (m *DivPayoutMutation) SetCloseDate(t time.Time) {
	m._CloseDate = &t
}

// CloseDate returns the value of the "CloseDate" field in the mutation.
func (m *DivPayoutMutation) CloseDate() (r time.Time, exists bool) {
	v := m._CloseDate
	if v == nil {
		return
	}
	return *v, true
}

// OldCloseDate returns the old "CloseDate" field's value of the DivPayout entity.
// If the DivPayout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivPayoutMutation) OldCloseDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCloseDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCloseDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCloseDate: %w", err)
	}
	return oldValue.CloseDate, nil
}

// ResetCloseDate resets all changes to the "CloseDate" field.
func (m *DivPayoutMutation) ResetCloseDate() {
	m._CloseDate = nil
}

// SetStatus sets the "Status" field.
func (m *DivPayoutMutation) SetStatus(i int) {
	m._Status = &i
	m.add_Status = nil
}

// Status returns the value of the "Status" field in the mutation.
func (m *DivPayoutMutation) Status() (r int, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the DivPayout entity.
// If the DivPayout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivPayoutMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "Status" field.
func (m *DivPayoutMutation) AddStatus(i int) {
	if m.add_Status != nil {
		*m.add_Status += i
	} else {
		m.add_Status = &i
	}
}

// AddedStatus returns the value that was added to the "Status" field in this mutation.
func (m *DivPayoutMutation) AddedStatus() (r int, exists bool) {
	v := m.add_Status
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "Status" field.
func (m *DivPayoutMutation) ResetStatus() {
	m._Status = nil
	m.add_Status = nil
}

// SetDPS sets the "DPS" field.
func (m *DivPayoutMutation) SetDPS(f float64) {
	m._DPS = &f
	m.add_DPS = nil
}

// DPS returns the value of the "DPS" field in the mutation.
func (m *DivPayoutMutation) DPS() (r float64, exists bool) {
	v := m._DPS
	if v == nil {
		return
	}
	return *v, true
}

// OldDPS returns the old "DPS" field's value of the DivPayout entity.
// If the DivPayout object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DivPayoutMutation) OldDPS(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDPS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDPS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDPS: %w", err)
	}
	return oldValue.DPS, nil
}

// AddDPS adds f to the "DPS" field.
func (m *DivPayoutMutation) AddDPS(f float64) {
	if m.add_DPS != nil {
		*m.add_DPS += f
	} else {
		m.add_DPS = &f
	}
}

// AddedDPS returns the value that was added to the "DPS" field in this mutation.
func (m *DivPayoutMutation) AddedDPS() (r float64, exists bool) {
	v := m.add_DPS
	if v == nil {
		return
	}
	return *v, true
}

// ResetDPS resets all changes to the "DPS" field.
func (m *DivPayoutMutation) ResetDPS() {
	m._DPS = nil
	m.add_DPS = nil
}

// SetTickersID sets the "Tickers" edge to the Ticker entity by id.
func (m *DivPayoutMutation) SetTickersID(id string) {
	m._Tickers = &id
}

// ClearTickers clears the "Tickers" edge to the Ticker entity.
func (m *DivPayoutMutation) ClearTickers() {
	m.cleared_Tickers = true
}

// TickersCleared reports if the "Tickers" edge to the Ticker entity was cleared.
func (m *DivPayoutMutation) TickersCleared() bool {
	return m.cleared_Tickers
}

// TickersID returns the "Tickers" edge ID in the mutation.
func (m *DivPayoutMutation) TickersID() (id string, exists bool) {
	if m._Tickers != nil {
		return *m._Tickers, true
	}
	return
}

// TickersIDs returns the "Tickers" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TickersID instead. It exists only for internal usage by the builders.
func (m *DivPayoutMutation) TickersIDs() (ids []string) {
	if id := m._Tickers; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTickers resets all changes to the "Tickers" edge.
func (m *DivPayoutMutation) ResetTickers() {
	m._Tickers = nil
	m.cleared_Tickers = false
}

// Where appends a list predicates to the DivPayoutMutation builder.
func (m *DivPayoutMutation) Where(ps ...predicate.DivPayout) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DivPayoutMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DivPayout).
func (m *DivPayoutMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DivPayoutMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._ForYear != nil {
		fields = append(fields, divpayout.FieldForYear)
	}
	if m._ForQuarter != nil {
		fields = append(fields, divpayout.FieldForQuarter)
	}
	if m._CloseDate != nil {
		fields = append(fields, divpayout.FieldCloseDate)
	}
	if m._Status != nil {
		fields = append(fields, divpayout.FieldStatus)
	}
	if m._DPS != nil {
		fields = append(fields, divpayout.FieldDPS)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DivPayoutMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case divpayout.FieldForYear:
		return m.ForYear()
	case divpayout.FieldForQuarter:
		return m.ForQuarter()
	case divpayout.FieldCloseDate:
		return m.CloseDate()
	case divpayout.FieldStatus:
		return m.Status()
	case divpayout.FieldDPS:
		return m.DPS()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DivPayoutMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case divpayout.FieldForYear:
		return m.OldForYear(ctx)
	case divpayout.FieldForQuarter:
		return m.OldForQuarter(ctx)
	case divpayout.FieldCloseDate:
		return m.OldCloseDate(ctx)
	case divpayout.FieldStatus:
		return m.OldStatus(ctx)
	case divpayout.FieldDPS:
		return m.OldDPS(ctx)
	}
	return nil, fmt.Errorf("unknown DivPayout field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DivPayoutMutation) SetField(name string, value ent.Value) error {
	switch name {
	case divpayout.FieldForYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForYear(v)
		return nil
	case divpayout.FieldForQuarter:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForQuarter(v)
		return nil
	case divpayout.FieldCloseDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCloseDate(v)
		return nil
	case divpayout.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case divpayout.FieldDPS:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDPS(v)
		return nil
	}
	return fmt.Errorf("unknown DivPayout field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DivPayoutMutation) AddedFields() []string {
	var fields []string
	if m.add_ForYear != nil {
		fields = append(fields, divpayout.FieldForYear)
	}
	if m.add_ForQuarter != nil {
		fields = append(fields, divpayout.FieldForQuarter)
	}
	if m.add_Status != nil {
		fields = append(fields, divpayout.FieldStatus)
	}
	if m.add_DPS != nil {
		fields = append(fields, divpayout.FieldDPS)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DivPayoutMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case divpayout.FieldForYear:
		return m.AddedForYear()
	case divpayout.FieldForQuarter:
		return m.AddedForQuarter()
	case divpayout.FieldStatus:
		return m.AddedStatus()
	case divpayout.FieldDPS:
		return m.AddedDPS()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DivPayoutMutation) AddField(name string, value ent.Value) error {
	switch name {
	case divpayout.FieldForYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddForYear(v)
		return nil
	case divpayout.FieldForQuarter:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddForQuarter(v)
		return nil
	case divpayout.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case divpayout.FieldDPS:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDPS(v)
		return nil
	}
	return fmt.Errorf("unknown DivPayout numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DivPayoutMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DivPayoutMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DivPayoutMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DivPayout nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DivPayoutMutation) ResetField(name string) error {
	switch name {
	case divpayout.FieldForYear:
		m.ResetForYear()
		return nil
	case divpayout.FieldForQuarter:
		m.ResetForQuarter()
		return nil
	case divpayout.FieldCloseDate:
		m.ResetCloseDate()
		return nil
	case divpayout.FieldStatus:
		m.ResetStatus()
		return nil
	case divpayout.FieldDPS:
		m.ResetDPS()
		return nil
	}
	return fmt.Errorf("unknown DivPayout field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DivPayoutMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Tickers != nil {
		edges = append(edges, divpayout.EdgeTickers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DivPayoutMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case divpayout.EdgeTickers:
		if id := m._Tickers; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DivPayoutMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DivPayoutMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DivPayoutMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Tickers {
		edges = append(edges, divpayout.EdgeTickers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DivPayoutMutation) EdgeCleared(name string) bool {
	switch name {
	case divpayout.EdgeTickers:
		return m.cleared_Tickers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DivPayoutMutation) ClearEdge(name string) error {
	switch name {
	case divpayout.EdgeTickers:
		m.ClearTickers()
		return nil
	}
	return fmt.Errorf("unknown DivPayout unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DivPayoutMutation) ResetEdge(name string) error {
	switch name {
	case divpayout.EdgeTickers:
		m.ResetTickers()
		return nil
	}
	return fmt.Errorf("unknown DivPayout edge %s", name)
}

// EmissionMutation represents an operation that mutates the Emission nodes in the graph.
type EmissionMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	_RecDate         *time.Time
	_Size            *int64
	add_Size         *int64
	_FreeFloat       *int
	add_FreeFloat    *int
	_LotSize         *int
	add_LotSize      *int
	_ListingLevel    *int
	add_ListingLevel *int
	clearedFields    map[string]struct{}
	_Ticker          *string
	cleared_Ticker   bool
	done             bool
	oldValue         func(context.Context) (*Emission, error)
	predicates       []predicate.Emission
}

var _ ent.Mutation = (*EmissionMutation)(nil)

// emissionOption allows management of the mutation configuration using functional options.
type emissionOption func(*EmissionMutation)

// newEmissionMutation creates new mutation for the Emission entity.
func newEmissionMutation(c config, op Op, opts ...emissionOption) *EmissionMutation {
	m := &EmissionMutation{
		config:        c,
		op:            op,
		typ:           TypeEmission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmissionID sets the ID field of the mutation.
func withEmissionID(id xid.ID) emissionOption {
	return func(m *EmissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Emission
		)
		m.oldValue = func(ctx context.Context) (*Emission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Emission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmission sets the old Emission of the mutation.
func withEmission(node *Emission) emissionOption {
	return func(m *EmissionMutation) {
		m.oldValue = func(context.Context) (*Emission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Emission entities.
func (m *EmissionMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmissionMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmissionMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Emission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRecDate sets the "RecDate" field.
func (m *EmissionMutation) SetRecDate(t time.Time) {
	m._RecDate = &t
}

// RecDate returns the value of the "RecDate" field in the mutation.
func (m *EmissionMutation) RecDate() (r time.Time, exists bool) {
	v := m._RecDate
	if v == nil {
		return
	}
	return *v, true
}

// OldRecDate returns the old "RecDate" field's value of the Emission entity.
// If the Emission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmissionMutation) OldRecDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecDate: %w", err)
	}
	return oldValue.RecDate, nil
}

// ResetRecDate resets all changes to the "RecDate" field.
func (m *EmissionMutation) ResetRecDate() {
	m._RecDate = nil
}

// SetSize sets the "Size" field.
func (m *EmissionMutation) SetSize(i int64) {
	m._Size = &i
	m.add_Size = nil
}

// Size returns the value of the "Size" field in the mutation.
func (m *EmissionMutation) Size() (r int64, exists bool) {
	v := m._Size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "Size" field's value of the Emission entity.
// If the Emission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmissionMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "Size" field.
func (m *EmissionMutation) AddSize(i int64) {
	if m.add_Size != nil {
		*m.add_Size += i
	} else {
		m.add_Size = &i
	}
}

// AddedSize returns the value that was added to the "Size" field in this mutation.
func (m *EmissionMutation) AddedSize() (r int64, exists bool) {
	v := m.add_Size
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "Size" field.
func (m *EmissionMutation) ResetSize() {
	m._Size = nil
	m.add_Size = nil
}

// SetFreeFloat sets the "FreeFloat" field.
func (m *EmissionMutation) SetFreeFloat(i int) {
	m._FreeFloat = &i
	m.add_FreeFloat = nil
}

// FreeFloat returns the value of the "FreeFloat" field in the mutation.
func (m *EmissionMutation) FreeFloat() (r int, exists bool) {
	v := m._FreeFloat
	if v == nil {
		return
	}
	return *v, true
}

// OldFreeFloat returns the old "FreeFloat" field's value of the Emission entity.
// If the Emission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmissionMutation) OldFreeFloat(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreeFloat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreeFloat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreeFloat: %w", err)
	}
	return oldValue.FreeFloat, nil
}

// AddFreeFloat adds i to the "FreeFloat" field.
func (m *EmissionMutation) AddFreeFloat(i int) {
	if m.add_FreeFloat != nil {
		*m.add_FreeFloat += i
	} else {
		m.add_FreeFloat = &i
	}
}

// AddedFreeFloat returns the value that was added to the "FreeFloat" field in this mutation.
func (m *EmissionMutation) AddedFreeFloat() (r int, exists bool) {
	v := m.add_FreeFloat
	if v == nil {
		return
	}
	return *v, true
}

// ClearFreeFloat clears the value of the "FreeFloat" field.
func (m *EmissionMutation) ClearFreeFloat() {
	m._FreeFloat = nil
	m.add_FreeFloat = nil
	m.clearedFields[emission.FieldFreeFloat] = struct{}{}
}

// FreeFloatCleared returns if the "FreeFloat" field was cleared in this mutation.
func (m *EmissionMutation) FreeFloatCleared() bool {
	_, ok := m.clearedFields[emission.FieldFreeFloat]
	return ok
}

// ResetFreeFloat resets all changes to the "FreeFloat" field.
func (m *EmissionMutation) ResetFreeFloat() {
	m._FreeFloat = nil
	m.add_FreeFloat = nil
	delete(m.clearedFields, emission.FieldFreeFloat)
}

// SetLotSize sets the "LotSize" field.
func (m *EmissionMutation) SetLotSize(i int) {
	m._LotSize = &i
	m.add_LotSize = nil
}

// LotSize returns the value of the "LotSize" field in the mutation.
func (m *EmissionMutation) LotSize() (r int, exists bool) {
	v := m._LotSize
	if v == nil {
		return
	}
	return *v, true
}

// OldLotSize returns the old "LotSize" field's value of the Emission entity.
// If the Emission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmissionMutation) OldLotSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLotSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLotSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLotSize: %w", err)
	}
	return oldValue.LotSize, nil
}

// AddLotSize adds i to the "LotSize" field.
func (m *EmissionMutation) AddLotSize(i int) {
	if m.add_LotSize != nil {
		*m.add_LotSize += i
	} else {
		m.add_LotSize = &i
	}
}

// AddedLotSize returns the value that was added to the "LotSize" field in this mutation.
func (m *EmissionMutation) AddedLotSize() (r int, exists bool) {
	v := m.add_LotSize
	if v == nil {
		return
	}
	return *v, true
}

// ClearLotSize clears the value of the "LotSize" field.
func (m *EmissionMutation) ClearLotSize() {
	m._LotSize = nil
	m.add_LotSize = nil
	m.clearedFields[emission.FieldLotSize] = struct{}{}
}

// LotSizeCleared returns if the "LotSize" field was cleared in this mutation.
func (m *EmissionMutation) LotSizeCleared() bool {
	_, ok := m.clearedFields[emission.FieldLotSize]
	return ok
}

// ResetLotSize resets all changes to the "LotSize" field.
func (m *EmissionMutation) ResetLotSize() {
	m._LotSize = nil
	m.add_LotSize = nil
	delete(m.clearedFields, emission.FieldLotSize)
}

// SetListingLevel sets the "ListingLevel" field.
func (m *EmissionMutation) SetListingLevel(i int) {
	m._ListingLevel = &i
	m.add_ListingLevel = nil
}

// ListingLevel returns the value of the "ListingLevel" field in the mutation.
func (m *EmissionMutation) ListingLevel() (r int, exists bool) {
	v := m._ListingLevel
	if v == nil {
		return
	}
	return *v, true
}

// OldListingLevel returns the old "ListingLevel" field's value of the Emission entity.
// If the Emission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmissionMutation) OldListingLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldListingLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldListingLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldListingLevel: %w", err)
	}
	return oldValue.ListingLevel, nil
}

// AddListingLevel adds i to the "ListingLevel" field.
func (m *EmissionMutation) AddListingLevel(i int) {
	if m.add_ListingLevel != nil {
		*m.add_ListingLevel += i
	} else {
		m.add_ListingLevel = &i
	}
}

// AddedListingLevel returns the value that was added to the "ListingLevel" field in this mutation.
func (m *EmissionMutation) AddedListingLevel() (r int, exists bool) {
	v := m.add_ListingLevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetListingLevel resets all changes to the "ListingLevel" field.
func (m *EmissionMutation) ResetListingLevel() {
	m._ListingLevel = nil
	m.add_ListingLevel = nil
}

// SetTickerID sets the "Ticker" edge to the Ticker entity by id.
func (m *EmissionMutation) SetTickerID(id string) {
	m._Ticker = &id
}

// ClearTicker clears the "Ticker" edge to the Ticker entity.
func (m *EmissionMutation) ClearTicker() {
	m.cleared_Ticker = true
}

// TickerCleared reports if the "Ticker" edge to the Ticker entity was cleared.
func (m *EmissionMutation) TickerCleared() bool {
	return m.cleared_Ticker
}

// TickerID returns the "Ticker" edge ID in the mutation.
func (m *EmissionMutation) TickerID() (id string, exists bool) {
	if m._Ticker != nil {
		return *m._Ticker, true
	}
	return
}

// TickerIDs returns the "Ticker" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TickerID instead. It exists only for internal usage by the builders.
func (m *EmissionMutation) TickerIDs() (ids []string) {
	if id := m._Ticker; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTicker resets all changes to the "Ticker" edge.
func (m *EmissionMutation) ResetTicker() {
	m._Ticker = nil
	m.cleared_Ticker = false
}

// Where appends a list predicates to the EmissionMutation builder.
func (m *EmissionMutation) Where(ps ...predicate.Emission) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EmissionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Emission).
func (m *EmissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmissionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._RecDate != nil {
		fields = append(fields, emission.FieldRecDate)
	}
	if m._Size != nil {
		fields = append(fields, emission.FieldSize)
	}
	if m._FreeFloat != nil {
		fields = append(fields, emission.FieldFreeFloat)
	}
	if m._LotSize != nil {
		fields = append(fields, emission.FieldLotSize)
	}
	if m._ListingLevel != nil {
		fields = append(fields, emission.FieldListingLevel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emission.FieldRecDate:
		return m.RecDate()
	case emission.FieldSize:
		return m.Size()
	case emission.FieldFreeFloat:
		return m.FreeFloat()
	case emission.FieldLotSize:
		return m.LotSize()
	case emission.FieldListingLevel:
		return m.ListingLevel()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emission.FieldRecDate:
		return m.OldRecDate(ctx)
	case emission.FieldSize:
		return m.OldSize(ctx)
	case emission.FieldFreeFloat:
		return m.OldFreeFloat(ctx)
	case emission.FieldLotSize:
		return m.OldLotSize(ctx)
	case emission.FieldListingLevel:
		return m.OldListingLevel(ctx)
	}
	return nil, fmt.Errorf("unknown Emission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emission.FieldRecDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecDate(v)
		return nil
	case emission.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case emission.FieldFreeFloat:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreeFloat(v)
		return nil
	case emission.FieldLotSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLotSize(v)
		return nil
	case emission.FieldListingLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetListingLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Emission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmissionMutation) AddedFields() []string {
	var fields []string
	if m.add_Size != nil {
		fields = append(fields, emission.FieldSize)
	}
	if m.add_FreeFloat != nil {
		fields = append(fields, emission.FieldFreeFloat)
	}
	if m.add_LotSize != nil {
		fields = append(fields, emission.FieldLotSize)
	}
	if m.add_ListingLevel != nil {
		fields = append(fields, emission.FieldListingLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case emission.FieldSize:
		return m.AddedSize()
	case emission.FieldFreeFloat:
		return m.AddedFreeFloat()
	case emission.FieldLotSize:
		return m.AddedLotSize()
	case emission.FieldListingLevel:
		return m.AddedListingLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case emission.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case emission.FieldFreeFloat:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFreeFloat(v)
		return nil
	case emission.FieldLotSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLotSize(v)
		return nil
	case emission.FieldListingLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddListingLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Emission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emission.FieldFreeFloat) {
		fields = append(fields, emission.FieldFreeFloat)
	}
	if m.FieldCleared(emission.FieldLotSize) {
		fields = append(fields, emission.FieldLotSize)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmissionMutation) ClearField(name string) error {
	switch name {
	case emission.FieldFreeFloat:
		m.ClearFreeFloat()
		return nil
	case emission.FieldLotSize:
		m.ClearLotSize()
		return nil
	}
	return fmt.Errorf("unknown Emission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmissionMutation) ResetField(name string) error {
	switch name {
	case emission.FieldRecDate:
		m.ResetRecDate()
		return nil
	case emission.FieldSize:
		m.ResetSize()
		return nil
	case emission.FieldFreeFloat:
		m.ResetFreeFloat()
		return nil
	case emission.FieldLotSize:
		m.ResetLotSize()
		return nil
	case emission.FieldListingLevel:
		m.ResetListingLevel()
		return nil
	}
	return fmt.Errorf("unknown Emission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Ticker != nil {
		edges = append(edges, emission.EdgeTicker)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emission.EdgeTicker:
		if id := m._Ticker; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Ticker {
		edges = append(edges, emission.EdgeTicker)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmissionMutation) EdgeCleared(name string) bool {
	switch name {
	case emission.EdgeTicker:
		return m.cleared_Ticker
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmissionMutation) ClearEdge(name string) error {
	switch name {
	case emission.EdgeTicker:
		m.ClearTicker()
		return nil
	}
	return fmt.Errorf("unknown Emission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmissionMutation) ResetEdge(name string) error {
	switch name {
	case emission.EdgeTicker:
		m.ResetTicker()
		return nil
	}
	return fmt.Errorf("unknown Emission edge %s", name)
}

// EmitentMutation represents an operation that mutates the Emitent nodes in the graph.
type EmitentMutation struct {
	config
	op               Op
	typ              string
	id               *xid.ID
	_Descr           *string
	clearedFields    map[string]struct{}
	_Industry        *string
	cleared_Industry bool
	_Tickers         map[string]struct{}
	removed_Tickers  map[string]struct{}
	cleared_Tickers  bool
	_Reports         map[xid.ID]struct{}
	removed_Reports  map[xid.ID]struct{}
	cleared_Reports  bool
	done             bool
	oldValue         func(context.Context) (*Emitent, error)
	predicates       []predicate.Emitent
}

var _ ent.Mutation = (*EmitentMutation)(nil)

// emitentOption allows management of the mutation configuration using functional options.
type emitentOption func(*EmitentMutation)

// newEmitentMutation creates new mutation for the Emitent entity.
func newEmitentMutation(c config, op Op, opts ...emitentOption) *EmitentMutation {
	m := &EmitentMutation{
		config:        c,
		op:            op,
		typ:           TypeEmitent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmitentID sets the ID field of the mutation.
func withEmitentID(id xid.ID) emitentOption {
	return func(m *EmitentMutation) {
		var (
			err   error
			once  sync.Once
			value *Emitent
		)
		m.oldValue = func(ctx context.Context) (*Emitent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Emitent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmitent sets the old Emitent of the mutation.
func withEmitent(node *Emitent) emitentOption {
	return func(m *EmitentMutation) {
		m.oldValue = func(context.Context) (*Emitent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmitentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmitentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Emitent entities.
func (m *EmitentMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmitentMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmitentMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Emitent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescr sets the "Descr" field.
func (m *EmitentMutation) SetDescr(s string) {
	m._Descr = &s
}

// Descr returns the value of the "Descr" field in the mutation.
func (m *EmitentMutation) Descr() (r string, exists bool) {
	v := m._Descr
	if v == nil {
		return
	}
	return *v, true
}

// OldDescr returns the old "Descr" field's value of the Emitent entity.
// If the Emitent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmitentMutation) OldDescr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescr: %w", err)
	}
	return oldValue.Descr, nil
}

// ResetDescr resets all changes to the "Descr" field.
func (m *EmitentMutation) ResetDescr() {
	m._Descr = nil
}

// SetIndustryID sets the "Industry" edge to the Industry entity by id.
func (m *EmitentMutation) SetIndustryID(id string) {
	m._Industry = &id
}

// ClearIndustry clears the "Industry" edge to the Industry entity.
func (m *EmitentMutation) ClearIndustry() {
	m.cleared_Industry = true
}

// IndustryCleared reports if the "Industry" edge to the Industry entity was cleared.
func (m *EmitentMutation) IndustryCleared() bool {
	return m.cleared_Industry
}

// IndustryID returns the "Industry" edge ID in the mutation.
func (m *EmitentMutation) IndustryID() (id string, exists bool) {
	if m._Industry != nil {
		return *m._Industry, true
	}
	return
}

// IndustryIDs returns the "Industry" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IndustryID instead. It exists only for internal usage by the builders.
func (m *EmitentMutation) IndustryIDs() (ids []string) {
	if id := m._Industry; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIndustry resets all changes to the "Industry" edge.
func (m *EmitentMutation) ResetIndustry() {
	m._Industry = nil
	m.cleared_Industry = false
}

// AddTickerIDs adds the "Tickers" edge to the Ticker entity by ids.
func (m *EmitentMutation) AddTickerIDs(ids ...string) {
	if m._Tickers == nil {
		m._Tickers = make(map[string]struct{})
	}
	for i := range ids {
		m._Tickers[ids[i]] = struct{}{}
	}
}

// ClearTickers clears the "Tickers" edge to the Ticker entity.
func (m *EmitentMutation) ClearTickers() {
	m.cleared_Tickers = true
}

// TickersCleared reports if the "Tickers" edge to the Ticker entity was cleared.
func (m *EmitentMutation) TickersCleared() bool {
	return m.cleared_Tickers
}

// RemoveTickerIDs removes the "Tickers" edge to the Ticker entity by IDs.
func (m *EmitentMutation) RemoveTickerIDs(ids ...string) {
	if m.removed_Tickers == nil {
		m.removed_Tickers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m._Tickers, ids[i])
		m.removed_Tickers[ids[i]] = struct{}{}
	}
}

// RemovedTickers returns the removed IDs of the "Tickers" edge to the Ticker entity.
func (m *EmitentMutation) RemovedTickersIDs() (ids []string) {
	for id := range m.removed_Tickers {
		ids = append(ids, id)
	}
	return
}

// TickersIDs returns the "Tickers" edge IDs in the mutation.
func (m *EmitentMutation) TickersIDs() (ids []string) {
	for id := range m._Tickers {
		ids = append(ids, id)
	}
	return
}

// ResetTickers resets all changes to the "Tickers" edge.
func (m *EmitentMutation) ResetTickers() {
	m._Tickers = nil
	m.cleared_Tickers = false
	m.removed_Tickers = nil
}

// AddReportIDs adds the "Reports" edge to the Report entity by ids.
func (m *EmitentMutation) AddReportIDs(ids ...xid.ID) {
	if m._Reports == nil {
		m._Reports = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m._Reports[ids[i]] = struct{}{}
	}
}

// ClearReports clears the "Reports" edge to the Report entity.
func (m *EmitentMutation) ClearReports() {
	m.cleared_Reports = true
}

// ReportsCleared reports if the "Reports" edge to the Report entity was cleared.
func (m *EmitentMutation) ReportsCleared() bool {
	return m.cleared_Reports
}

// RemoveReportIDs removes the "Reports" edge to the Report entity by IDs.
func (m *EmitentMutation) RemoveReportIDs(ids ...xid.ID) {
	if m.removed_Reports == nil {
		m.removed_Reports = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m._Reports, ids[i])
		m.removed_Reports[ids[i]] = struct{}{}
	}
}

// RemovedReports returns the removed IDs of the "Reports" edge to the Report entity.
func (m *EmitentMutation) RemovedReportsIDs() (ids []xid.ID) {
	for id := range m.removed_Reports {
		ids = append(ids, id)
	}
	return
}

// ReportsIDs returns the "Reports" edge IDs in the mutation.
func (m *EmitentMutation) ReportsIDs() (ids []xid.ID) {
	for id := range m._Reports {
		ids = append(ids, id)
	}
	return
}

// ResetReports resets all changes to the "Reports" edge.
func (m *EmitentMutation) ResetReports() {
	m._Reports = nil
	m.cleared_Reports = false
	m.removed_Reports = nil
}

// Where appends a list predicates to the EmitentMutation builder.
func (m *EmitentMutation) Where(ps ...predicate.Emitent) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EmitentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Emitent).
func (m *EmitentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmitentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Descr != nil {
		fields = append(fields, emitent.FieldDescr)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmitentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emitent.FieldDescr:
		return m.Descr()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmitentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emitent.FieldDescr:
		return m.OldDescr(ctx)
	}
	return nil, fmt.Errorf("unknown Emitent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmitentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emitent.FieldDescr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescr(v)
		return nil
	}
	return fmt.Errorf("unknown Emitent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmitentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmitentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmitentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Emitent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmitentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmitentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmitentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Emitent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmitentMutation) ResetField(name string) error {
	switch name {
	case emitent.FieldDescr:
		m.ResetDescr()
		return nil
	}
	return fmt.Errorf("unknown Emitent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmitentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Industry != nil {
		edges = append(edges, emitent.EdgeIndustry)
	}
	if m._Tickers != nil {
		edges = append(edges, emitent.EdgeTickers)
	}
	if m._Reports != nil {
		edges = append(edges, emitent.EdgeReports)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmitentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emitent.EdgeIndustry:
		if id := m._Industry; id != nil {
			return []ent.Value{*id}
		}
	case emitent.EdgeTickers:
		ids := make([]ent.Value, 0, len(m._Tickers))
		for id := range m._Tickers {
			ids = append(ids, id)
		}
		return ids
	case emitent.EdgeReports:
		ids := make([]ent.Value, 0, len(m._Reports))
		for id := range m._Reports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmitentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_Tickers != nil {
		edges = append(edges, emitent.EdgeTickers)
	}
	if m.removed_Reports != nil {
		edges = append(edges, emitent.EdgeReports)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmitentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case emitent.EdgeTickers:
		ids := make([]ent.Value, 0, len(m.removed_Tickers))
		for id := range m.removed_Tickers {
			ids = append(ids, id)
		}
		return ids
	case emitent.EdgeReports:
		ids := make([]ent.Value, 0, len(m.removed_Reports))
		for id := range m.removed_Reports {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmitentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Industry {
		edges = append(edges, emitent.EdgeIndustry)
	}
	if m.cleared_Tickers {
		edges = append(edges, emitent.EdgeTickers)
	}
	if m.cleared_Reports {
		edges = append(edges, emitent.EdgeReports)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmitentMutation) EdgeCleared(name string) bool {
	switch name {
	case emitent.EdgeIndustry:
		return m.cleared_Industry
	case emitent.EdgeTickers:
		return m.cleared_Tickers
	case emitent.EdgeReports:
		return m.cleared_Reports
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmitentMutation) ClearEdge(name string) error {
	switch name {
	case emitent.EdgeIndustry:
		m.ClearIndustry()
		return nil
	}
	return fmt.Errorf("unknown Emitent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmitentMutation) ResetEdge(name string) error {
	switch name {
	case emitent.EdgeIndustry:
		m.ResetIndustry()
		return nil
	case emitent.EdgeTickers:
		m.ResetTickers()
		return nil
	case emitent.EdgeReports:
		m.ResetReports()
		return nil
	}
	return fmt.Errorf("unknown Emitent edge %s", name)
}

// IndustryMutation represents an operation that mutates the Industry nodes in the graph.
type IndustryMutation struct {
	config
	op               Op
	typ              string
	id               *string
	_Descr           *string
	clearedFields    map[string]struct{}
	_Emitents        map[xid.ID]struct{}
	removed_Emitents map[xid.ID]struct{}
	cleared_Emitents bool
	done             bool
	oldValue         func(context.Context) (*Industry, error)
	predicates       []predicate.Industry
}

var _ ent.Mutation = (*IndustryMutation)(nil)

// industryOption allows management of the mutation configuration using functional options.
type industryOption func(*IndustryMutation)

// newIndustryMutation creates new mutation for the Industry entity.
func newIndustryMutation(c config, op Op, opts ...industryOption) *IndustryMutation {
	m := &IndustryMutation{
		config:        c,
		op:            op,
		typ:           TypeIndustry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIndustryID sets the ID field of the mutation.
func withIndustryID(id string) industryOption {
	return func(m *IndustryMutation) {
		var (
			err   error
			once  sync.Once
			value *Industry
		)
		m.oldValue = func(ctx context.Context) (*Industry, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Industry.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIndustry sets the old Industry of the mutation.
func withIndustry(node *Industry) industryOption {
	return func(m *IndustryMutation) {
		m.oldValue = func(context.Context) (*Industry, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IndustryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IndustryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Industry entities.
func (m *IndustryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IndustryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IndustryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Industry.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescr sets the "Descr" field.
func (m *IndustryMutation) SetDescr(s string) {
	m._Descr = &s
}

// Descr returns the value of the "Descr" field in the mutation.
func (m *IndustryMutation) Descr() (r string, exists bool) {
	v := m._Descr
	if v == nil {
		return
	}
	return *v, true
}

// OldDescr returns the old "Descr" field's value of the Industry entity.
// If the Industry object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndustryMutation) OldDescr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescr: %w", err)
	}
	return oldValue.Descr, nil
}

// ResetDescr resets all changes to the "Descr" field.
func (m *IndustryMutation) ResetDescr() {
	m._Descr = nil
}

// AddEmitentIDs adds the "Emitents" edge to the Emitent entity by ids.
func (m *IndustryMutation) AddEmitentIDs(ids ...xid.ID) {
	if m._Emitents == nil {
		m._Emitents = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m._Emitents[ids[i]] = struct{}{}
	}
}

// ClearEmitents clears the "Emitents" edge to the Emitent entity.
func (m *IndustryMutation) ClearEmitents() {
	m.cleared_Emitents = true
}

// EmitentsCleared reports if the "Emitents" edge to the Emitent entity was cleared.
func (m *IndustryMutation) EmitentsCleared() bool {
	return m.cleared_Emitents
}

// RemoveEmitentIDs removes the "Emitents" edge to the Emitent entity by IDs.
func (m *IndustryMutation) RemoveEmitentIDs(ids ...xid.ID) {
	if m.removed_Emitents == nil {
		m.removed_Emitents = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m._Emitents, ids[i])
		m.removed_Emitents[ids[i]] = struct{}{}
	}
}

// RemovedEmitents returns the removed IDs of the "Emitents" edge to the Emitent entity.
func (m *IndustryMutation) RemovedEmitentsIDs() (ids []xid.ID) {
	for id := range m.removed_Emitents {
		ids = append(ids, id)
	}
	return
}

// EmitentsIDs returns the "Emitents" edge IDs in the mutation.
func (m *IndustryMutation) EmitentsIDs() (ids []xid.ID) {
	for id := range m._Emitents {
		ids = append(ids, id)
	}
	return
}

// ResetEmitents resets all changes to the "Emitents" edge.
func (m *IndustryMutation) ResetEmitents() {
	m._Emitents = nil
	m.cleared_Emitents = false
	m.removed_Emitents = nil
}

// Where appends a list predicates to the IndustryMutation builder.
func (m *IndustryMutation) Where(ps ...predicate.Industry) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *IndustryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Industry).
func (m *IndustryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IndustryMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Descr != nil {
		fields = append(fields, industry.FieldDescr)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IndustryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case industry.FieldDescr:
		return m.Descr()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IndustryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case industry.FieldDescr:
		return m.OldDescr(ctx)
	}
	return nil, fmt.Errorf("unknown Industry field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IndustryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case industry.FieldDescr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescr(v)
		return nil
	}
	return fmt.Errorf("unknown Industry field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IndustryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IndustryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IndustryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Industry numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IndustryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IndustryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IndustryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Industry nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IndustryMutation) ResetField(name string) error {
	switch name {
	case industry.FieldDescr:
		m.ResetDescr()
		return nil
	}
	return fmt.Errorf("unknown Industry field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IndustryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Emitents != nil {
		edges = append(edges, industry.EdgeEmitents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IndustryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case industry.EdgeEmitents:
		ids := make([]ent.Value, 0, len(m._Emitents))
		for id := range m._Emitents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IndustryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Emitents != nil {
		edges = append(edges, industry.EdgeEmitents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IndustryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case industry.EdgeEmitents:
		ids := make([]ent.Value, 0, len(m.removed_Emitents))
		for id := range m.removed_Emitents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IndustryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Emitents {
		edges = append(edges, industry.EdgeEmitents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IndustryMutation) EdgeCleared(name string) bool {
	switch name {
	case industry.EdgeEmitents:
		return m.cleared_Emitents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IndustryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Industry unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IndustryMutation) ResetEdge(name string) error {
	switch name {
	case industry.EdgeEmitents:
		m.ResetEmitents()
		return nil
	}
	return fmt.Errorf("unknown Industry edge %s", name)
}

// InvestAccountMutation represents an operation that mutates the InvestAccount nodes in the graph.
type InvestAccountMutation struct {
	config
	op                 Op
	typ                string
	id                 *xid.ID
	_Descr             *string
	clearedFields      map[string]struct{}
	_Owner             *xid.ID
	cleared_Owner      bool
	_Cashflows         map[xid.ID]struct{}
	removed_Cashflows  map[xid.ID]struct{}
	cleared_Cashflows  bool
	_Valuations        map[xid.ID]struct{}
	removed_Valuations map[xid.ID]struct{}
	cleared_Valuations bool
	done               bool
	oldValue           func(context.Context) (*InvestAccount, error)
	predicates         []predicate.InvestAccount
}

var _ ent.Mutation = (*InvestAccountMutation)(nil)

// investaccountOption allows management of the mutation configuration using functional options.
type investaccountOption func(*InvestAccountMutation)

// newInvestAccountMutation creates new mutation for the InvestAccount entity.
func newInvestAccountMutation(c config, op Op, opts ...investaccountOption) *InvestAccountMutation {
	m := &InvestAccountMutation{
		config:        c,
		op:            op,
		typ:           TypeInvestAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvestAccountID sets the ID field of the mutation.
func withInvestAccountID(id xid.ID) investaccountOption {
	return func(m *InvestAccountMutation) {
		var (
			err   error
			once  sync.Once
			value *InvestAccount
		)
		m.oldValue = func(ctx context.Context) (*InvestAccount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvestAccount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvestAccount sets the old InvestAccount of the mutation.
func withInvestAccount(node *InvestAccount) investaccountOption {
	return func(m *InvestAccountMutation) {
		m.oldValue = func(context.Context) (*InvestAccount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvestAccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvestAccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvestAccount entities.
func (m *InvestAccountMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvestAccountMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvestAccountMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvestAccount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescr sets the "Descr" field.
func (m *InvestAccountMutation) SetDescr(s string) {
	m._Descr = &s
}

// Descr returns the value of the "Descr" field in the mutation.
func (m *InvestAccountMutation) Descr() (r string, exists bool) {
	v := m._Descr
	if v == nil {
		return
	}
	return *v, true
}

// OldDescr returns the old "Descr" field's value of the InvestAccount entity.
// If the InvestAccount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestAccountMutation) OldDescr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescr: %w", err)
	}
	return oldValue.Descr, nil
}

// ResetDescr resets all changes to the "Descr" field.
func (m *InvestAccountMutation) ResetDescr() {
	m._Descr = nil
}

// SetOwnerID sets the "Owner" edge to the User entity by id.
func (m *InvestAccountMutation) SetOwnerID(id xid.ID) {
	m._Owner = &id
}

// ClearOwner clears the "Owner" edge to the User entity.
func (m *InvestAccountMutation) ClearOwner() {
	m.cleared_Owner = true
}

// OwnerCleared reports if the "Owner" edge to the User entity was cleared.
func (m *InvestAccountMutation) OwnerCleared() bool {
	return m.cleared_Owner
}

// OwnerID returns the "Owner" edge ID in the mutation.
func (m *InvestAccountMutation) OwnerID() (id xid.ID, exists bool) {
	if m._Owner != nil {
		return *m._Owner, true
	}
	return
}

// OwnerIDs returns the "Owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *InvestAccountMutation) OwnerIDs() (ids []xid.ID) {
	if id := m._Owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "Owner" edge.
func (m *InvestAccountMutation) ResetOwner() {
	m._Owner = nil
	m.cleared_Owner = false
}

// AddCashflowIDs adds the "Cashflows" edge to the InvestAccountCashflow entity by ids.
func (m *InvestAccountMutation) AddCashflowIDs(ids ...xid.ID) {
	if m._Cashflows == nil {
		m._Cashflows = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m._Cashflows[ids[i]] = struct{}{}
	}
}

// ClearCashflows clears the "Cashflows" edge to the InvestAccountCashflow entity.
func (m *InvestAccountMutation) ClearCashflows() {
	m.cleared_Cashflows = true
}

// CashflowsCleared reports if the "Cashflows" edge to the InvestAccountCashflow entity was cleared.
func (m *InvestAccountMutation) CashflowsCleared() bool {
	return m.cleared_Cashflows
}

// RemoveCashflowIDs removes the "Cashflows" edge to the InvestAccountCashflow entity by IDs.
func (m *InvestAccountMutation) RemoveCashflowIDs(ids ...xid.ID) {
	if m.removed_Cashflows == nil {
		m.removed_Cashflows = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m._Cashflows, ids[i])
		m.removed_Cashflows[ids[i]] = struct{}{}
	}
}

// RemovedCashflows returns the removed IDs of the "Cashflows" edge to the InvestAccountCashflow entity.
func (m *InvestAccountMutation) RemovedCashflowsIDs() (ids []xid.ID) {
	for id := range m.removed_Cashflows {
		ids = append(ids, id)
	}
	return
}

// CashflowsIDs returns the "Cashflows" edge IDs in the mutation.
func (m *InvestAccountMutation) CashflowsIDs() (ids []xid.ID) {
	for id := range m._Cashflows {
		ids = append(ids, id)
	}
	return
}

// ResetCashflows resets all changes to the "Cashflows" edge.
func (m *InvestAccountMutation) ResetCashflows() {
	m._Cashflows = nil
	m.cleared_Cashflows = false
	m.removed_Cashflows = nil
}

// AddValuationIDs adds the "Valuations" edge to the InvestAccountValuation entity by ids.
func (m *InvestAccountMutation) AddValuationIDs(ids ...xid.ID) {
	if m._Valuations == nil {
		m._Valuations = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m._Valuations[ids[i]] = struct{}{}
	}
}

// ClearValuations clears the "Valuations" edge to the InvestAccountValuation entity.
func (m *InvestAccountMutation) ClearValuations() {
	m.cleared_Valuations = true
}

// ValuationsCleared reports if the "Valuations" edge to the InvestAccountValuation entity was cleared.
func (m *InvestAccountMutation) ValuationsCleared() bool {
	return m.cleared_Valuations
}

// RemoveValuationIDs removes the "Valuations" edge to the InvestAccountValuation entity by IDs.
func (m *InvestAccountMutation) RemoveValuationIDs(ids ...xid.ID) {
	if m.removed_Valuations == nil {
		m.removed_Valuations = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m._Valuations, ids[i])
		m.removed_Valuations[ids[i]] = struct{}{}
	}
}

// RemovedValuations returns the removed IDs of the "Valuations" edge to the InvestAccountValuation entity.
func (m *InvestAccountMutation) RemovedValuationsIDs() (ids []xid.ID) {
	for id := range m.removed_Valuations {
		ids = append(ids, id)
	}
	return
}

// ValuationsIDs returns the "Valuations" edge IDs in the mutation.
func (m *InvestAccountMutation) ValuationsIDs() (ids []xid.ID) {
	for id := range m._Valuations {
		ids = append(ids, id)
	}
	return
}

// ResetValuations resets all changes to the "Valuations" edge.
func (m *InvestAccountMutation) ResetValuations() {
	m._Valuations = nil
	m.cleared_Valuations = false
	m.removed_Valuations = nil
}

// Where appends a list predicates to the InvestAccountMutation builder.
func (m *InvestAccountMutation) Where(ps ...predicate.InvestAccount) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InvestAccountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InvestAccount).
func (m *InvestAccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvestAccountMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Descr != nil {
		fields = append(fields, investaccount.FieldDescr)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvestAccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case investaccount.FieldDescr:
		return m.Descr()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvestAccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case investaccount.FieldDescr:
		return m.OldDescr(ctx)
	}
	return nil, fmt.Errorf("unknown InvestAccount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvestAccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case investaccount.FieldDescr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescr(v)
		return nil
	}
	return fmt.Errorf("unknown InvestAccount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvestAccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvestAccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvestAccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InvestAccount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvestAccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvestAccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvestAccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InvestAccount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvestAccountMutation) ResetField(name string) error {
	switch name {
	case investaccount.FieldDescr:
		m.ResetDescr()
		return nil
	}
	return fmt.Errorf("unknown InvestAccount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvestAccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._Owner != nil {
		edges = append(edges, investaccount.EdgeOwner)
	}
	if m._Cashflows != nil {
		edges = append(edges, investaccount.EdgeCashflows)
	}
	if m._Valuations != nil {
		edges = append(edges, investaccount.EdgeValuations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvestAccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case investaccount.EdgeOwner:
		if id := m._Owner; id != nil {
			return []ent.Value{*id}
		}
	case investaccount.EdgeCashflows:
		ids := make([]ent.Value, 0, len(m._Cashflows))
		for id := range m._Cashflows {
			ids = append(ids, id)
		}
		return ids
	case investaccount.EdgeValuations:
		ids := make([]ent.Value, 0, len(m._Valuations))
		for id := range m._Valuations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvestAccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_Cashflows != nil {
		edges = append(edges, investaccount.EdgeCashflows)
	}
	if m.removed_Valuations != nil {
		edges = append(edges, investaccount.EdgeValuations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvestAccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case investaccount.EdgeCashflows:
		ids := make([]ent.Value, 0, len(m.removed_Cashflows))
		for id := range m.removed_Cashflows {
			ids = append(ids, id)
		}
		return ids
	case investaccount.EdgeValuations:
		ids := make([]ent.Value, 0, len(m.removed_Valuations))
		for id := range m.removed_Valuations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvestAccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_Owner {
		edges = append(edges, investaccount.EdgeOwner)
	}
	if m.cleared_Cashflows {
		edges = append(edges, investaccount.EdgeCashflows)
	}
	if m.cleared_Valuations {
		edges = append(edges, investaccount.EdgeValuations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvestAccountMutation) EdgeCleared(name string) bool {
	switch name {
	case investaccount.EdgeOwner:
		return m.cleared_Owner
	case investaccount.EdgeCashflows:
		return m.cleared_Cashflows
	case investaccount.EdgeValuations:
		return m.cleared_Valuations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvestAccountMutation) ClearEdge(name string) error {
	switch name {
	case investaccount.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown InvestAccount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvestAccountMutation) ResetEdge(name string) error {
	switch name {
	case investaccount.EdgeOwner:
		m.ResetOwner()
		return nil
	case investaccount.EdgeCashflows:
		m.ResetCashflows()
		return nil
	case investaccount.EdgeValuations:
		m.ResetValuations()
		return nil
	}
	return fmt.Errorf("unknown InvestAccount edge %s", name)
}

// InvestAccountCashflowMutation represents an operation that mutates the InvestAccountCashflow nodes in the graph.
type InvestAccountCashflowMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	_RecDate      *time.Time
	_Qty          *float64
	add_Qty       *float64
	clearedFields map[string]struct{}
	_Owner        *xid.ID
	cleared_Owner bool
	done          bool
	oldValue      func(context.Context) (*InvestAccountCashflow, error)
	predicates    []predicate.InvestAccountCashflow
}

var _ ent.Mutation = (*InvestAccountCashflowMutation)(nil)

// investaccountcashflowOption allows management of the mutation configuration using functional options.
type investaccountcashflowOption func(*InvestAccountCashflowMutation)

// newInvestAccountCashflowMutation creates new mutation for the InvestAccountCashflow entity.
func newInvestAccountCashflowMutation(c config, op Op, opts ...investaccountcashflowOption) *InvestAccountCashflowMutation {
	m := &InvestAccountCashflowMutation{
		config:        c,
		op:            op,
		typ:           TypeInvestAccountCashflow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvestAccountCashflowID sets the ID field of the mutation.
func withInvestAccountCashflowID(id xid.ID) investaccountcashflowOption {
	return func(m *InvestAccountCashflowMutation) {
		var (
			err   error
			once  sync.Once
			value *InvestAccountCashflow
		)
		m.oldValue = func(ctx context.Context) (*InvestAccountCashflow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvestAccountCashflow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvestAccountCashflow sets the old InvestAccountCashflow of the mutation.
func withInvestAccountCashflow(node *InvestAccountCashflow) investaccountcashflowOption {
	return func(m *InvestAccountCashflowMutation) {
		m.oldValue = func(context.Context) (*InvestAccountCashflow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvestAccountCashflowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvestAccountCashflowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvestAccountCashflow entities.
func (m *InvestAccountCashflowMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvestAccountCashflowMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvestAccountCashflowMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvestAccountCashflow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRecDate sets the "RecDate" field.
func (m *InvestAccountCashflowMutation) SetRecDate(t time.Time) {
	m._RecDate = &t
}

// RecDate returns the value of the "RecDate" field in the mutation.
func (m *InvestAccountCashflowMutation) RecDate() (r time.Time, exists bool) {
	v := m._RecDate
	if v == nil {
		return
	}
	return *v, true
}

// OldRecDate returns the old "RecDate" field's value of the InvestAccountCashflow entity.
// If the InvestAccountCashflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestAccountCashflowMutation) OldRecDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecDate: %w", err)
	}
	return oldValue.RecDate, nil
}

// ResetRecDate resets all changes to the "RecDate" field.
func (m *InvestAccountCashflowMutation) ResetRecDate() {
	m._RecDate = nil
}

// SetQty sets the "Qty" field.
func (m *InvestAccountCashflowMutation) SetQty(f float64) {
	m._Qty = &f
	m.add_Qty = nil
}

// Qty returns the value of the "Qty" field in the mutation.
func (m *InvestAccountCashflowMutation) Qty() (r float64, exists bool) {
	v := m._Qty
	if v == nil {
		return
	}
	return *v, true
}

// OldQty returns the old "Qty" field's value of the InvestAccountCashflow entity.
// If the InvestAccountCashflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestAccountCashflowMutation) OldQty(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQty: %w", err)
	}
	return oldValue.Qty, nil
}

// AddQty adds f to the "Qty" field.
func (m *InvestAccountCashflowMutation) AddQty(f float64) {
	if m.add_Qty != nil {
		*m.add_Qty += f
	} else {
		m.add_Qty = &f
	}
}

// AddedQty returns the value that was added to the "Qty" field in this mutation.
func (m *InvestAccountCashflowMutation) AddedQty() (r float64, exists bool) {
	v := m.add_Qty
	if v == nil {
		return
	}
	return *v, true
}

// ResetQty resets all changes to the "Qty" field.
func (m *InvestAccountCashflowMutation) ResetQty() {
	m._Qty = nil
	m.add_Qty = nil
}

// SetOwnerID sets the "Owner" edge to the InvestAccount entity by id.
func (m *InvestAccountCashflowMutation) SetOwnerID(id xid.ID) {
	m._Owner = &id
}

// ClearOwner clears the "Owner" edge to the InvestAccount entity.
func (m *InvestAccountCashflowMutation) ClearOwner() {
	m.cleared_Owner = true
}

// OwnerCleared reports if the "Owner" edge to the InvestAccount entity was cleared.
func (m *InvestAccountCashflowMutation) OwnerCleared() bool {
	return m.cleared_Owner
}

// OwnerID returns the "Owner" edge ID in the mutation.
func (m *InvestAccountCashflowMutation) OwnerID() (id xid.ID, exists bool) {
	if m._Owner != nil {
		return *m._Owner, true
	}
	return
}

// OwnerIDs returns the "Owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *InvestAccountCashflowMutation) OwnerIDs() (ids []xid.ID) {
	if id := m._Owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "Owner" edge.
func (m *InvestAccountCashflowMutation) ResetOwner() {
	m._Owner = nil
	m.cleared_Owner = false
}

// Where appends a list predicates to the InvestAccountCashflowMutation builder.
func (m *InvestAccountCashflowMutation) Where(ps ...predicate.InvestAccountCashflow) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InvestAccountCashflowMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InvestAccountCashflow).
func (m *InvestAccountCashflowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvestAccountCashflowMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._RecDate != nil {
		fields = append(fields, investaccountcashflow.FieldRecDate)
	}
	if m._Qty != nil {
		fields = append(fields, investaccountcashflow.FieldQty)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvestAccountCashflowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case investaccountcashflow.FieldRecDate:
		return m.RecDate()
	case investaccountcashflow.FieldQty:
		return m.Qty()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvestAccountCashflowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case investaccountcashflow.FieldRecDate:
		return m.OldRecDate(ctx)
	case investaccountcashflow.FieldQty:
		return m.OldQty(ctx)
	}
	return nil, fmt.Errorf("unknown InvestAccountCashflow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvestAccountCashflowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case investaccountcashflow.FieldRecDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecDate(v)
		return nil
	case investaccountcashflow.FieldQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQty(v)
		return nil
	}
	return fmt.Errorf("unknown InvestAccountCashflow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvestAccountCashflowMutation) AddedFields() []string {
	var fields []string
	if m.add_Qty != nil {
		fields = append(fields, investaccountcashflow.FieldQty)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvestAccountCashflowMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case investaccountcashflow.FieldQty:
		return m.AddedQty()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvestAccountCashflowMutation) AddField(name string, value ent.Value) error {
	switch name {
	case investaccountcashflow.FieldQty:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQty(v)
		return nil
	}
	return fmt.Errorf("unknown InvestAccountCashflow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvestAccountCashflowMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvestAccountCashflowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvestAccountCashflowMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InvestAccountCashflow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvestAccountCashflowMutation) ResetField(name string) error {
	switch name {
	case investaccountcashflow.FieldRecDate:
		m.ResetRecDate()
		return nil
	case investaccountcashflow.FieldQty:
		m.ResetQty()
		return nil
	}
	return fmt.Errorf("unknown InvestAccountCashflow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvestAccountCashflowMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Owner != nil {
		edges = append(edges, investaccountcashflow.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvestAccountCashflowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case investaccountcashflow.EdgeOwner:
		if id := m._Owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvestAccountCashflowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvestAccountCashflowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvestAccountCashflowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Owner {
		edges = append(edges, investaccountcashflow.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvestAccountCashflowMutation) EdgeCleared(name string) bool {
	switch name {
	case investaccountcashflow.EdgeOwner:
		return m.cleared_Owner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvestAccountCashflowMutation) ClearEdge(name string) error {
	switch name {
	case investaccountcashflow.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown InvestAccountCashflow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvestAccountCashflowMutation) ResetEdge(name string) error {
	switch name {
	case investaccountcashflow.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown InvestAccountCashflow edge %s", name)
}

// InvestAccountValuationMutation represents an operation that mutates the InvestAccountValuation nodes in the graph.
type InvestAccountValuationMutation struct {
	config
	op            Op
	typ           string
	id            *xid.ID
	_RecDate      *time.Time
	_Value        *float64
	add_Value     *float64
	clearedFields map[string]struct{}
	_Owner        *xid.ID
	cleared_Owner bool
	done          bool
	oldValue      func(context.Context) (*InvestAccountValuation, error)
	predicates    []predicate.InvestAccountValuation
}

var _ ent.Mutation = (*InvestAccountValuationMutation)(nil)

// investaccountvaluationOption allows management of the mutation configuration using functional options.
type investaccountvaluationOption func(*InvestAccountValuationMutation)

// newInvestAccountValuationMutation creates new mutation for the InvestAccountValuation entity.
func newInvestAccountValuationMutation(c config, op Op, opts ...investaccountvaluationOption) *InvestAccountValuationMutation {
	m := &InvestAccountValuationMutation{
		config:        c,
		op:            op,
		typ:           TypeInvestAccountValuation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvestAccountValuationID sets the ID field of the mutation.
func withInvestAccountValuationID(id xid.ID) investaccountvaluationOption {
	return func(m *InvestAccountValuationMutation) {
		var (
			err   error
			once  sync.Once
			value *InvestAccountValuation
		)
		m.oldValue = func(ctx context.Context) (*InvestAccountValuation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InvestAccountValuation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvestAccountValuation sets the old InvestAccountValuation of the mutation.
func withInvestAccountValuation(node *InvestAccountValuation) investaccountvaluationOption {
	return func(m *InvestAccountValuationMutation) {
		m.oldValue = func(context.Context) (*InvestAccountValuation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvestAccountValuationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvestAccountValuationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InvestAccountValuation entities.
func (m *InvestAccountValuationMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvestAccountValuationMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvestAccountValuationMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InvestAccountValuation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRecDate sets the "RecDate" field.
func (m *InvestAccountValuationMutation) SetRecDate(t time.Time) {
	m._RecDate = &t
}

// RecDate returns the value of the "RecDate" field in the mutation.
func (m *InvestAccountValuationMutation) RecDate() (r time.Time, exists bool) {
	v := m._RecDate
	if v == nil {
		return
	}
	return *v, true
}

// OldRecDate returns the old "RecDate" field's value of the InvestAccountValuation entity.
// If the InvestAccountValuation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestAccountValuationMutation) OldRecDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecDate: %w", err)
	}
	return oldValue.RecDate, nil
}

// ResetRecDate resets all changes to the "RecDate" field.
func (m *InvestAccountValuationMutation) ResetRecDate() {
	m._RecDate = nil
}

// SetValue sets the "Value" field.
func (m *InvestAccountValuationMutation) SetValue(f float64) {
	m._Value = &f
	m.add_Value = nil
}

// Value returns the value of the "Value" field in the mutation.
func (m *InvestAccountValuationMutation) Value() (r float64, exists bool) {
	v := m._Value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "Value" field's value of the InvestAccountValuation entity.
// If the InvestAccountValuation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvestAccountValuationMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "Value" field.
func (m *InvestAccountValuationMutation) AddValue(f float64) {
	if m.add_Value != nil {
		*m.add_Value += f
	} else {
		m.add_Value = &f
	}
}

// AddedValue returns the value that was added to the "Value" field in this mutation.
func (m *InvestAccountValuationMutation) AddedValue() (r float64, exists bool) {
	v := m.add_Value
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "Value" field.
func (m *InvestAccountValuationMutation) ResetValue() {
	m._Value = nil
	m.add_Value = nil
}

// SetOwnerID sets the "Owner" edge to the InvestAccount entity by id.
func (m *InvestAccountValuationMutation) SetOwnerID(id xid.ID) {
	m._Owner = &id
}

// ClearOwner clears the "Owner" edge to the InvestAccount entity.
func (m *InvestAccountValuationMutation) ClearOwner() {
	m.cleared_Owner = true
}

// OwnerCleared reports if the "Owner" edge to the InvestAccount entity was cleared.
func (m *InvestAccountValuationMutation) OwnerCleared() bool {
	return m.cleared_Owner
}

// OwnerID returns the "Owner" edge ID in the mutation.
func (m *InvestAccountValuationMutation) OwnerID() (id xid.ID, exists bool) {
	if m._Owner != nil {
		return *m._Owner, true
	}
	return
}

// OwnerIDs returns the "Owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *InvestAccountValuationMutation) OwnerIDs() (ids []xid.ID) {
	if id := m._Owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "Owner" edge.
func (m *InvestAccountValuationMutation) ResetOwner() {
	m._Owner = nil
	m.cleared_Owner = false
}

// Where appends a list predicates to the InvestAccountValuationMutation builder.
func (m *InvestAccountValuationMutation) Where(ps ...predicate.InvestAccountValuation) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InvestAccountValuationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InvestAccountValuation).
func (m *InvestAccountValuationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvestAccountValuationMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._RecDate != nil {
		fields = append(fields, investaccountvaluation.FieldRecDate)
	}
	if m._Value != nil {
		fields = append(fields, investaccountvaluation.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvestAccountValuationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case investaccountvaluation.FieldRecDate:
		return m.RecDate()
	case investaccountvaluation.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvestAccountValuationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case investaccountvaluation.FieldRecDate:
		return m.OldRecDate(ctx)
	case investaccountvaluation.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown InvestAccountValuation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvestAccountValuationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case investaccountvaluation.FieldRecDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecDate(v)
		return nil
	case investaccountvaluation.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown InvestAccountValuation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvestAccountValuationMutation) AddedFields() []string {
	var fields []string
	if m.add_Value != nil {
		fields = append(fields, investaccountvaluation.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvestAccountValuationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case investaccountvaluation.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvestAccountValuationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case investaccountvaluation.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown InvestAccountValuation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvestAccountValuationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvestAccountValuationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvestAccountValuationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown InvestAccountValuation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvestAccountValuationMutation) ResetField(name string) error {
	switch name {
	case investaccountvaluation.FieldRecDate:
		m.ResetRecDate()
		return nil
	case investaccountvaluation.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown InvestAccountValuation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvestAccountValuationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Owner != nil {
		edges = append(edges, investaccountvaluation.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvestAccountValuationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case investaccountvaluation.EdgeOwner:
		if id := m._Owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvestAccountValuationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvestAccountValuationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvestAccountValuationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Owner {
		edges = append(edges, investaccountvaluation.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvestAccountValuationMutation) EdgeCleared(name string) bool {
	switch name {
	case investaccountvaluation.EdgeOwner:
		return m.cleared_Owner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvestAccountValuationMutation) ClearEdge(name string) error {
	switch name {
	case investaccountvaluation.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown InvestAccountValuation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvestAccountValuationMutation) ResetEdge(name string) error {
	switch name {
	case investaccountvaluation.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown InvestAccountValuation edge %s", name)
}

// QuoteMutation represents an operation that mutates the Quote nodes in the graph.
type QuoteMutation struct {
	config
	op             Op
	typ            string
	id             *xid.ID
	_D             *time.Time
	_O             *float64
	add_O          *float64
	_C             *float64
	add_C          *float64
	_H             *float64
	add_H          *float64
	_L             *float64
	add_L          *float64
	_V             *float64
	add_V          *float64
	clearedFields  map[string]struct{}
	_Ticker        *string
	cleared_Ticker bool
	done           bool
	oldValue       func(context.Context) (*Quote, error)
	predicates     []predicate.Quote
}

var _ ent.Mutation = (*QuoteMutation)(nil)

// quoteOption allows management of the mutation configuration using functional options.
type quoteOption func(*QuoteMutation)

// newQuoteMutation creates new mutation for the Quote entity.
func newQuoteMutation(c config, op Op, opts ...quoteOption) *QuoteMutation {
	m := &QuoteMutation{
		config:        c,
		op:            op,
		typ:           TypeQuote,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withQuoteID sets the ID field of the mutation.
func withQuoteID(id xid.ID) quoteOption {
	return func(m *QuoteMutation) {
		var (
			err   error
			once  sync.Once
			value *Quote
		)
		m.oldValue = func(ctx context.Context) (*Quote, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Quote.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withQuote sets the old Quote of the mutation.
func withQuote(node *Quote) quoteOption {
	return func(m *QuoteMutation) {
		m.oldValue = func(context.Context) (*Quote, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m QuoteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m QuoteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Quote entities.
func (m *QuoteMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *QuoteMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *QuoteMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Quote.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetD sets the "D" field.
func (m *QuoteMutation) SetD(t time.Time) {
	m._D = &t
}

// D returns the value of the "D" field in the mutation.
func (m *QuoteMutation) D() (r time.Time, exists bool) {
	v := m._D
	if v == nil {
		return
	}
	return *v, true
}

// OldD returns the old "D" field's value of the Quote entity.
// If the Quote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuoteMutation) OldD(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldD is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldD requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldD: %w", err)
	}
	return oldValue.D, nil
}

// ResetD resets all changes to the "D" field.
func (m *QuoteMutation) ResetD() {
	m._D = nil
}

// SetO sets the "O" field.
func (m *QuoteMutation) SetO(f float64) {
	m._O = &f
	m.add_O = nil
}

// O returns the value of the "O" field in the mutation.
func (m *QuoteMutation) O() (r float64, exists bool) {
	v := m._O
	if v == nil {
		return
	}
	return *v, true
}

// OldO returns the old "O" field's value of the Quote entity.
// If the Quote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuoteMutation) OldO(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldO is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldO requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldO: %w", err)
	}
	return oldValue.O, nil
}

// AddO adds f to the "O" field.
func (m *QuoteMutation) AddO(f float64) {
	if m.add_O != nil {
		*m.add_O += f
	} else {
		m.add_O = &f
	}
}

// AddedO returns the value that was added to the "O" field in this mutation.
func (m *QuoteMutation) AddedO() (r float64, exists bool) {
	v := m.add_O
	if v == nil {
		return
	}
	return *v, true
}

// ResetO resets all changes to the "O" field.
func (m *QuoteMutation) ResetO() {
	m._O = nil
	m.add_O = nil
}

// SetC sets the "C" field.
func (m *QuoteMutation) SetC(f float64) {
	m._C = &f
	m.add_C = nil
}

// C returns the value of the "C" field in the mutation.
func (m *QuoteMutation) C() (r float64, exists bool) {
	v := m._C
	if v == nil {
		return
	}
	return *v, true
}

// OldC returns the old "C" field's value of the Quote entity.
// If the Quote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuoteMutation) OldC(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldC: %w", err)
	}
	return oldValue.C, nil
}

// AddC adds f to the "C" field.
func (m *QuoteMutation) AddC(f float64) {
	if m.add_C != nil {
		*m.add_C += f
	} else {
		m.add_C = &f
	}
}

// AddedC returns the value that was added to the "C" field in this mutation.
func (m *QuoteMutation) AddedC() (r float64, exists bool) {
	v := m.add_C
	if v == nil {
		return
	}
	return *v, true
}

// ResetC resets all changes to the "C" field.
func (m *QuoteMutation) ResetC() {
	m._C = nil
	m.add_C = nil
}

// SetH sets the "H" field.
func (m *QuoteMutation) SetH(f float64) {
	m._H = &f
	m.add_H = nil
}

// H returns the value of the "H" field in the mutation.
func (m *QuoteMutation) H() (r float64, exists bool) {
	v := m._H
	if v == nil {
		return
	}
	return *v, true
}

// OldH returns the old "H" field's value of the Quote entity.
// If the Quote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuoteMutation) OldH(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldH is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldH requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldH: %w", err)
	}
	return oldValue.H, nil
}

// AddH adds f to the "H" field.
func (m *QuoteMutation) AddH(f float64) {
	if m.add_H != nil {
		*m.add_H += f
	} else {
		m.add_H = &f
	}
}

// AddedH returns the value that was added to the "H" field in this mutation.
func (m *QuoteMutation) AddedH() (r float64, exists bool) {
	v := m.add_H
	if v == nil {
		return
	}
	return *v, true
}

// ResetH resets all changes to the "H" field.
func (m *QuoteMutation) ResetH() {
	m._H = nil
	m.add_H = nil
}

// SetL sets the "L" field.
func (m *QuoteMutation) SetL(f float64) {
	m._L = &f
	m.add_L = nil
}

// L returns the value of the "L" field in the mutation.
func (m *QuoteMutation) L() (r float64, exists bool) {
	v := m._L
	if v == nil {
		return
	}
	return *v, true
}

// OldL returns the old "L" field's value of the Quote entity.
// If the Quote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuoteMutation) OldL(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldL: %w", err)
	}
	return oldValue.L, nil
}

// AddL adds f to the "L" field.
func (m *QuoteMutation) AddL(f float64) {
	if m.add_L != nil {
		*m.add_L += f
	} else {
		m.add_L = &f
	}
}

// AddedL returns the value that was added to the "L" field in this mutation.
func (m *QuoteMutation) AddedL() (r float64, exists bool) {
	v := m.add_L
	if v == nil {
		return
	}
	return *v, true
}

// ResetL resets all changes to the "L" field.
func (m *QuoteMutation) ResetL() {
	m._L = nil
	m.add_L = nil
}

// SetV sets the "V" field.
func (m *QuoteMutation) SetV(f float64) {
	m._V = &f
	m.add_V = nil
}

// V returns the value of the "V" field in the mutation.
func (m *QuoteMutation) V() (r float64, exists bool) {
	v := m._V
	if v == nil {
		return
	}
	return *v, true
}

// OldV returns the old "V" field's value of the Quote entity.
// If the Quote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *QuoteMutation) OldV(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldV is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldV requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldV: %w", err)
	}
	return oldValue.V, nil
}

// AddV adds f to the "V" field.
func (m *QuoteMutation) AddV(f float64) {
	if m.add_V != nil {
		*m.add_V += f
	} else {
		m.add_V = &f
	}
}

// AddedV returns the value that was added to the "V" field in this mutation.
func (m *QuoteMutation) AddedV() (r float64, exists bool) {
	v := m.add_V
	if v == nil {
		return
	}
	return *v, true
}

// ResetV resets all changes to the "V" field.
func (m *QuoteMutation) ResetV() {
	m._V = nil
	m.add_V = nil
}

// SetTickerID sets the "Ticker" edge to the Ticker entity by id.
func (m *QuoteMutation) SetTickerID(id string) {
	m._Ticker = &id
}

// ClearTicker clears the "Ticker" edge to the Ticker entity.
func (m *QuoteMutation) ClearTicker() {
	m.cleared_Ticker = true
}

// TickerCleared reports if the "Ticker" edge to the Ticker entity was cleared.
func (m *QuoteMutation) TickerCleared() bool {
	return m.cleared_Ticker
}

// TickerID returns the "Ticker" edge ID in the mutation.
func (m *QuoteMutation) TickerID() (id string, exists bool) {
	if m._Ticker != nil {
		return *m._Ticker, true
	}
	return
}

// TickerIDs returns the "Ticker" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TickerID instead. It exists only for internal usage by the builders.
func (m *QuoteMutation) TickerIDs() (ids []string) {
	if id := m._Ticker; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTicker resets all changes to the "Ticker" edge.
func (m *QuoteMutation) ResetTicker() {
	m._Ticker = nil
	m.cleared_Ticker = false
}

// Where appends a list predicates to the QuoteMutation builder.
func (m *QuoteMutation) Where(ps ...predicate.Quote) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *QuoteMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Quote).
func (m *QuoteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *QuoteMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._D != nil {
		fields = append(fields, quote.FieldD)
	}
	if m._O != nil {
		fields = append(fields, quote.FieldO)
	}
	if m._C != nil {
		fields = append(fields, quote.FieldC)
	}
	if m._H != nil {
		fields = append(fields, quote.FieldH)
	}
	if m._L != nil {
		fields = append(fields, quote.FieldL)
	}
	if m._V != nil {
		fields = append(fields, quote.FieldV)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *QuoteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case quote.FieldD:
		return m.D()
	case quote.FieldO:
		return m.O()
	case quote.FieldC:
		return m.C()
	case quote.FieldH:
		return m.H()
	case quote.FieldL:
		return m.L()
	case quote.FieldV:
		return m.V()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *QuoteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case quote.FieldD:
		return m.OldD(ctx)
	case quote.FieldO:
		return m.OldO(ctx)
	case quote.FieldC:
		return m.OldC(ctx)
	case quote.FieldH:
		return m.OldH(ctx)
	case quote.FieldL:
		return m.OldL(ctx)
	case quote.FieldV:
		return m.OldV(ctx)
	}
	return nil, fmt.Errorf("unknown Quote field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuoteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case quote.FieldD:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetD(v)
		return nil
	case quote.FieldO:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetO(v)
		return nil
	case quote.FieldC:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetC(v)
		return nil
	case quote.FieldH:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetH(v)
		return nil
	case quote.FieldL:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetL(v)
		return nil
	case quote.FieldV:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetV(v)
		return nil
	}
	return fmt.Errorf("unknown Quote field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *QuoteMutation) AddedFields() []string {
	var fields []string
	if m.add_O != nil {
		fields = append(fields, quote.FieldO)
	}
	if m.add_C != nil {
		fields = append(fields, quote.FieldC)
	}
	if m.add_H != nil {
		fields = append(fields, quote.FieldH)
	}
	if m.add_L != nil {
		fields = append(fields, quote.FieldL)
	}
	if m.add_V != nil {
		fields = append(fields, quote.FieldV)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *QuoteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case quote.FieldO:
		return m.AddedO()
	case quote.FieldC:
		return m.AddedC()
	case quote.FieldH:
		return m.AddedH()
	case quote.FieldL:
		return m.AddedL()
	case quote.FieldV:
		return m.AddedV()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *QuoteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case quote.FieldO:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddO(v)
		return nil
	case quote.FieldC:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddC(v)
		return nil
	case quote.FieldH:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddH(v)
		return nil
	case quote.FieldL:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddL(v)
		return nil
	case quote.FieldV:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddV(v)
		return nil
	}
	return fmt.Errorf("unknown Quote numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *QuoteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *QuoteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *QuoteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Quote nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *QuoteMutation) ResetField(name string) error {
	switch name {
	case quote.FieldD:
		m.ResetD()
		return nil
	case quote.FieldO:
		m.ResetO()
		return nil
	case quote.FieldC:
		m.ResetC()
		return nil
	case quote.FieldH:
		m.ResetH()
		return nil
	case quote.FieldL:
		m.ResetL()
		return nil
	case quote.FieldV:
		m.ResetV()
		return nil
	}
	return fmt.Errorf("unknown Quote field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *QuoteMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Ticker != nil {
		edges = append(edges, quote.EdgeTicker)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *QuoteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case quote.EdgeTicker:
		if id := m._Ticker; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *QuoteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *QuoteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *QuoteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Ticker {
		edges = append(edges, quote.EdgeTicker)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *QuoteMutation) EdgeCleared(name string) bool {
	switch name {
	case quote.EdgeTicker:
		return m.cleared_Ticker
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *QuoteMutation) ClearEdge(name string) error {
	switch name {
	case quote.EdgeTicker:
		m.ClearTicker()
		return nil
	}
	return fmt.Errorf("unknown Quote unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *QuoteMutation) ResetEdge(name string) error {
	switch name {
	case quote.EdgeTicker:
		m.ResetTicker()
		return nil
	}
	return fmt.Errorf("unknown Quote edge %s", name)
}

// ReportMutation represents an operation that mutates the Report nodes in the graph.
type ReportMutation struct {
	config
	op                             Op
	typ                            string
	id                             *xid.ID
	_ReportYear                    *int
	add_ReportYear                 *int
	_ReportQuarter                 *int
	add_ReportQuarter              *int
	_ReportDate                    *time.Time
	_PnlRevenueYtd                 *float64
	add_PnlRevenueYtd              *float64
	_PnlAmortizationYtd            *float64
	add_PnlAmortizationYtd         *float64
	_PnlOperatingIncomeYtd         *float64
	add_PnlOperatingIncomeYtd      *float64
	_PnlInterestIncomeYtd          *float64
	add_PnlInterestIncomeYtd       *float64
	_PnlInterestExpensesYtd        *float64
	add_PnlInterestExpensesYtd     *float64
	_PnlIncomeTaxYtd               *float64
	add_PnlIncomeTaxYtd            *float64
	_PnlNetIncomeYtd               *float64
	add_PnlNetIncomeYtd            *float64
	_CfCashSld                     *float64
	add_CfCashSld                  *float64
	_CfNonCurrentLiabilitiesSld    *float64
	add_CfNonCurrentLiabilitiesSld *float64
	_CfCurrentLiabilitesSld        *float64
	add_CfCurrentLiabilitesSld     *float64
	_CfNonControllingSld           *float64
	add_CfNonControllingSld        *float64
	_CfEquitySld                   *float64
	add_CfEquitySld                *float64
	_CfTotalSld                    *float64
	add_CfTotalSld                 *float64
	_Url                           *string
	clearedFields                  map[string]struct{}
	_Emitent                       *xid.ID
	cleared_Emitent                bool
	done                           bool
	oldValue                       func(context.Context) (*Report, error)
	predicates                     []predicate.Report
}

var _ ent.Mutation = (*ReportMutation)(nil)

// reportOption allows management of the mutation configuration using functional options.
type reportOption func(*ReportMutation)

// newReportMutation creates new mutation for the Report entity.
func newReportMutation(c config, op Op, opts ...reportOption) *ReportMutation {
	m := &ReportMutation{
		config:        c,
		op:            op,
		typ:           TypeReport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReportID sets the ID field of the mutation.
func withReportID(id xid.ID) reportOption {
	return func(m *ReportMutation) {
		var (
			err   error
			once  sync.Once
			value *Report
		)
		m.oldValue = func(ctx context.Context) (*Report, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Report.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReport sets the old Report of the mutation.
func withReport(node *Report) reportOption {
	return func(m *ReportMutation) {
		m.oldValue = func(context.Context) (*Report, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Report entities.
func (m *ReportMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReportMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReportMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Report.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetReportYear sets the "ReportYear" field.
func (m *ReportMutation) SetReportYear(i int) {
	m._ReportYear = &i
	m.add_ReportYear = nil
}

// ReportYear returns the value of the "ReportYear" field in the mutation.
func (m *ReportMutation) ReportYear() (r int, exists bool) {
	v := m._ReportYear
	if v == nil {
		return
	}
	return *v, true
}

// OldReportYear returns the old "ReportYear" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldReportYear(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportYear: %w", err)
	}
	return oldValue.ReportYear, nil
}

// AddReportYear adds i to the "ReportYear" field.
func (m *ReportMutation) AddReportYear(i int) {
	if m.add_ReportYear != nil {
		*m.add_ReportYear += i
	} else {
		m.add_ReportYear = &i
	}
}

// AddedReportYear returns the value that was added to the "ReportYear" field in this mutation.
func (m *ReportMutation) AddedReportYear() (r int, exists bool) {
	v := m.add_ReportYear
	if v == nil {
		return
	}
	return *v, true
}

// ResetReportYear resets all changes to the "ReportYear" field.
func (m *ReportMutation) ResetReportYear() {
	m._ReportYear = nil
	m.add_ReportYear = nil
}

// SetReportQuarter sets the "ReportQuarter" field.
func (m *ReportMutation) SetReportQuarter(i int) {
	m._ReportQuarter = &i
	m.add_ReportQuarter = nil
}

// ReportQuarter returns the value of the "ReportQuarter" field in the mutation.
func (m *ReportMutation) ReportQuarter() (r int, exists bool) {
	v := m._ReportQuarter
	if v == nil {
		return
	}
	return *v, true
}

// OldReportQuarter returns the old "ReportQuarter" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldReportQuarter(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportQuarter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportQuarter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportQuarter: %w", err)
	}
	return oldValue.ReportQuarter, nil
}

// AddReportQuarter adds i to the "ReportQuarter" field.
func (m *ReportMutation) AddReportQuarter(i int) {
	if m.add_ReportQuarter != nil {
		*m.add_ReportQuarter += i
	} else {
		m.add_ReportQuarter = &i
	}
}

// AddedReportQuarter returns the value that was added to the "ReportQuarter" field in this mutation.
func (m *ReportMutation) AddedReportQuarter() (r int, exists bool) {
	v := m.add_ReportQuarter
	if v == nil {
		return
	}
	return *v, true
}

// ResetReportQuarter resets all changes to the "ReportQuarter" field.
func (m *ReportMutation) ResetReportQuarter() {
	m._ReportQuarter = nil
	m.add_ReportQuarter = nil
}

// SetReportDate sets the "ReportDate" field.
func (m *ReportMutation) SetReportDate(t time.Time) {
	m._ReportDate = &t
}

// ReportDate returns the value of the "ReportDate" field in the mutation.
func (m *ReportMutation) ReportDate() (r time.Time, exists bool) {
	v := m._ReportDate
	if v == nil {
		return
	}
	return *v, true
}

// OldReportDate returns the old "ReportDate" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldReportDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReportDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReportDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReportDate: %w", err)
	}
	return oldValue.ReportDate, nil
}

// ResetReportDate resets all changes to the "ReportDate" field.
func (m *ReportMutation) ResetReportDate() {
	m._ReportDate = nil
}

// SetPnlRevenueYtd sets the "PnlRevenueYtd" field.
func (m *ReportMutation) SetPnlRevenueYtd(f float64) {
	m._PnlRevenueYtd = &f
	m.add_PnlRevenueYtd = nil
}

// PnlRevenueYtd returns the value of the "PnlRevenueYtd" field in the mutation.
func (m *ReportMutation) PnlRevenueYtd() (r float64, exists bool) {
	v := m._PnlRevenueYtd
	if v == nil {
		return
	}
	return *v, true
}

// OldPnlRevenueYtd returns the old "PnlRevenueYtd" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldPnlRevenueYtd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPnlRevenueYtd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPnlRevenueYtd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPnlRevenueYtd: %w", err)
	}
	return oldValue.PnlRevenueYtd, nil
}

// AddPnlRevenueYtd adds f to the "PnlRevenueYtd" field.
func (m *ReportMutation) AddPnlRevenueYtd(f float64) {
	if m.add_PnlRevenueYtd != nil {
		*m.add_PnlRevenueYtd += f
	} else {
		m.add_PnlRevenueYtd = &f
	}
}

// AddedPnlRevenueYtd returns the value that was added to the "PnlRevenueYtd" field in this mutation.
func (m *ReportMutation) AddedPnlRevenueYtd() (r float64, exists bool) {
	v := m.add_PnlRevenueYtd
	if v == nil {
		return
	}
	return *v, true
}

// ResetPnlRevenueYtd resets all changes to the "PnlRevenueYtd" field.
func (m *ReportMutation) ResetPnlRevenueYtd() {
	m._PnlRevenueYtd = nil
	m.add_PnlRevenueYtd = nil
}

// SetPnlAmortizationYtd sets the "PnlAmortizationYtd" field.
func (m *ReportMutation) SetPnlAmortizationYtd(f float64) {
	m._PnlAmortizationYtd = &f
	m.add_PnlAmortizationYtd = nil
}

// PnlAmortizationYtd returns the value of the "PnlAmortizationYtd" field in the mutation.
func (m *ReportMutation) PnlAmortizationYtd() (r float64, exists bool) {
	v := m._PnlAmortizationYtd
	if v == nil {
		return
	}
	return *v, true
}

// OldPnlAmortizationYtd returns the old "PnlAmortizationYtd" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldPnlAmortizationYtd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPnlAmortizationYtd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPnlAmortizationYtd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPnlAmortizationYtd: %w", err)
	}
	return oldValue.PnlAmortizationYtd, nil
}

// AddPnlAmortizationYtd adds f to the "PnlAmortizationYtd" field.
func (m *ReportMutation) AddPnlAmortizationYtd(f float64) {
	if m.add_PnlAmortizationYtd != nil {
		*m.add_PnlAmortizationYtd += f
	} else {
		m.add_PnlAmortizationYtd = &f
	}
}

// AddedPnlAmortizationYtd returns the value that was added to the "PnlAmortizationYtd" field in this mutation.
func (m *ReportMutation) AddedPnlAmortizationYtd() (r float64, exists bool) {
	v := m.add_PnlAmortizationYtd
	if v == nil {
		return
	}
	return *v, true
}

// ResetPnlAmortizationYtd resets all changes to the "PnlAmortizationYtd" field.
func (m *ReportMutation) ResetPnlAmortizationYtd() {
	m._PnlAmortizationYtd = nil
	m.add_PnlAmortizationYtd = nil
}

// SetPnlOperatingIncomeYtd sets the "PnlOperatingIncomeYtd" field.
func (m *ReportMutation) SetPnlOperatingIncomeYtd(f float64) {
	m._PnlOperatingIncomeYtd = &f
	m.add_PnlOperatingIncomeYtd = nil
}

// PnlOperatingIncomeYtd returns the value of the "PnlOperatingIncomeYtd" field in the mutation.
func (m *ReportMutation) PnlOperatingIncomeYtd() (r float64, exists bool) {
	v := m._PnlOperatingIncomeYtd
	if v == nil {
		return
	}
	return *v, true
}

// OldPnlOperatingIncomeYtd returns the old "PnlOperatingIncomeYtd" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldPnlOperatingIncomeYtd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPnlOperatingIncomeYtd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPnlOperatingIncomeYtd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPnlOperatingIncomeYtd: %w", err)
	}
	return oldValue.PnlOperatingIncomeYtd, nil
}

// AddPnlOperatingIncomeYtd adds f to the "PnlOperatingIncomeYtd" field.
func (m *ReportMutation) AddPnlOperatingIncomeYtd(f float64) {
	if m.add_PnlOperatingIncomeYtd != nil {
		*m.add_PnlOperatingIncomeYtd += f
	} else {
		m.add_PnlOperatingIncomeYtd = &f
	}
}

// AddedPnlOperatingIncomeYtd returns the value that was added to the "PnlOperatingIncomeYtd" field in this mutation.
func (m *ReportMutation) AddedPnlOperatingIncomeYtd() (r float64, exists bool) {
	v := m.add_PnlOperatingIncomeYtd
	if v == nil {
		return
	}
	return *v, true
}

// ResetPnlOperatingIncomeYtd resets all changes to the "PnlOperatingIncomeYtd" field.
func (m *ReportMutation) ResetPnlOperatingIncomeYtd() {
	m._PnlOperatingIncomeYtd = nil
	m.add_PnlOperatingIncomeYtd = nil
}

// SetPnlInterestIncomeYtd sets the "PnlInterestIncomeYtd" field.
func (m *ReportMutation) SetPnlInterestIncomeYtd(f float64) {
	m._PnlInterestIncomeYtd = &f
	m.add_PnlInterestIncomeYtd = nil
}

// PnlInterestIncomeYtd returns the value of the "PnlInterestIncomeYtd" field in the mutation.
func (m *ReportMutation) PnlInterestIncomeYtd() (r float64, exists bool) {
	v := m._PnlInterestIncomeYtd
	if v == nil {
		return
	}
	return *v, true
}

// OldPnlInterestIncomeYtd returns the old "PnlInterestIncomeYtd" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldPnlInterestIncomeYtd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPnlInterestIncomeYtd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPnlInterestIncomeYtd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPnlInterestIncomeYtd: %w", err)
	}
	return oldValue.PnlInterestIncomeYtd, nil
}

// AddPnlInterestIncomeYtd adds f to the "PnlInterestIncomeYtd" field.
func (m *ReportMutation) AddPnlInterestIncomeYtd(f float64) {
	if m.add_PnlInterestIncomeYtd != nil {
		*m.add_PnlInterestIncomeYtd += f
	} else {
		m.add_PnlInterestIncomeYtd = &f
	}
}

// AddedPnlInterestIncomeYtd returns the value that was added to the "PnlInterestIncomeYtd" field in this mutation.
func (m *ReportMutation) AddedPnlInterestIncomeYtd() (r float64, exists bool) {
	v := m.add_PnlInterestIncomeYtd
	if v == nil {
		return
	}
	return *v, true
}

// ResetPnlInterestIncomeYtd resets all changes to the "PnlInterestIncomeYtd" field.
func (m *ReportMutation) ResetPnlInterestIncomeYtd() {
	m._PnlInterestIncomeYtd = nil
	m.add_PnlInterestIncomeYtd = nil
}

// SetPnlInterestExpensesYtd sets the "PnlInterestExpensesYtd" field.
func (m *ReportMutation) SetPnlInterestExpensesYtd(f float64) {
	m._PnlInterestExpensesYtd = &f
	m.add_PnlInterestExpensesYtd = nil
}

// PnlInterestExpensesYtd returns the value of the "PnlInterestExpensesYtd" field in the mutation.
func (m *ReportMutation) PnlInterestExpensesYtd() (r float64, exists bool) {
	v := m._PnlInterestExpensesYtd
	if v == nil {
		return
	}
	return *v, true
}

// OldPnlInterestExpensesYtd returns the old "PnlInterestExpensesYtd" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldPnlInterestExpensesYtd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPnlInterestExpensesYtd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPnlInterestExpensesYtd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPnlInterestExpensesYtd: %w", err)
	}
	return oldValue.PnlInterestExpensesYtd, nil
}

// AddPnlInterestExpensesYtd adds f to the "PnlInterestExpensesYtd" field.
func (m *ReportMutation) AddPnlInterestExpensesYtd(f float64) {
	if m.add_PnlInterestExpensesYtd != nil {
		*m.add_PnlInterestExpensesYtd += f
	} else {
		m.add_PnlInterestExpensesYtd = &f
	}
}

// AddedPnlInterestExpensesYtd returns the value that was added to the "PnlInterestExpensesYtd" field in this mutation.
func (m *ReportMutation) AddedPnlInterestExpensesYtd() (r float64, exists bool) {
	v := m.add_PnlInterestExpensesYtd
	if v == nil {
		return
	}
	return *v, true
}

// ResetPnlInterestExpensesYtd resets all changes to the "PnlInterestExpensesYtd" field.
func (m *ReportMutation) ResetPnlInterestExpensesYtd() {
	m._PnlInterestExpensesYtd = nil
	m.add_PnlInterestExpensesYtd = nil
}

// SetPnlIncomeTaxYtd sets the "PnlIncomeTaxYtd" field.
func (m *ReportMutation) SetPnlIncomeTaxYtd(f float64) {
	m._PnlIncomeTaxYtd = &f
	m.add_PnlIncomeTaxYtd = nil
}

// PnlIncomeTaxYtd returns the value of the "PnlIncomeTaxYtd" field in the mutation.
func (m *ReportMutation) PnlIncomeTaxYtd() (r float64, exists bool) {
	v := m._PnlIncomeTaxYtd
	if v == nil {
		return
	}
	return *v, true
}

// OldPnlIncomeTaxYtd returns the old "PnlIncomeTaxYtd" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldPnlIncomeTaxYtd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPnlIncomeTaxYtd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPnlIncomeTaxYtd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPnlIncomeTaxYtd: %w", err)
	}
	return oldValue.PnlIncomeTaxYtd, nil
}

// AddPnlIncomeTaxYtd adds f to the "PnlIncomeTaxYtd" field.
func (m *ReportMutation) AddPnlIncomeTaxYtd(f float64) {
	if m.add_PnlIncomeTaxYtd != nil {
		*m.add_PnlIncomeTaxYtd += f
	} else {
		m.add_PnlIncomeTaxYtd = &f
	}
}

// AddedPnlIncomeTaxYtd returns the value that was added to the "PnlIncomeTaxYtd" field in this mutation.
func (m *ReportMutation) AddedPnlIncomeTaxYtd() (r float64, exists bool) {
	v := m.add_PnlIncomeTaxYtd
	if v == nil {
		return
	}
	return *v, true
}

// ResetPnlIncomeTaxYtd resets all changes to the "PnlIncomeTaxYtd" field.
func (m *ReportMutation) ResetPnlIncomeTaxYtd() {
	m._PnlIncomeTaxYtd = nil
	m.add_PnlIncomeTaxYtd = nil
}

// SetPnlNetIncomeYtd sets the "PnlNetIncomeYtd" field.
func (m *ReportMutation) SetPnlNetIncomeYtd(f float64) {
	m._PnlNetIncomeYtd = &f
	m.add_PnlNetIncomeYtd = nil
}

// PnlNetIncomeYtd returns the value of the "PnlNetIncomeYtd" field in the mutation.
func (m *ReportMutation) PnlNetIncomeYtd() (r float64, exists bool) {
	v := m._PnlNetIncomeYtd
	if v == nil {
		return
	}
	return *v, true
}

// OldPnlNetIncomeYtd returns the old "PnlNetIncomeYtd" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldPnlNetIncomeYtd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPnlNetIncomeYtd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPnlNetIncomeYtd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPnlNetIncomeYtd: %w", err)
	}
	return oldValue.PnlNetIncomeYtd, nil
}

// AddPnlNetIncomeYtd adds f to the "PnlNetIncomeYtd" field.
func (m *ReportMutation) AddPnlNetIncomeYtd(f float64) {
	if m.add_PnlNetIncomeYtd != nil {
		*m.add_PnlNetIncomeYtd += f
	} else {
		m.add_PnlNetIncomeYtd = &f
	}
}

// AddedPnlNetIncomeYtd returns the value that was added to the "PnlNetIncomeYtd" field in this mutation.
func (m *ReportMutation) AddedPnlNetIncomeYtd() (r float64, exists bool) {
	v := m.add_PnlNetIncomeYtd
	if v == nil {
		return
	}
	return *v, true
}

// ResetPnlNetIncomeYtd resets all changes to the "PnlNetIncomeYtd" field.
func (m *ReportMutation) ResetPnlNetIncomeYtd() {
	m._PnlNetIncomeYtd = nil
	m.add_PnlNetIncomeYtd = nil
}

// SetCfCashSld sets the "CfCashSld" field.
func (m *ReportMutation) SetCfCashSld(f float64) {
	m._CfCashSld = &f
	m.add_CfCashSld = nil
}

// CfCashSld returns the value of the "CfCashSld" field in the mutation.
func (m *ReportMutation) CfCashSld() (r float64, exists bool) {
	v := m._CfCashSld
	if v == nil {
		return
	}
	return *v, true
}

// OldCfCashSld returns the old "CfCashSld" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldCfCashSld(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCfCashSld is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCfCashSld requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCfCashSld: %w", err)
	}
	return oldValue.CfCashSld, nil
}

// AddCfCashSld adds f to the "CfCashSld" field.
func (m *ReportMutation) AddCfCashSld(f float64) {
	if m.add_CfCashSld != nil {
		*m.add_CfCashSld += f
	} else {
		m.add_CfCashSld = &f
	}
}

// AddedCfCashSld returns the value that was added to the "CfCashSld" field in this mutation.
func (m *ReportMutation) AddedCfCashSld() (r float64, exists bool) {
	v := m.add_CfCashSld
	if v == nil {
		return
	}
	return *v, true
}

// ResetCfCashSld resets all changes to the "CfCashSld" field.
func (m *ReportMutation) ResetCfCashSld() {
	m._CfCashSld = nil
	m.add_CfCashSld = nil
}

// SetCfNonCurrentLiabilitiesSld sets the "CfNonCurrentLiabilitiesSld" field.
func (m *ReportMutation) SetCfNonCurrentLiabilitiesSld(f float64) {
	m._CfNonCurrentLiabilitiesSld = &f
	m.add_CfNonCurrentLiabilitiesSld = nil
}

// CfNonCurrentLiabilitiesSld returns the value of the "CfNonCurrentLiabilitiesSld" field in the mutation.
func (m *ReportMutation) CfNonCurrentLiabilitiesSld() (r float64, exists bool) {
	v := m._CfNonCurrentLiabilitiesSld
	if v == nil {
		return
	}
	return *v, true
}

// OldCfNonCurrentLiabilitiesSld returns the old "CfNonCurrentLiabilitiesSld" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldCfNonCurrentLiabilitiesSld(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCfNonCurrentLiabilitiesSld is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCfNonCurrentLiabilitiesSld requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCfNonCurrentLiabilitiesSld: %w", err)
	}
	return oldValue.CfNonCurrentLiabilitiesSld, nil
}

// AddCfNonCurrentLiabilitiesSld adds f to the "CfNonCurrentLiabilitiesSld" field.
func (m *ReportMutation) AddCfNonCurrentLiabilitiesSld(f float64) {
	if m.add_CfNonCurrentLiabilitiesSld != nil {
		*m.add_CfNonCurrentLiabilitiesSld += f
	} else {
		m.add_CfNonCurrentLiabilitiesSld = &f
	}
}

// AddedCfNonCurrentLiabilitiesSld returns the value that was added to the "CfNonCurrentLiabilitiesSld" field in this mutation.
func (m *ReportMutation) AddedCfNonCurrentLiabilitiesSld() (r float64, exists bool) {
	v := m.add_CfNonCurrentLiabilitiesSld
	if v == nil {
		return
	}
	return *v, true
}

// ResetCfNonCurrentLiabilitiesSld resets all changes to the "CfNonCurrentLiabilitiesSld" field.
func (m *ReportMutation) ResetCfNonCurrentLiabilitiesSld() {
	m._CfNonCurrentLiabilitiesSld = nil
	m.add_CfNonCurrentLiabilitiesSld = nil
}

// SetCfCurrentLiabilitesSld sets the "CfCurrentLiabilitesSld" field.
func (m *ReportMutation) SetCfCurrentLiabilitesSld(f float64) {
	m._CfCurrentLiabilitesSld = &f
	m.add_CfCurrentLiabilitesSld = nil
}

// CfCurrentLiabilitesSld returns the value of the "CfCurrentLiabilitesSld" field in the mutation.
func (m *ReportMutation) CfCurrentLiabilitesSld() (r float64, exists bool) {
	v := m._CfCurrentLiabilitesSld
	if v == nil {
		return
	}
	return *v, true
}

// OldCfCurrentLiabilitesSld returns the old "CfCurrentLiabilitesSld" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldCfCurrentLiabilitesSld(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCfCurrentLiabilitesSld is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCfCurrentLiabilitesSld requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCfCurrentLiabilitesSld: %w", err)
	}
	return oldValue.CfCurrentLiabilitesSld, nil
}

// AddCfCurrentLiabilitesSld adds f to the "CfCurrentLiabilitesSld" field.
func (m *ReportMutation) AddCfCurrentLiabilitesSld(f float64) {
	if m.add_CfCurrentLiabilitesSld != nil {
		*m.add_CfCurrentLiabilitesSld += f
	} else {
		m.add_CfCurrentLiabilitesSld = &f
	}
}

// AddedCfCurrentLiabilitesSld returns the value that was added to the "CfCurrentLiabilitesSld" field in this mutation.
func (m *ReportMutation) AddedCfCurrentLiabilitesSld() (r float64, exists bool) {
	v := m.add_CfCurrentLiabilitesSld
	if v == nil {
		return
	}
	return *v, true
}

// ResetCfCurrentLiabilitesSld resets all changes to the "CfCurrentLiabilitesSld" field.
func (m *ReportMutation) ResetCfCurrentLiabilitesSld() {
	m._CfCurrentLiabilitesSld = nil
	m.add_CfCurrentLiabilitesSld = nil
}

// SetCfNonControllingSld sets the "CfNonControllingSld" field.
func (m *ReportMutation) SetCfNonControllingSld(f float64) {
	m._CfNonControllingSld = &f
	m.add_CfNonControllingSld = nil
}

// CfNonControllingSld returns the value of the "CfNonControllingSld" field in the mutation.
func (m *ReportMutation) CfNonControllingSld() (r float64, exists bool) {
	v := m._CfNonControllingSld
	if v == nil {
		return
	}
	return *v, true
}

// OldCfNonControllingSld returns the old "CfNonControllingSld" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldCfNonControllingSld(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCfNonControllingSld is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCfNonControllingSld requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCfNonControllingSld: %w", err)
	}
	return oldValue.CfNonControllingSld, nil
}

// AddCfNonControllingSld adds f to the "CfNonControllingSld" field.
func (m *ReportMutation) AddCfNonControllingSld(f float64) {
	if m.add_CfNonControllingSld != nil {
		*m.add_CfNonControllingSld += f
	} else {
		m.add_CfNonControllingSld = &f
	}
}

// AddedCfNonControllingSld returns the value that was added to the "CfNonControllingSld" field in this mutation.
func (m *ReportMutation) AddedCfNonControllingSld() (r float64, exists bool) {
	v := m.add_CfNonControllingSld
	if v == nil {
		return
	}
	return *v, true
}

// ResetCfNonControllingSld resets all changes to the "CfNonControllingSld" field.
func (m *ReportMutation) ResetCfNonControllingSld() {
	m._CfNonControllingSld = nil
	m.add_CfNonControllingSld = nil
}

// SetCfEquitySld sets the "CfEquitySld" field.
func (m *ReportMutation) SetCfEquitySld(f float64) {
	m._CfEquitySld = &f
	m.add_CfEquitySld = nil
}

// CfEquitySld returns the value of the "CfEquitySld" field in the mutation.
func (m *ReportMutation) CfEquitySld() (r float64, exists bool) {
	v := m._CfEquitySld
	if v == nil {
		return
	}
	return *v, true
}

// OldCfEquitySld returns the old "CfEquitySld" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldCfEquitySld(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCfEquitySld is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCfEquitySld requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCfEquitySld: %w", err)
	}
	return oldValue.CfEquitySld, nil
}

// AddCfEquitySld adds f to the "CfEquitySld" field.
func (m *ReportMutation) AddCfEquitySld(f float64) {
	if m.add_CfEquitySld != nil {
		*m.add_CfEquitySld += f
	} else {
		m.add_CfEquitySld = &f
	}
}

// AddedCfEquitySld returns the value that was added to the "CfEquitySld" field in this mutation.
func (m *ReportMutation) AddedCfEquitySld() (r float64, exists bool) {
	v := m.add_CfEquitySld
	if v == nil {
		return
	}
	return *v, true
}

// ResetCfEquitySld resets all changes to the "CfEquitySld" field.
func (m *ReportMutation) ResetCfEquitySld() {
	m._CfEquitySld = nil
	m.add_CfEquitySld = nil
}

// SetCfTotalSld sets the "CfTotalSld" field.
func (m *ReportMutation) SetCfTotalSld(f float64) {
	m._CfTotalSld = &f
	m.add_CfTotalSld = nil
}

// CfTotalSld returns the value of the "CfTotalSld" field in the mutation.
func (m *ReportMutation) CfTotalSld() (r float64, exists bool) {
	v := m._CfTotalSld
	if v == nil {
		return
	}
	return *v, true
}

// OldCfTotalSld returns the old "CfTotalSld" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldCfTotalSld(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCfTotalSld is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCfTotalSld requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCfTotalSld: %w", err)
	}
	return oldValue.CfTotalSld, nil
}

// AddCfTotalSld adds f to the "CfTotalSld" field.
func (m *ReportMutation) AddCfTotalSld(f float64) {
	if m.add_CfTotalSld != nil {
		*m.add_CfTotalSld += f
	} else {
		m.add_CfTotalSld = &f
	}
}

// AddedCfTotalSld returns the value that was added to the "CfTotalSld" field in this mutation.
func (m *ReportMutation) AddedCfTotalSld() (r float64, exists bool) {
	v := m.add_CfTotalSld
	if v == nil {
		return
	}
	return *v, true
}

// ResetCfTotalSld resets all changes to the "CfTotalSld" field.
func (m *ReportMutation) ResetCfTotalSld() {
	m._CfTotalSld = nil
	m.add_CfTotalSld = nil
}

// SetURL sets the "Url" field.
func (m *ReportMutation) SetURL(s string) {
	m._Url = &s
}

// URL returns the value of the "Url" field in the mutation.
func (m *ReportMutation) URL() (r string, exists bool) {
	v := m._Url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "Url" field's value of the Report entity.
// If the Report object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "Url" field.
func (m *ReportMutation) ClearURL() {
	m._Url = nil
	m.clearedFields[report.FieldURL] = struct{}{}
}

// URLCleared returns if the "Url" field was cleared in this mutation.
func (m *ReportMutation) URLCleared() bool {
	_, ok := m.clearedFields[report.FieldURL]
	return ok
}

// ResetURL resets all changes to the "Url" field.
func (m *ReportMutation) ResetURL() {
	m._Url = nil
	delete(m.clearedFields, report.FieldURL)
}

// SetEmitentID sets the "Emitent" edge to the Emitent entity by id.
func (m *ReportMutation) SetEmitentID(id xid.ID) {
	m._Emitent = &id
}

// ClearEmitent clears the "Emitent" edge to the Emitent entity.
func (m *ReportMutation) ClearEmitent() {
	m.cleared_Emitent = true
}

// EmitentCleared reports if the "Emitent" edge to the Emitent entity was cleared.
func (m *ReportMutation) EmitentCleared() bool {
	return m.cleared_Emitent
}

// EmitentID returns the "Emitent" edge ID in the mutation.
func (m *ReportMutation) EmitentID() (id xid.ID, exists bool) {
	if m._Emitent != nil {
		return *m._Emitent, true
	}
	return
}

// EmitentIDs returns the "Emitent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmitentID instead. It exists only for internal usage by the builders.
func (m *ReportMutation) EmitentIDs() (ids []xid.ID) {
	if id := m._Emitent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmitent resets all changes to the "Emitent" edge.
func (m *ReportMutation) ResetEmitent() {
	m._Emitent = nil
	m.cleared_Emitent = false
}

// Where appends a list predicates to the ReportMutation builder.
func (m *ReportMutation) Where(ps ...predicate.Report) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ReportMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Report).
func (m *ReportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReportMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m._ReportYear != nil {
		fields = append(fields, report.FieldReportYear)
	}
	if m._ReportQuarter != nil {
		fields = append(fields, report.FieldReportQuarter)
	}
	if m._ReportDate != nil {
		fields = append(fields, report.FieldReportDate)
	}
	if m._PnlRevenueYtd != nil {
		fields = append(fields, report.FieldPnlRevenueYtd)
	}
	if m._PnlAmortizationYtd != nil {
		fields = append(fields, report.FieldPnlAmortizationYtd)
	}
	if m._PnlOperatingIncomeYtd != nil {
		fields = append(fields, report.FieldPnlOperatingIncomeYtd)
	}
	if m._PnlInterestIncomeYtd != nil {
		fields = append(fields, report.FieldPnlInterestIncomeYtd)
	}
	if m._PnlInterestExpensesYtd != nil {
		fields = append(fields, report.FieldPnlInterestExpensesYtd)
	}
	if m._PnlIncomeTaxYtd != nil {
		fields = append(fields, report.FieldPnlIncomeTaxYtd)
	}
	if m._PnlNetIncomeYtd != nil {
		fields = append(fields, report.FieldPnlNetIncomeYtd)
	}
	if m._CfCashSld != nil {
		fields = append(fields, report.FieldCfCashSld)
	}
	if m._CfNonCurrentLiabilitiesSld != nil {
		fields = append(fields, report.FieldCfNonCurrentLiabilitiesSld)
	}
	if m._CfCurrentLiabilitesSld != nil {
		fields = append(fields, report.FieldCfCurrentLiabilitesSld)
	}
	if m._CfNonControllingSld != nil {
		fields = append(fields, report.FieldCfNonControllingSld)
	}
	if m._CfEquitySld != nil {
		fields = append(fields, report.FieldCfEquitySld)
	}
	if m._CfTotalSld != nil {
		fields = append(fields, report.FieldCfTotalSld)
	}
	if m._Url != nil {
		fields = append(fields, report.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case report.FieldReportYear:
		return m.ReportYear()
	case report.FieldReportQuarter:
		return m.ReportQuarter()
	case report.FieldReportDate:
		return m.ReportDate()
	case report.FieldPnlRevenueYtd:
		return m.PnlRevenueYtd()
	case report.FieldPnlAmortizationYtd:
		return m.PnlAmortizationYtd()
	case report.FieldPnlOperatingIncomeYtd:
		return m.PnlOperatingIncomeYtd()
	case report.FieldPnlInterestIncomeYtd:
		return m.PnlInterestIncomeYtd()
	case report.FieldPnlInterestExpensesYtd:
		return m.PnlInterestExpensesYtd()
	case report.FieldPnlIncomeTaxYtd:
		return m.PnlIncomeTaxYtd()
	case report.FieldPnlNetIncomeYtd:
		return m.PnlNetIncomeYtd()
	case report.FieldCfCashSld:
		return m.CfCashSld()
	case report.FieldCfNonCurrentLiabilitiesSld:
		return m.CfNonCurrentLiabilitiesSld()
	case report.FieldCfCurrentLiabilitesSld:
		return m.CfCurrentLiabilitesSld()
	case report.FieldCfNonControllingSld:
		return m.CfNonControllingSld()
	case report.FieldCfEquitySld:
		return m.CfEquitySld()
	case report.FieldCfTotalSld:
		return m.CfTotalSld()
	case report.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case report.FieldReportYear:
		return m.OldReportYear(ctx)
	case report.FieldReportQuarter:
		return m.OldReportQuarter(ctx)
	case report.FieldReportDate:
		return m.OldReportDate(ctx)
	case report.FieldPnlRevenueYtd:
		return m.OldPnlRevenueYtd(ctx)
	case report.FieldPnlAmortizationYtd:
		return m.OldPnlAmortizationYtd(ctx)
	case report.FieldPnlOperatingIncomeYtd:
		return m.OldPnlOperatingIncomeYtd(ctx)
	case report.FieldPnlInterestIncomeYtd:
		return m.OldPnlInterestIncomeYtd(ctx)
	case report.FieldPnlInterestExpensesYtd:
		return m.OldPnlInterestExpensesYtd(ctx)
	case report.FieldPnlIncomeTaxYtd:
		return m.OldPnlIncomeTaxYtd(ctx)
	case report.FieldPnlNetIncomeYtd:
		return m.OldPnlNetIncomeYtd(ctx)
	case report.FieldCfCashSld:
		return m.OldCfCashSld(ctx)
	case report.FieldCfNonCurrentLiabilitiesSld:
		return m.OldCfNonCurrentLiabilitiesSld(ctx)
	case report.FieldCfCurrentLiabilitesSld:
		return m.OldCfCurrentLiabilitesSld(ctx)
	case report.FieldCfNonControllingSld:
		return m.OldCfNonControllingSld(ctx)
	case report.FieldCfEquitySld:
		return m.OldCfEquitySld(ctx)
	case report.FieldCfTotalSld:
		return m.OldCfTotalSld(ctx)
	case report.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown Report field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case report.FieldReportYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportYear(v)
		return nil
	case report.FieldReportQuarter:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportQuarter(v)
		return nil
	case report.FieldReportDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReportDate(v)
		return nil
	case report.FieldPnlRevenueYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPnlRevenueYtd(v)
		return nil
	case report.FieldPnlAmortizationYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPnlAmortizationYtd(v)
		return nil
	case report.FieldPnlOperatingIncomeYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPnlOperatingIncomeYtd(v)
		return nil
	case report.FieldPnlInterestIncomeYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPnlInterestIncomeYtd(v)
		return nil
	case report.FieldPnlInterestExpensesYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPnlInterestExpensesYtd(v)
		return nil
	case report.FieldPnlIncomeTaxYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPnlIncomeTaxYtd(v)
		return nil
	case report.FieldPnlNetIncomeYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPnlNetIncomeYtd(v)
		return nil
	case report.FieldCfCashSld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCfCashSld(v)
		return nil
	case report.FieldCfNonCurrentLiabilitiesSld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCfNonCurrentLiabilitiesSld(v)
		return nil
	case report.FieldCfCurrentLiabilitesSld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCfCurrentLiabilitesSld(v)
		return nil
	case report.FieldCfNonControllingSld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCfNonControllingSld(v)
		return nil
	case report.FieldCfEquitySld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCfEquitySld(v)
		return nil
	case report.FieldCfTotalSld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCfTotalSld(v)
		return nil
	case report.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown Report field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReportMutation) AddedFields() []string {
	var fields []string
	if m.add_ReportYear != nil {
		fields = append(fields, report.FieldReportYear)
	}
	if m.add_ReportQuarter != nil {
		fields = append(fields, report.FieldReportQuarter)
	}
	if m.add_PnlRevenueYtd != nil {
		fields = append(fields, report.FieldPnlRevenueYtd)
	}
	if m.add_PnlAmortizationYtd != nil {
		fields = append(fields, report.FieldPnlAmortizationYtd)
	}
	if m.add_PnlOperatingIncomeYtd != nil {
		fields = append(fields, report.FieldPnlOperatingIncomeYtd)
	}
	if m.add_PnlInterestIncomeYtd != nil {
		fields = append(fields, report.FieldPnlInterestIncomeYtd)
	}
	if m.add_PnlInterestExpensesYtd != nil {
		fields = append(fields, report.FieldPnlInterestExpensesYtd)
	}
	if m.add_PnlIncomeTaxYtd != nil {
		fields = append(fields, report.FieldPnlIncomeTaxYtd)
	}
	if m.add_PnlNetIncomeYtd != nil {
		fields = append(fields, report.FieldPnlNetIncomeYtd)
	}
	if m.add_CfCashSld != nil {
		fields = append(fields, report.FieldCfCashSld)
	}
	if m.add_CfNonCurrentLiabilitiesSld != nil {
		fields = append(fields, report.FieldCfNonCurrentLiabilitiesSld)
	}
	if m.add_CfCurrentLiabilitesSld != nil {
		fields = append(fields, report.FieldCfCurrentLiabilitesSld)
	}
	if m.add_CfNonControllingSld != nil {
		fields = append(fields, report.FieldCfNonControllingSld)
	}
	if m.add_CfEquitySld != nil {
		fields = append(fields, report.FieldCfEquitySld)
	}
	if m.add_CfTotalSld != nil {
		fields = append(fields, report.FieldCfTotalSld)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case report.FieldReportYear:
		return m.AddedReportYear()
	case report.FieldReportQuarter:
		return m.AddedReportQuarter()
	case report.FieldPnlRevenueYtd:
		return m.AddedPnlRevenueYtd()
	case report.FieldPnlAmortizationYtd:
		return m.AddedPnlAmortizationYtd()
	case report.FieldPnlOperatingIncomeYtd:
		return m.AddedPnlOperatingIncomeYtd()
	case report.FieldPnlInterestIncomeYtd:
		return m.AddedPnlInterestIncomeYtd()
	case report.FieldPnlInterestExpensesYtd:
		return m.AddedPnlInterestExpensesYtd()
	case report.FieldPnlIncomeTaxYtd:
		return m.AddedPnlIncomeTaxYtd()
	case report.FieldPnlNetIncomeYtd:
		return m.AddedPnlNetIncomeYtd()
	case report.FieldCfCashSld:
		return m.AddedCfCashSld()
	case report.FieldCfNonCurrentLiabilitiesSld:
		return m.AddedCfNonCurrentLiabilitiesSld()
	case report.FieldCfCurrentLiabilitesSld:
		return m.AddedCfCurrentLiabilitesSld()
	case report.FieldCfNonControllingSld:
		return m.AddedCfNonControllingSld()
	case report.FieldCfEquitySld:
		return m.AddedCfEquitySld()
	case report.FieldCfTotalSld:
		return m.AddedCfTotalSld()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case report.FieldReportYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReportYear(v)
		return nil
	case report.FieldReportQuarter:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReportQuarter(v)
		return nil
	case report.FieldPnlRevenueYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPnlRevenueYtd(v)
		return nil
	case report.FieldPnlAmortizationYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPnlAmortizationYtd(v)
		return nil
	case report.FieldPnlOperatingIncomeYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPnlOperatingIncomeYtd(v)
		return nil
	case report.FieldPnlInterestIncomeYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPnlInterestIncomeYtd(v)
		return nil
	case report.FieldPnlInterestExpensesYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPnlInterestExpensesYtd(v)
		return nil
	case report.FieldPnlIncomeTaxYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPnlIncomeTaxYtd(v)
		return nil
	case report.FieldPnlNetIncomeYtd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPnlNetIncomeYtd(v)
		return nil
	case report.FieldCfCashSld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCfCashSld(v)
		return nil
	case report.FieldCfNonCurrentLiabilitiesSld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCfNonCurrentLiabilitiesSld(v)
		return nil
	case report.FieldCfCurrentLiabilitesSld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCfCurrentLiabilitesSld(v)
		return nil
	case report.FieldCfNonControllingSld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCfNonControllingSld(v)
		return nil
	case report.FieldCfEquitySld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCfEquitySld(v)
		return nil
	case report.FieldCfTotalSld:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCfTotalSld(v)
		return nil
	}
	return fmt.Errorf("unknown Report numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(report.FieldURL) {
		fields = append(fields, report.FieldURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReportMutation) ClearField(name string) error {
	switch name {
	case report.FieldURL:
		m.ClearURL()
		return nil
	}
	return fmt.Errorf("unknown Report nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReportMutation) ResetField(name string) error {
	switch name {
	case report.FieldReportYear:
		m.ResetReportYear()
		return nil
	case report.FieldReportQuarter:
		m.ResetReportQuarter()
		return nil
	case report.FieldReportDate:
		m.ResetReportDate()
		return nil
	case report.FieldPnlRevenueYtd:
		m.ResetPnlRevenueYtd()
		return nil
	case report.FieldPnlAmortizationYtd:
		m.ResetPnlAmortizationYtd()
		return nil
	case report.FieldPnlOperatingIncomeYtd:
		m.ResetPnlOperatingIncomeYtd()
		return nil
	case report.FieldPnlInterestIncomeYtd:
		m.ResetPnlInterestIncomeYtd()
		return nil
	case report.FieldPnlInterestExpensesYtd:
		m.ResetPnlInterestExpensesYtd()
		return nil
	case report.FieldPnlIncomeTaxYtd:
		m.ResetPnlIncomeTaxYtd()
		return nil
	case report.FieldPnlNetIncomeYtd:
		m.ResetPnlNetIncomeYtd()
		return nil
	case report.FieldCfCashSld:
		m.ResetCfCashSld()
		return nil
	case report.FieldCfNonCurrentLiabilitiesSld:
		m.ResetCfNonCurrentLiabilitiesSld()
		return nil
	case report.FieldCfCurrentLiabilitesSld:
		m.ResetCfCurrentLiabilitesSld()
		return nil
	case report.FieldCfNonControllingSld:
		m.ResetCfNonControllingSld()
		return nil
	case report.FieldCfEquitySld:
		m.ResetCfEquitySld()
		return nil
	case report.FieldCfTotalSld:
		m.ResetCfTotalSld()
		return nil
	case report.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown Report field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReportMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Emitent != nil {
		edges = append(edges, report.EdgeEmitent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case report.EdgeEmitent:
		if id := m._Emitent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReportMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Emitent {
		edges = append(edges, report.EdgeEmitent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReportMutation) EdgeCleared(name string) bool {
	switch name {
	case report.EdgeEmitent:
		return m.cleared_Emitent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReportMutation) ClearEdge(name string) error {
	switch name {
	case report.EdgeEmitent:
		m.ClearEmitent()
		return nil
	}
	return fmt.Errorf("unknown Report unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReportMutation) ResetEdge(name string) error {
	switch name {
	case report.EdgeEmitent:
		m.ResetEmitent()
		return nil
	}
	return fmt.Errorf("unknown Report edge %s", name)
}

// TickerMutation represents an operation that mutates the Ticker nodes in the graph.
type TickerMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	_Descr             *string
	_Kind              *int32
	add_Kind           *int32
	clearedFields      map[string]struct{}
	_Emitent           *xid.ID
	cleared_Emitent    bool
	_Quotes            map[xid.ID]struct{}
	removed_Quotes     map[xid.ID]struct{}
	cleared_Quotes     bool
	_DivPayouts        map[int]struct{}
	removed_DivPayouts map[int]struct{}
	cleared_DivPayouts bool
	_Emissions         map[xid.ID]struct{}
	removed_Emissions  map[xid.ID]struct{}
	cleared_Emissions  bool
	done               bool
	oldValue           func(context.Context) (*Ticker, error)
	predicates         []predicate.Ticker
}

var _ ent.Mutation = (*TickerMutation)(nil)

// tickerOption allows management of the mutation configuration using functional options.
type tickerOption func(*TickerMutation)

// newTickerMutation creates new mutation for the Ticker entity.
func newTickerMutation(c config, op Op, opts ...tickerOption) *TickerMutation {
	m := &TickerMutation{
		config:        c,
		op:            op,
		typ:           TypeTicker,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTickerID sets the ID field of the mutation.
func withTickerID(id string) tickerOption {
	return func(m *TickerMutation) {
		var (
			err   error
			once  sync.Once
			value *Ticker
		)
		m.oldValue = func(ctx context.Context) (*Ticker, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ticker.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTicker sets the old Ticker of the mutation.
func withTicker(node *Ticker) tickerOption {
	return func(m *TickerMutation) {
		m.oldValue = func(context.Context) (*Ticker, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TickerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TickerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ticker entities.
func (m *TickerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TickerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TickerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ticker.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDescr sets the "Descr" field.
func (m *TickerMutation) SetDescr(s string) {
	m._Descr = &s
}

// Descr returns the value of the "Descr" field in the mutation.
func (m *TickerMutation) Descr() (r string, exists bool) {
	v := m._Descr
	if v == nil {
		return
	}
	return *v, true
}

// OldDescr returns the old "Descr" field's value of the Ticker entity.
// If the Ticker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TickerMutation) OldDescr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescr: %w", err)
	}
	return oldValue.Descr, nil
}

// ResetDescr resets all changes to the "Descr" field.
func (m *TickerMutation) ResetDescr() {
	m._Descr = nil
}

// SetKind sets the "Kind" field.
func (m *TickerMutation) SetKind(i int32) {
	m._Kind = &i
	m.add_Kind = nil
}

// Kind returns the value of the "Kind" field in the mutation.
func (m *TickerMutation) Kind() (r int32, exists bool) {
	v := m._Kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "Kind" field's value of the Ticker entity.
// If the Ticker object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TickerMutation) OldKind(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// AddKind adds i to the "Kind" field.
func (m *TickerMutation) AddKind(i int32) {
	if m.add_Kind != nil {
		*m.add_Kind += i
	} else {
		m.add_Kind = &i
	}
}

// AddedKind returns the value that was added to the "Kind" field in this mutation.
func (m *TickerMutation) AddedKind() (r int32, exists bool) {
	v := m.add_Kind
	if v == nil {
		return
	}
	return *v, true
}

// ResetKind resets all changes to the "Kind" field.
func (m *TickerMutation) ResetKind() {
	m._Kind = nil
	m.add_Kind = nil
}

// SetEmitentID sets the "Emitent" edge to the Emitent entity by id.
func (m *TickerMutation) SetEmitentID(id xid.ID) {
	m._Emitent = &id
}

// ClearEmitent clears the "Emitent" edge to the Emitent entity.
func (m *TickerMutation) ClearEmitent() {
	m.cleared_Emitent = true
}

// EmitentCleared reports if the "Emitent" edge to the Emitent entity was cleared.
func (m *TickerMutation) EmitentCleared() bool {
	return m.cleared_Emitent
}

// EmitentID returns the "Emitent" edge ID in the mutation.
func (m *TickerMutation) EmitentID() (id xid.ID, exists bool) {
	if m._Emitent != nil {
		return *m._Emitent, true
	}
	return
}

// EmitentIDs returns the "Emitent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmitentID instead. It exists only for internal usage by the builders.
func (m *TickerMutation) EmitentIDs() (ids []xid.ID) {
	if id := m._Emitent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmitent resets all changes to the "Emitent" edge.
func (m *TickerMutation) ResetEmitent() {
	m._Emitent = nil
	m.cleared_Emitent = false
}

// AddQuoteIDs adds the "Quotes" edge to the Quote entity by ids.
func (m *TickerMutation) AddQuoteIDs(ids ...xid.ID) {
	if m._Quotes == nil {
		m._Quotes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m._Quotes[ids[i]] = struct{}{}
	}
}

// ClearQuotes clears the "Quotes" edge to the Quote entity.
func (m *TickerMutation) ClearQuotes() {
	m.cleared_Quotes = true
}

// QuotesCleared reports if the "Quotes" edge to the Quote entity was cleared.
func (m *TickerMutation) QuotesCleared() bool {
	return m.cleared_Quotes
}

// RemoveQuoteIDs removes the "Quotes" edge to the Quote entity by IDs.
func (m *TickerMutation) RemoveQuoteIDs(ids ...xid.ID) {
	if m.removed_Quotes == nil {
		m.removed_Quotes = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m._Quotes, ids[i])
		m.removed_Quotes[ids[i]] = struct{}{}
	}
}

// RemovedQuotes returns the removed IDs of the "Quotes" edge to the Quote entity.
func (m *TickerMutation) RemovedQuotesIDs() (ids []xid.ID) {
	for id := range m.removed_Quotes {
		ids = append(ids, id)
	}
	return
}

// QuotesIDs returns the "Quotes" edge IDs in the mutation.
func (m *TickerMutation) QuotesIDs() (ids []xid.ID) {
	for id := range m._Quotes {
		ids = append(ids, id)
	}
	return
}

// ResetQuotes resets all changes to the "Quotes" edge.
func (m *TickerMutation) ResetQuotes() {
	m._Quotes = nil
	m.cleared_Quotes = false
	m.removed_Quotes = nil
}

// AddDivPayoutIDs adds the "DivPayouts" edge to the DivPayout entity by ids.
func (m *TickerMutation) AddDivPayoutIDs(ids ...int) {
	if m._DivPayouts == nil {
		m._DivPayouts = make(map[int]struct{})
	}
	for i := range ids {
		m._DivPayouts[ids[i]] = struct{}{}
	}
}

// ClearDivPayouts clears the "DivPayouts" edge to the DivPayout entity.
func (m *TickerMutation) ClearDivPayouts() {
	m.cleared_DivPayouts = true
}

// DivPayoutsCleared reports if the "DivPayouts" edge to the DivPayout entity was cleared.
func (m *TickerMutation) DivPayoutsCleared() bool {
	return m.cleared_DivPayouts
}

// RemoveDivPayoutIDs removes the "DivPayouts" edge to the DivPayout entity by IDs.
func (m *TickerMutation) RemoveDivPayoutIDs(ids ...int) {
	if m.removed_DivPayouts == nil {
		m.removed_DivPayouts = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._DivPayouts, ids[i])
		m.removed_DivPayouts[ids[i]] = struct{}{}
	}
}

// RemovedDivPayouts returns the removed IDs of the "DivPayouts" edge to the DivPayout entity.
func (m *TickerMutation) RemovedDivPayoutsIDs() (ids []int) {
	for id := range m.removed_DivPayouts {
		ids = append(ids, id)
	}
	return
}

// DivPayoutsIDs returns the "DivPayouts" edge IDs in the mutation.
func (m *TickerMutation) DivPayoutsIDs() (ids []int) {
	for id := range m._DivPayouts {
		ids = append(ids, id)
	}
	return
}

// ResetDivPayouts resets all changes to the "DivPayouts" edge.
func (m *TickerMutation) ResetDivPayouts() {
	m._DivPayouts = nil
	m.cleared_DivPayouts = false
	m.removed_DivPayouts = nil
}

// AddEmissionIDs adds the "Emissions" edge to the Emission entity by ids.
func (m *TickerMutation) AddEmissionIDs(ids ...xid.ID) {
	if m._Emissions == nil {
		m._Emissions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m._Emissions[ids[i]] = struct{}{}
	}
}

// ClearEmissions clears the "Emissions" edge to the Emission entity.
func (m *TickerMutation) ClearEmissions() {
	m.cleared_Emissions = true
}

// EmissionsCleared reports if the "Emissions" edge to the Emission entity was cleared.
func (m *TickerMutation) EmissionsCleared() bool {
	return m.cleared_Emissions
}

// RemoveEmissionIDs removes the "Emissions" edge to the Emission entity by IDs.
func (m *TickerMutation) RemoveEmissionIDs(ids ...xid.ID) {
	if m.removed_Emissions == nil {
		m.removed_Emissions = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m._Emissions, ids[i])
		m.removed_Emissions[ids[i]] = struct{}{}
	}
}

// RemovedEmissions returns the removed IDs of the "Emissions" edge to the Emission entity.
func (m *TickerMutation) RemovedEmissionsIDs() (ids []xid.ID) {
	for id := range m.removed_Emissions {
		ids = append(ids, id)
	}
	return
}

// EmissionsIDs returns the "Emissions" edge IDs in the mutation.
func (m *TickerMutation) EmissionsIDs() (ids []xid.ID) {
	for id := range m._Emissions {
		ids = append(ids, id)
	}
	return
}

// ResetEmissions resets all changes to the "Emissions" edge.
func (m *TickerMutation) ResetEmissions() {
	m._Emissions = nil
	m.cleared_Emissions = false
	m.removed_Emissions = nil
}

// Where appends a list predicates to the TickerMutation builder.
func (m *TickerMutation) Where(ps ...predicate.Ticker) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TickerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Ticker).
func (m *TickerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TickerMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Descr != nil {
		fields = append(fields, ticker.FieldDescr)
	}
	if m._Kind != nil {
		fields = append(fields, ticker.FieldKind)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TickerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ticker.FieldDescr:
		return m.Descr()
	case ticker.FieldKind:
		return m.Kind()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TickerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ticker.FieldDescr:
		return m.OldDescr(ctx)
	case ticker.FieldKind:
		return m.OldKind(ctx)
	}
	return nil, fmt.Errorf("unknown Ticker field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TickerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ticker.FieldDescr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescr(v)
		return nil
	case ticker.FieldKind:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	}
	return fmt.Errorf("unknown Ticker field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TickerMutation) AddedFields() []string {
	var fields []string
	if m.add_Kind != nil {
		fields = append(fields, ticker.FieldKind)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TickerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ticker.FieldKind:
		return m.AddedKind()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TickerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ticker.FieldKind:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddKind(v)
		return nil
	}
	return fmt.Errorf("unknown Ticker numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TickerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TickerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TickerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Ticker nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TickerMutation) ResetField(name string) error {
	switch name {
	case ticker.FieldDescr:
		m.ResetDescr()
		return nil
	case ticker.FieldKind:
		m.ResetKind()
		return nil
	}
	return fmt.Errorf("unknown Ticker field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TickerMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._Emitent != nil {
		edges = append(edges, ticker.EdgeEmitent)
	}
	if m._Quotes != nil {
		edges = append(edges, ticker.EdgeQuotes)
	}
	if m._DivPayouts != nil {
		edges = append(edges, ticker.EdgeDivPayouts)
	}
	if m._Emissions != nil {
		edges = append(edges, ticker.EdgeEmissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TickerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ticker.EdgeEmitent:
		if id := m._Emitent; id != nil {
			return []ent.Value{*id}
		}
	case ticker.EdgeQuotes:
		ids := make([]ent.Value, 0, len(m._Quotes))
		for id := range m._Quotes {
			ids = append(ids, id)
		}
		return ids
	case ticker.EdgeDivPayouts:
		ids := make([]ent.Value, 0, len(m._DivPayouts))
		for id := range m._DivPayouts {
			ids = append(ids, id)
		}
		return ids
	case ticker.EdgeEmissions:
		ids := make([]ent.Value, 0, len(m._Emissions))
		for id := range m._Emissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TickerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_Quotes != nil {
		edges = append(edges, ticker.EdgeQuotes)
	}
	if m.removed_DivPayouts != nil {
		edges = append(edges, ticker.EdgeDivPayouts)
	}
	if m.removed_Emissions != nil {
		edges = append(edges, ticker.EdgeEmissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TickerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ticker.EdgeQuotes:
		ids := make([]ent.Value, 0, len(m.removed_Quotes))
		for id := range m.removed_Quotes {
			ids = append(ids, id)
		}
		return ids
	case ticker.EdgeDivPayouts:
		ids := make([]ent.Value, 0, len(m.removed_DivPayouts))
		for id := range m.removed_DivPayouts {
			ids = append(ids, id)
		}
		return ids
	case ticker.EdgeEmissions:
		ids := make([]ent.Value, 0, len(m.removed_Emissions))
		for id := range m.removed_Emissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TickerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_Emitent {
		edges = append(edges, ticker.EdgeEmitent)
	}
	if m.cleared_Quotes {
		edges = append(edges, ticker.EdgeQuotes)
	}
	if m.cleared_DivPayouts {
		edges = append(edges, ticker.EdgeDivPayouts)
	}
	if m.cleared_Emissions {
		edges = append(edges, ticker.EdgeEmissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TickerMutation) EdgeCleared(name string) bool {
	switch name {
	case ticker.EdgeEmitent:
		return m.cleared_Emitent
	case ticker.EdgeQuotes:
		return m.cleared_Quotes
	case ticker.EdgeDivPayouts:
		return m.cleared_DivPayouts
	case ticker.EdgeEmissions:
		return m.cleared_Emissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TickerMutation) ClearEdge(name string) error {
	switch name {
	case ticker.EdgeEmitent:
		m.ClearEmitent()
		return nil
	}
	return fmt.Errorf("unknown Ticker unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TickerMutation) ResetEdge(name string) error {
	switch name {
	case ticker.EdgeEmitent:
		m.ResetEmitent()
		return nil
	case ticker.EdgeQuotes:
		m.ResetQuotes()
		return nil
	case ticker.EdgeDivPayouts:
		m.ResetDivPayouts()
		return nil
	case ticker.EdgeEmissions:
		m.ResetEmissions()
		return nil
	}
	return fmt.Errorf("unknown Ticker edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                           Op
	typ                          string
	id                           *xid.ID
	_UserName                    *string
	_PasswordHash                *string
	_Admin                       *bool
	_StartInvestAccountsFlow     *time.Time
	_HowManyTickersOnHomepage    *int
	add_HowManyTickersOnHomepage *int
	clearedFields                map[string]struct{}
	_InvestAccounts              map[xid.ID]struct{}
	removed_InvestAccounts       map[xid.ID]struct{}
	cleared_InvestAccounts       bool
	done                         bool
	oldValue                     func(context.Context) (*User, error)
	predicates                   []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id xid.ID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id xid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id xid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]xid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []xid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserName sets the "UserName" field.
func (m *UserMutation) SetUserName(s string) {
	m._UserName = &s
}

// UserName returns the value of the "UserName" field in the mutation.
func (m *UserMutation) UserName() (r string, exists bool) {
	v := m._UserName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "UserName" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName resets all changes to the "UserName" field.
func (m *UserMutation) ResetUserName() {
	m._UserName = nil
}

// SetPasswordHash sets the "PasswordHash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m._PasswordHash = &s
}

// PasswordHash returns the value of the "PasswordHash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m._PasswordHash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "PasswordHash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "PasswordHash" field.
func (m *UserMutation) ResetPasswordHash() {
	m._PasswordHash = nil
}

// SetAdmin sets the "Admin" field.
func (m *UserMutation) SetAdmin(b bool) {
	m._Admin = &b
}

// Admin returns the value of the "Admin" field in the mutation.
func (m *UserMutation) Admin() (r bool, exists bool) {
	v := m._Admin
	if v == nil {
		return
	}
	return *v, true
}

// OldAdmin returns the old "Admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdmin: %w", err)
	}
	return oldValue.Admin, nil
}

// ResetAdmin resets all changes to the "Admin" field.
func (m *UserMutation) ResetAdmin() {
	m._Admin = nil
}

// SetStartInvestAccountsFlow sets the "StartInvestAccountsFlow" field.
func (m *UserMutation) SetStartInvestAccountsFlow(t time.Time) {
	m._StartInvestAccountsFlow = &t
}

// StartInvestAccountsFlow returns the value of the "StartInvestAccountsFlow" field in the mutation.
func (m *UserMutation) StartInvestAccountsFlow() (r time.Time, exists bool) {
	v := m._StartInvestAccountsFlow
	if v == nil {
		return
	}
	return *v, true
}

// OldStartInvestAccountsFlow returns the old "StartInvestAccountsFlow" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStartInvestAccountsFlow(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartInvestAccountsFlow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartInvestAccountsFlow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartInvestAccountsFlow: %w", err)
	}
	return oldValue.StartInvestAccountsFlow, nil
}

// ClearStartInvestAccountsFlow clears the value of the "StartInvestAccountsFlow" field.
func (m *UserMutation) ClearStartInvestAccountsFlow() {
	m._StartInvestAccountsFlow = nil
	m.clearedFields[user.FieldStartInvestAccountsFlow] = struct{}{}
}

// StartInvestAccountsFlowCleared returns if the "StartInvestAccountsFlow" field was cleared in this mutation.
func (m *UserMutation) StartInvestAccountsFlowCleared() bool {
	_, ok := m.clearedFields[user.FieldStartInvestAccountsFlow]
	return ok
}

// ResetStartInvestAccountsFlow resets all changes to the "StartInvestAccountsFlow" field.
func (m *UserMutation) ResetStartInvestAccountsFlow() {
	m._StartInvestAccountsFlow = nil
	delete(m.clearedFields, user.FieldStartInvestAccountsFlow)
}

// SetHowManyTickersOnHomepage sets the "HowManyTickersOnHomepage" field.
func (m *UserMutation) SetHowManyTickersOnHomepage(i int) {
	m._HowManyTickersOnHomepage = &i
	m.add_HowManyTickersOnHomepage = nil
}

// HowManyTickersOnHomepage returns the value of the "HowManyTickersOnHomepage" field in the mutation.
func (m *UserMutation) HowManyTickersOnHomepage() (r int, exists bool) {
	v := m._HowManyTickersOnHomepage
	if v == nil {
		return
	}
	return *v, true
}

// OldHowManyTickersOnHomepage returns the old "HowManyTickersOnHomepage" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHowManyTickersOnHomepage(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHowManyTickersOnHomepage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHowManyTickersOnHomepage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHowManyTickersOnHomepage: %w", err)
	}
	return oldValue.HowManyTickersOnHomepage, nil
}

// AddHowManyTickersOnHomepage adds i to the "HowManyTickersOnHomepage" field.
func (m *UserMutation) AddHowManyTickersOnHomepage(i int) {
	if m.add_HowManyTickersOnHomepage != nil {
		*m.add_HowManyTickersOnHomepage += i
	} else {
		m.add_HowManyTickersOnHomepage = &i
	}
}

// AddedHowManyTickersOnHomepage returns the value that was added to the "HowManyTickersOnHomepage" field in this mutation.
func (m *UserMutation) AddedHowManyTickersOnHomepage() (r int, exists bool) {
	v := m.add_HowManyTickersOnHomepage
	if v == nil {
		return
	}
	return *v, true
}

// ResetHowManyTickersOnHomepage resets all changes to the "HowManyTickersOnHomepage" field.
func (m *UserMutation) ResetHowManyTickersOnHomepage() {
	m._HowManyTickersOnHomepage = nil
	m.add_HowManyTickersOnHomepage = nil
}

// AddInvestAccountIDs adds the "InvestAccounts" edge to the InvestAccount entity by ids.
func (m *UserMutation) AddInvestAccountIDs(ids ...xid.ID) {
	if m._InvestAccounts == nil {
		m._InvestAccounts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		m._InvestAccounts[ids[i]] = struct{}{}
	}
}

// ClearInvestAccounts clears the "InvestAccounts" edge to the InvestAccount entity.
func (m *UserMutation) ClearInvestAccounts() {
	m.cleared_InvestAccounts = true
}

// InvestAccountsCleared reports if the "InvestAccounts" edge to the InvestAccount entity was cleared.
func (m *UserMutation) InvestAccountsCleared() bool {
	return m.cleared_InvestAccounts
}

// RemoveInvestAccountIDs removes the "InvestAccounts" edge to the InvestAccount entity by IDs.
func (m *UserMutation) RemoveInvestAccountIDs(ids ...xid.ID) {
	if m.removed_InvestAccounts == nil {
		m.removed_InvestAccounts = make(map[xid.ID]struct{})
	}
	for i := range ids {
		delete(m._InvestAccounts, ids[i])
		m.removed_InvestAccounts[ids[i]] = struct{}{}
	}
}

// RemovedInvestAccounts returns the removed IDs of the "InvestAccounts" edge to the InvestAccount entity.
func (m *UserMutation) RemovedInvestAccountsIDs() (ids []xid.ID) {
	for id := range m.removed_InvestAccounts {
		ids = append(ids, id)
	}
	return
}

// InvestAccountsIDs returns the "InvestAccounts" edge IDs in the mutation.
func (m *UserMutation) InvestAccountsIDs() (ids []xid.ID) {
	for id := range m._InvestAccounts {
		ids = append(ids, id)
	}
	return
}

// ResetInvestAccounts resets all changes to the "InvestAccounts" edge.
func (m *UserMutation) ResetInvestAccounts() {
	m._InvestAccounts = nil
	m.cleared_InvestAccounts = false
	m.removed_InvestAccounts = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._UserName != nil {
		fields = append(fields, user.FieldUserName)
	}
	if m._PasswordHash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m._Admin != nil {
		fields = append(fields, user.FieldAdmin)
	}
	if m._StartInvestAccountsFlow != nil {
		fields = append(fields, user.FieldStartInvestAccountsFlow)
	}
	if m._HowManyTickersOnHomepage != nil {
		fields = append(fields, user.FieldHowManyTickersOnHomepage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUserName:
		return m.UserName()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldAdmin:
		return m.Admin()
	case user.FieldStartInvestAccountsFlow:
		return m.StartInvestAccountsFlow()
	case user.FieldHowManyTickersOnHomepage:
		return m.HowManyTickersOnHomepage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUserName:
		return m.OldUserName(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldAdmin:
		return m.OldAdmin(ctx)
	case user.FieldStartInvestAccountsFlow:
		return m.OldStartInvestAccountsFlow(ctx)
	case user.FieldHowManyTickersOnHomepage:
		return m.OldHowManyTickersOnHomepage(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdmin(v)
		return nil
	case user.FieldStartInvestAccountsFlow:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartInvestAccountsFlow(v)
		return nil
	case user.FieldHowManyTickersOnHomepage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHowManyTickersOnHomepage(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.add_HowManyTickersOnHomepage != nil {
		fields = append(fields, user.FieldHowManyTickersOnHomepage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldHowManyTickersOnHomepage:
		return m.AddedHowManyTickersOnHomepage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldHowManyTickersOnHomepage:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHowManyTickersOnHomepage(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldStartInvestAccountsFlow) {
		fields = append(fields, user.FieldStartInvestAccountsFlow)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldStartInvestAccountsFlow:
		m.ClearStartInvestAccountsFlow()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUserName:
		m.ResetUserName()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldAdmin:
		m.ResetAdmin()
		return nil
	case user.FieldStartInvestAccountsFlow:
		m.ResetStartInvestAccountsFlow()
		return nil
	case user.FieldHowManyTickersOnHomepage:
		m.ResetHowManyTickersOnHomepage()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._InvestAccounts != nil {
		edges = append(edges, user.EdgeInvestAccounts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeInvestAccounts:
		ids := make([]ent.Value, 0, len(m._InvestAccounts))
		for id := range m._InvestAccounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_InvestAccounts != nil {
		edges = append(edges, user.EdgeInvestAccounts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeInvestAccounts:
		ids := make([]ent.Value, 0, len(m.removed_InvestAccounts))
		for id := range m.removed_InvestAccounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_InvestAccounts {
		edges = append(edges, user.EdgeInvestAccounts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeInvestAccounts:
		return m.cleared_InvestAccounts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeInvestAccounts:
		m.ResetInvestAccounts()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
