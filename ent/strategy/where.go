// Code generated by entc, DO NOT EDIT.

package strategy

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/rs/xid"
	"github.com/softilium/mb4/domains"
	"github.com/softilium/mb4/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id xid.ID) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id xid.ID) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id xid.ID) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...xid.ID) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...xid.ID) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id xid.ID) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id xid.ID) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id xid.ID) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id xid.ID) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// Descr applies equality check predicate on the "Descr" field. It's identical to DescrEQ.
func Descr(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDescr), v))
	})
}

// MaxTickers applies equality check predicate on the "MaxTickers" field. It's identical to MaxTickersEQ.
func MaxTickers(v int) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMaxTickers), v))
	})
}

// MaxTickersPerIndustry applies equality check predicate on the "MaxTickersPerIndustry" field. It's identical to MaxTickersPerIndustryEQ.
func MaxTickersPerIndustry(v int) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMaxTickersPerIndustry), v))
	})
}

// BaseIndex applies equality check predicate on the "BaseIndex" field. It's identical to BaseIndexEQ.
func BaseIndex(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBaseIndex), v))
	})
}

// LastYearInventResult applies equality check predicate on the "LastYearInventResult" field. It's identical to LastYearInventResultEQ.
func LastYearInventResult(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastYearInventResult), v))
	})
}

// LastYearYield applies equality check predicate on the "LastYearYield" field. It's identical to LastYearYieldEQ.
func LastYearYield(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastYearYield), v))
	})
}

// Last3YearsInvertResult applies equality check predicate on the "Last3YearsInvertResult" field. It's identical to Last3YearsInvertResultEQ.
func Last3YearsInvertResult(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLast3YearsInvertResult), v))
	})
}

// Last3YearsYield applies equality check predicate on the "Last3YearsYield" field. It's identical to Last3YearsYieldEQ.
func Last3YearsYield(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLast3YearsYield), v))
	})
}

// WeekRefillAmount applies equality check predicate on the "WeekRefillAmount" field. It's identical to WeekRefillAmountEQ.
func WeekRefillAmount(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWeekRefillAmount), v))
	})
}

// StartAmount applies equality check predicate on the "StartAmount" field. It's identical to StartAmountEQ.
func StartAmount(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStartAmount), v))
	})
}

// StartSimulation applies equality check predicate on the "StartSimulation" field. It's identical to StartSimulationEQ.
func StartSimulation(v *domains.JSDateOnly) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStartSimulation), v))
	})
}

// BuyOnlyLowPrice applies equality check predicate on the "BuyOnlyLowPrice" field. It's identical to BuyOnlyLowPriceEQ.
func BuyOnlyLowPrice(v bool) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBuyOnlyLowPrice), v))
	})
}

// AllowLossWhenSell applies equality check predicate on the "AllowLossWhenSell" field. It's identical to AllowLossWhenSellEQ.
func AllowLossWhenSell(v bool) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAllowLossWhenSell), v))
	})
}

// AllowSellToFit applies equality check predicate on the "AllowSellToFit" field. It's identical to AllowSellToFitEQ.
func AllowSellToFit(v bool) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAllowSellToFit), v))
	})
}

// SameEmitent applies equality check predicate on the "SameEmitent" field. It's identical to SameEmitentEQ.
func SameEmitent(v int) predicate.Strategy {
	vc := int(v)
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSameEmitent), vc))
	})
}

// DescrEQ applies the EQ predicate on the "Descr" field.
func DescrEQ(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDescr), v))
	})
}

// DescrNEQ applies the NEQ predicate on the "Descr" field.
func DescrNEQ(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDescr), v))
	})
}

// DescrIn applies the In predicate on the "Descr" field.
func DescrIn(vs ...string) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDescr), v...))
	})
}

// DescrNotIn applies the NotIn predicate on the "Descr" field.
func DescrNotIn(vs ...string) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDescr), v...))
	})
}

// DescrGT applies the GT predicate on the "Descr" field.
func DescrGT(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDescr), v))
	})
}

// DescrGTE applies the GTE predicate on the "Descr" field.
func DescrGTE(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDescr), v))
	})
}

// DescrLT applies the LT predicate on the "Descr" field.
func DescrLT(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDescr), v))
	})
}

// DescrLTE applies the LTE predicate on the "Descr" field.
func DescrLTE(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDescr), v))
	})
}

// DescrContains applies the Contains predicate on the "Descr" field.
func DescrContains(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldDescr), v))
	})
}

// DescrHasPrefix applies the HasPrefix predicate on the "Descr" field.
func DescrHasPrefix(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldDescr), v))
	})
}

// DescrHasSuffix applies the HasSuffix predicate on the "Descr" field.
func DescrHasSuffix(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldDescr), v))
	})
}

// DescrEqualFold applies the EqualFold predicate on the "Descr" field.
func DescrEqualFold(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldDescr), v))
	})
}

// DescrContainsFold applies the ContainsFold predicate on the "Descr" field.
func DescrContainsFold(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldDescr), v))
	})
}

// MaxTickersEQ applies the EQ predicate on the "MaxTickers" field.
func MaxTickersEQ(v int) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMaxTickers), v))
	})
}

// MaxTickersNEQ applies the NEQ predicate on the "MaxTickers" field.
func MaxTickersNEQ(v int) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMaxTickers), v))
	})
}

// MaxTickersIn applies the In predicate on the "MaxTickers" field.
func MaxTickersIn(vs ...int) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMaxTickers), v...))
	})
}

// MaxTickersNotIn applies the NotIn predicate on the "MaxTickers" field.
func MaxTickersNotIn(vs ...int) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMaxTickers), v...))
	})
}

// MaxTickersGT applies the GT predicate on the "MaxTickers" field.
func MaxTickersGT(v int) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMaxTickers), v))
	})
}

// MaxTickersGTE applies the GTE predicate on the "MaxTickers" field.
func MaxTickersGTE(v int) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMaxTickers), v))
	})
}

// MaxTickersLT applies the LT predicate on the "MaxTickers" field.
func MaxTickersLT(v int) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMaxTickers), v))
	})
}

// MaxTickersLTE applies the LTE predicate on the "MaxTickers" field.
func MaxTickersLTE(v int) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMaxTickers), v))
	})
}

// MaxTickersPerIndustryEQ applies the EQ predicate on the "MaxTickersPerIndustry" field.
func MaxTickersPerIndustryEQ(v int) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMaxTickersPerIndustry), v))
	})
}

// MaxTickersPerIndustryNEQ applies the NEQ predicate on the "MaxTickersPerIndustry" field.
func MaxTickersPerIndustryNEQ(v int) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMaxTickersPerIndustry), v))
	})
}

// MaxTickersPerIndustryIn applies the In predicate on the "MaxTickersPerIndustry" field.
func MaxTickersPerIndustryIn(vs ...int) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMaxTickersPerIndustry), v...))
	})
}

// MaxTickersPerIndustryNotIn applies the NotIn predicate on the "MaxTickersPerIndustry" field.
func MaxTickersPerIndustryNotIn(vs ...int) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMaxTickersPerIndustry), v...))
	})
}

// MaxTickersPerIndustryGT applies the GT predicate on the "MaxTickersPerIndustry" field.
func MaxTickersPerIndustryGT(v int) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMaxTickersPerIndustry), v))
	})
}

// MaxTickersPerIndustryGTE applies the GTE predicate on the "MaxTickersPerIndustry" field.
func MaxTickersPerIndustryGTE(v int) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMaxTickersPerIndustry), v))
	})
}

// MaxTickersPerIndustryLT applies the LT predicate on the "MaxTickersPerIndustry" field.
func MaxTickersPerIndustryLT(v int) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMaxTickersPerIndustry), v))
	})
}

// MaxTickersPerIndustryLTE applies the LTE predicate on the "MaxTickersPerIndustry" field.
func MaxTickersPerIndustryLTE(v int) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMaxTickersPerIndustry), v))
	})
}

// BaseIndexEQ applies the EQ predicate on the "BaseIndex" field.
func BaseIndexEQ(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBaseIndex), v))
	})
}

// BaseIndexNEQ applies the NEQ predicate on the "BaseIndex" field.
func BaseIndexNEQ(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBaseIndex), v))
	})
}

// BaseIndexIn applies the In predicate on the "BaseIndex" field.
func BaseIndexIn(vs ...string) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBaseIndex), v...))
	})
}

// BaseIndexNotIn applies the NotIn predicate on the "BaseIndex" field.
func BaseIndexNotIn(vs ...string) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBaseIndex), v...))
	})
}

// BaseIndexGT applies the GT predicate on the "BaseIndex" field.
func BaseIndexGT(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBaseIndex), v))
	})
}

// BaseIndexGTE applies the GTE predicate on the "BaseIndex" field.
func BaseIndexGTE(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBaseIndex), v))
	})
}

// BaseIndexLT applies the LT predicate on the "BaseIndex" field.
func BaseIndexLT(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBaseIndex), v))
	})
}

// BaseIndexLTE applies the LTE predicate on the "BaseIndex" field.
func BaseIndexLTE(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBaseIndex), v))
	})
}

// BaseIndexContains applies the Contains predicate on the "BaseIndex" field.
func BaseIndexContains(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldBaseIndex), v))
	})
}

// BaseIndexHasPrefix applies the HasPrefix predicate on the "BaseIndex" field.
func BaseIndexHasPrefix(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldBaseIndex), v))
	})
}

// BaseIndexHasSuffix applies the HasSuffix predicate on the "BaseIndex" field.
func BaseIndexHasSuffix(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldBaseIndex), v))
	})
}

// BaseIndexIsNil applies the IsNil predicate on the "BaseIndex" field.
func BaseIndexIsNil() predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldBaseIndex)))
	})
}

// BaseIndexNotNil applies the NotNil predicate on the "BaseIndex" field.
func BaseIndexNotNil() predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldBaseIndex)))
	})
}

// BaseIndexEqualFold applies the EqualFold predicate on the "BaseIndex" field.
func BaseIndexEqualFold(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldBaseIndex), v))
	})
}

// BaseIndexContainsFold applies the ContainsFold predicate on the "BaseIndex" field.
func BaseIndexContainsFold(v string) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldBaseIndex), v))
	})
}

// LastYearInventResultEQ applies the EQ predicate on the "LastYearInventResult" field.
func LastYearInventResultEQ(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastYearInventResult), v))
	})
}

// LastYearInventResultNEQ applies the NEQ predicate on the "LastYearInventResult" field.
func LastYearInventResultNEQ(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLastYearInventResult), v))
	})
}

// LastYearInventResultIn applies the In predicate on the "LastYearInventResult" field.
func LastYearInventResultIn(vs ...float64) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLastYearInventResult), v...))
	})
}

// LastYearInventResultNotIn applies the NotIn predicate on the "LastYearInventResult" field.
func LastYearInventResultNotIn(vs ...float64) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLastYearInventResult), v...))
	})
}

// LastYearInventResultGT applies the GT predicate on the "LastYearInventResult" field.
func LastYearInventResultGT(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLastYearInventResult), v))
	})
}

// LastYearInventResultGTE applies the GTE predicate on the "LastYearInventResult" field.
func LastYearInventResultGTE(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLastYearInventResult), v))
	})
}

// LastYearInventResultLT applies the LT predicate on the "LastYearInventResult" field.
func LastYearInventResultLT(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLastYearInventResult), v))
	})
}

// LastYearInventResultLTE applies the LTE predicate on the "LastYearInventResult" field.
func LastYearInventResultLTE(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLastYearInventResult), v))
	})
}

// LastYearYieldEQ applies the EQ predicate on the "LastYearYield" field.
func LastYearYieldEQ(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLastYearYield), v))
	})
}

// LastYearYieldNEQ applies the NEQ predicate on the "LastYearYield" field.
func LastYearYieldNEQ(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLastYearYield), v))
	})
}

// LastYearYieldIn applies the In predicate on the "LastYearYield" field.
func LastYearYieldIn(vs ...float64) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLastYearYield), v...))
	})
}

// LastYearYieldNotIn applies the NotIn predicate on the "LastYearYield" field.
func LastYearYieldNotIn(vs ...float64) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLastYearYield), v...))
	})
}

// LastYearYieldGT applies the GT predicate on the "LastYearYield" field.
func LastYearYieldGT(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLastYearYield), v))
	})
}

// LastYearYieldGTE applies the GTE predicate on the "LastYearYield" field.
func LastYearYieldGTE(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLastYearYield), v))
	})
}

// LastYearYieldLT applies the LT predicate on the "LastYearYield" field.
func LastYearYieldLT(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLastYearYield), v))
	})
}

// LastYearYieldLTE applies the LTE predicate on the "LastYearYield" field.
func LastYearYieldLTE(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLastYearYield), v))
	})
}

// Last3YearsInvertResultEQ applies the EQ predicate on the "Last3YearsInvertResult" field.
func Last3YearsInvertResultEQ(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLast3YearsInvertResult), v))
	})
}

// Last3YearsInvertResultNEQ applies the NEQ predicate on the "Last3YearsInvertResult" field.
func Last3YearsInvertResultNEQ(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLast3YearsInvertResult), v))
	})
}

// Last3YearsInvertResultIn applies the In predicate on the "Last3YearsInvertResult" field.
func Last3YearsInvertResultIn(vs ...float64) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLast3YearsInvertResult), v...))
	})
}

// Last3YearsInvertResultNotIn applies the NotIn predicate on the "Last3YearsInvertResult" field.
func Last3YearsInvertResultNotIn(vs ...float64) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLast3YearsInvertResult), v...))
	})
}

// Last3YearsInvertResultGT applies the GT predicate on the "Last3YearsInvertResult" field.
func Last3YearsInvertResultGT(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLast3YearsInvertResult), v))
	})
}

// Last3YearsInvertResultGTE applies the GTE predicate on the "Last3YearsInvertResult" field.
func Last3YearsInvertResultGTE(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLast3YearsInvertResult), v))
	})
}

// Last3YearsInvertResultLT applies the LT predicate on the "Last3YearsInvertResult" field.
func Last3YearsInvertResultLT(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLast3YearsInvertResult), v))
	})
}

// Last3YearsInvertResultLTE applies the LTE predicate on the "Last3YearsInvertResult" field.
func Last3YearsInvertResultLTE(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLast3YearsInvertResult), v))
	})
}

// Last3YearsYieldEQ applies the EQ predicate on the "Last3YearsYield" field.
func Last3YearsYieldEQ(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLast3YearsYield), v))
	})
}

// Last3YearsYieldNEQ applies the NEQ predicate on the "Last3YearsYield" field.
func Last3YearsYieldNEQ(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLast3YearsYield), v))
	})
}

// Last3YearsYieldIn applies the In predicate on the "Last3YearsYield" field.
func Last3YearsYieldIn(vs ...float64) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLast3YearsYield), v...))
	})
}

// Last3YearsYieldNotIn applies the NotIn predicate on the "Last3YearsYield" field.
func Last3YearsYieldNotIn(vs ...float64) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLast3YearsYield), v...))
	})
}

// Last3YearsYieldGT applies the GT predicate on the "Last3YearsYield" field.
func Last3YearsYieldGT(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLast3YearsYield), v))
	})
}

// Last3YearsYieldGTE applies the GTE predicate on the "Last3YearsYield" field.
func Last3YearsYieldGTE(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLast3YearsYield), v))
	})
}

// Last3YearsYieldLT applies the LT predicate on the "Last3YearsYield" field.
func Last3YearsYieldLT(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLast3YearsYield), v))
	})
}

// Last3YearsYieldLTE applies the LTE predicate on the "Last3YearsYield" field.
func Last3YearsYieldLTE(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLast3YearsYield), v))
	})
}

// WeekRefillAmountEQ applies the EQ predicate on the "WeekRefillAmount" field.
func WeekRefillAmountEQ(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWeekRefillAmount), v))
	})
}

// WeekRefillAmountNEQ applies the NEQ predicate on the "WeekRefillAmount" field.
func WeekRefillAmountNEQ(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldWeekRefillAmount), v))
	})
}

// WeekRefillAmountIn applies the In predicate on the "WeekRefillAmount" field.
func WeekRefillAmountIn(vs ...float64) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldWeekRefillAmount), v...))
	})
}

// WeekRefillAmountNotIn applies the NotIn predicate on the "WeekRefillAmount" field.
func WeekRefillAmountNotIn(vs ...float64) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldWeekRefillAmount), v...))
	})
}

// WeekRefillAmountGT applies the GT predicate on the "WeekRefillAmount" field.
func WeekRefillAmountGT(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldWeekRefillAmount), v))
	})
}

// WeekRefillAmountGTE applies the GTE predicate on the "WeekRefillAmount" field.
func WeekRefillAmountGTE(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldWeekRefillAmount), v))
	})
}

// WeekRefillAmountLT applies the LT predicate on the "WeekRefillAmount" field.
func WeekRefillAmountLT(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldWeekRefillAmount), v))
	})
}

// WeekRefillAmountLTE applies the LTE predicate on the "WeekRefillAmount" field.
func WeekRefillAmountLTE(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldWeekRefillAmount), v))
	})
}

// StartAmountEQ applies the EQ predicate on the "StartAmount" field.
func StartAmountEQ(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStartAmount), v))
	})
}

// StartAmountNEQ applies the NEQ predicate on the "StartAmount" field.
func StartAmountNEQ(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStartAmount), v))
	})
}

// StartAmountIn applies the In predicate on the "StartAmount" field.
func StartAmountIn(vs ...float64) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldStartAmount), v...))
	})
}

// StartAmountNotIn applies the NotIn predicate on the "StartAmount" field.
func StartAmountNotIn(vs ...float64) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldStartAmount), v...))
	})
}

// StartAmountGT applies the GT predicate on the "StartAmount" field.
func StartAmountGT(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldStartAmount), v))
	})
}

// StartAmountGTE applies the GTE predicate on the "StartAmount" field.
func StartAmountGTE(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldStartAmount), v))
	})
}

// StartAmountLT applies the LT predicate on the "StartAmount" field.
func StartAmountLT(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldStartAmount), v))
	})
}

// StartAmountLTE applies the LTE predicate on the "StartAmount" field.
func StartAmountLTE(v float64) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldStartAmount), v))
	})
}

// StartSimulationEQ applies the EQ predicate on the "StartSimulation" field.
func StartSimulationEQ(v *domains.JSDateOnly) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStartSimulation), v))
	})
}

// StartSimulationNEQ applies the NEQ predicate on the "StartSimulation" field.
func StartSimulationNEQ(v *domains.JSDateOnly) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStartSimulation), v))
	})
}

// StartSimulationIn applies the In predicate on the "StartSimulation" field.
func StartSimulationIn(vs ...*domains.JSDateOnly) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldStartSimulation), v...))
	})
}

// StartSimulationNotIn applies the NotIn predicate on the "StartSimulation" field.
func StartSimulationNotIn(vs ...*domains.JSDateOnly) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldStartSimulation), v...))
	})
}

// StartSimulationGT applies the GT predicate on the "StartSimulation" field.
func StartSimulationGT(v *domains.JSDateOnly) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldStartSimulation), v))
	})
}

// StartSimulationGTE applies the GTE predicate on the "StartSimulation" field.
func StartSimulationGTE(v *domains.JSDateOnly) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldStartSimulation), v))
	})
}

// StartSimulationLT applies the LT predicate on the "StartSimulation" field.
func StartSimulationLT(v *domains.JSDateOnly) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldStartSimulation), v))
	})
}

// StartSimulationLTE applies the LTE predicate on the "StartSimulation" field.
func StartSimulationLTE(v *domains.JSDateOnly) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldStartSimulation), v))
	})
}

// BuyOnlyLowPriceEQ applies the EQ predicate on the "BuyOnlyLowPrice" field.
func BuyOnlyLowPriceEQ(v bool) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBuyOnlyLowPrice), v))
	})
}

// BuyOnlyLowPriceNEQ applies the NEQ predicate on the "BuyOnlyLowPrice" field.
func BuyOnlyLowPriceNEQ(v bool) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBuyOnlyLowPrice), v))
	})
}

// AllowLossWhenSellEQ applies the EQ predicate on the "AllowLossWhenSell" field.
func AllowLossWhenSellEQ(v bool) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAllowLossWhenSell), v))
	})
}

// AllowLossWhenSellNEQ applies the NEQ predicate on the "AllowLossWhenSell" field.
func AllowLossWhenSellNEQ(v bool) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAllowLossWhenSell), v))
	})
}

// AllowSellToFitEQ applies the EQ predicate on the "AllowSellToFit" field.
func AllowSellToFitEQ(v bool) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAllowSellToFit), v))
	})
}

// AllowSellToFitNEQ applies the NEQ predicate on the "AllowSellToFit" field.
func AllowSellToFitNEQ(v bool) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAllowSellToFit), v))
	})
}

// SameEmitentEQ applies the EQ predicate on the "SameEmitent" field.
func SameEmitentEQ(v int) predicate.Strategy {
	vc := int(v)
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSameEmitent), vc))
	})
}

// SameEmitentNEQ applies the NEQ predicate on the "SameEmitent" field.
func SameEmitentNEQ(v int) predicate.Strategy {
	vc := int(v)
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSameEmitent), vc))
	})
}

// SameEmitentIn applies the In predicate on the "SameEmitent" field.
func SameEmitentIn(vs ...int) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = int(vs[i])
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSameEmitent), v...))
	})
}

// SameEmitentNotIn applies the NotIn predicate on the "SameEmitent" field.
func SameEmitentNotIn(vs ...int) predicate.Strategy {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = int(vs[i])
	}
	return predicate.Strategy(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSameEmitent), v...))
	})
}

// SameEmitentGT applies the GT predicate on the "SameEmitent" field.
func SameEmitentGT(v int) predicate.Strategy {
	vc := int(v)
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSameEmitent), vc))
	})
}

// SameEmitentGTE applies the GTE predicate on the "SameEmitent" field.
func SameEmitentGTE(v int) predicate.Strategy {
	vc := int(v)
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSameEmitent), vc))
	})
}

// SameEmitentLT applies the LT predicate on the "SameEmitent" field.
func SameEmitentLT(v int) predicate.Strategy {
	vc := int(v)
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSameEmitent), vc))
	})
}

// SameEmitentLTE applies the LTE predicate on the "SameEmitent" field.
func SameEmitentLTE(v int) predicate.Strategy {
	vc := int(v)
	return predicate.Strategy(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSameEmitent), vc))
	})
}

// HasUser applies the HasEdge predicate on the "User" edge.
func HasUser() predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(UserTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, UserTable, UserColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasUserWith applies the HasEdge predicate on the "User" edge with a given conditions (other predicates).
func HasUserWith(preds ...predicate.User) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(UserInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, UserTable, UserColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasFactors applies the HasEdge predicate on the "Factors" edge.
func HasFactors() predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(FactorsTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, FactorsTable, FactorsColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasFactorsWith applies the HasEdge predicate on the "Factors" edge with a given conditions (other predicates).
func HasFactorsWith(preds ...predicate.StrategyFactor) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(FactorsInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, FactorsTable, FactorsColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasFilters applies the HasEdge predicate on the "Filters" edge.
func HasFilters() predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(FiltersTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, FiltersTable, FiltersColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasFiltersWith applies the HasEdge predicate on the "Filters" edge with a given conditions (other predicates).
func HasFiltersWith(preds ...predicate.StrategyFilter) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(FiltersInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, FiltersTable, FiltersColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// HasFixedTickers applies the HasEdge predicate on the "FixedTickers" edge.
func HasFixedTickers() predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(FixedTickersTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, FixedTickersTable, FixedTickersColumn),
		)
		sqlgraph.HasNeighbors(s, step)
	})
}

// HasFixedTickersWith applies the HasEdge predicate on the "FixedTickers" edge with a given conditions (other predicates).
func HasFixedTickersWith(preds ...predicate.StrategyFixedTicker) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		step := sqlgraph.NewStep(
			sqlgraph.From(Table, FieldID),
			sqlgraph.To(FixedTickersInverseTable, FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, FixedTickersTable, FixedTickersColumn),
		)
		sqlgraph.HasNeighborsWith(s, step, func(s *sql.Selector) {
			for _, p := range preds {
				p(s)
			}
		})
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Strategy) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Strategy) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Strategy) predicate.Strategy {
	return predicate.Strategy(func(s *sql.Selector) {
		p(s.Not())
	})
}
